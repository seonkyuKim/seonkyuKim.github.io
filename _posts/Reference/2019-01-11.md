# Base views

다음 세 클래스들은 장고 view를 만드는데 필요한 많은 기능을 제공합니다. 그것들을 부모 view로 생각할 수 있으며, 그것은 스스로 사용되거나 상속될 수 있습니다. 프로젝트에 필요한 모든 기능을 제공하지 않을 수 있으며, 이러한 경우를 위해 Mixins 및 일반적인 클래스 기반 view가 있습니다.

장고에 내장된 클래스 기반 view의 대부분은 다른 클래스 기반 view 또는 다양한 mixins에서 상속받습니다. 이 상속사슬은 매우 중요하기 때문에 조상클래스는 **Ancestors (MRO)** 섹션 제목 아래에 문서화 되어 있습니다. MRO는 Method Resolution Order의 약자입니다.

# View

**class django.views.generic.base.View**

마스터 클래스 기반 view. 다른 모든 클래스 기반 view는 이 기본클래스에서 상속됩니다. 그것은 엄격하게 일반적인 view가 아니므로 **django.views**에서 가져올 수도 있습니다.

**매소드 흐름도**

1. **`dispatch()`**
2. **`http_method_not_allowed()`**
3. **`options()`**

**views.py 예제 :** 

    from django.http import HttpResponse
    from django.views import View
    
    class MyView(View):
    
        def get(self, request, *args, **kwargs):
            return HttpResponse('Hello, World!')

**urls.py 예제 :** 

    from django.urls import path
    
    from myapp.views import MyView
    
    urlpatterns = [
        path('mine/', MyView.as_view(), name='my-view'),
    ]

**Attributes**

**http_method_names**

이 view에서 허용할 HTTP 메소드 이름의 리스트.

기본값 : 

    ['get', 'post', 'put', 'patch', 'delete', 'head', 'options', 'trace']

**Methods**

**classmethod as_view(***initkwargs*)**

요청을 받아 응답을 반환하는 호출가능한 view를 반환합니다 : 

    response = MyView.as_view()(request)

반환된 view에는 **view_class** 및 **view_initkwargs** attribute가 있습니다.

요청/응답 사이클 중 view가 호출되면, **`HttpRequest`**가 view의 **요청** attribute에 할당됩니다. `URL 패턴에서 캡처된` positional 및/또는 keyword argument는 **args** 및 **kwargs** 특성에 할당되는 것으로 나타납니다. 그런 다음 **`dispatch()`**가 호출됩니다.

**dispatch(*request, args, *kwargs*)**

**view** 부분의 view - 요청 argument와 argument를 받아들이고, HTTP 응답을 반환하는 메소드입니다.

기본 도구는 HTTP 메소드를 검사하고 그것과 매치되는 메소드에 위임하려 합니다; **GET**은 **get()**으로, **POST**는 **post()**로 위임됩니다.

기본적으로 **HEAD** 요청은 **get()**에 위임됩니다. **GET**과 다른 방법으로 **HEAD** 요청을 처리해야하는 경우 **head()** 메소드를 오버라이드할 수 있습니다. 예제로 `다른 HTTP 메소드 지원`을 참조하십시오.

**http_method_not_allowed(*request, args, *kwargs*)**

view가 지원하지 않는 HTTP 메소드로 호출된 경우, 이 메소드가 대신 호출됩니다.

기본 도구는 허용된 메소드의 리스트를 일반 텍스트로 사용하여 **HttpResponseNotAllowed**를 반환합니다.

**options(*request, args, *kwargs*)**

OPTION HTTP 동사에 대한 요청에 응답하는 handlers. view의 허용된 HTTP 메소드 이름 리스트를 포함하는 **Allow** 헤더와 응답을 반환합니다.

---

# TemplateView

**class django.views.generic.base.TemplateView**

URL로 캡처된 매개변수를 포함한 context를 사용해, 지정된 템플릿을 렌더링합니다.

**Ancestors (MRO)**

이 view는 다음 view에서 메소드와 attribute를 상속합니다 : 

- **`django.views.generic.base.TemplateResponseMixin`**
- **`django.views.generic.base.ContextMixin`**
- **`django.views.generic.base.View`**

**메소드 흐름도**

1. **`dispatch()`**
2. **`http_method_not_allowed()`**
3. **`get_context_data()`**

**views.py** **예제 :** 

    from django.views.generic.base import TemplateView
    
    from articles.models import Article
    
    class HomePageView(TemplateView):
    
        template_name = "home.html"
    
        def get_context_data(self, **kwargs):
            context = super().get_context_data(**kwargs)
            context['latest_articles'] = Article.objects.all()[:5]
            return context

**urls.py 예제 :** 

    from django.urls import path
    
    from myapp.views import HomePageView
    
    urlpatterns = [
        path('', HomePageView.as_view(), name='home'),
    ]

**Context**

- view를 제공한 URL 패턴에서 캡처한 keyword argument로(**`ContextMixin`**을 통해) 채웁니다.
- **`as_view()`**에 대한 **`extra_context`** keyword argument를 사용하여 context를 추가할 수 있습니다.

---

# RedirectView

**class django.views.generic.base.RedirectView**

주어진 URL로 리디렉트한다.

주어진 URL은 URL에서 캡처된 매개변수에 대해 삽입될 사전-스타일 문자열 형식을 포함할 수 있습니다. 키워드 삽입은 항상 수행되기 때문에(argument가 전달되지 않은 경우에도), 파이썬이 출력 시 하나의 퍼센트 부호로 변환할 수 있도록 URL의 "%"문자는 반드시 "%%"로 작성되어야 합니다.

주어진 URL이 **None**이면 장고는 **HttpResponseGone** (410)을 반환합니다.

**Ancestors (MRO)**

이 view는 다음 view에서 메소드 및 attribute를 상속합니다 : 

- **`django.views.generic.base.View`**

**메소드 흐름도**

1. **`dispatch()`**
2. **`http_method_not_allowed()`**
3. **`get_redirect_url()`**

**views.py 예제 :** 

    from django.shortcuts import get_object_or_404
    from django.views.generic.base import RedirectView
    
    from articles.models import Article
    
    class ArticleCounterRedirectView(RedirectView):
    
        permanent = False
        query_string = True
        pattern_name = 'article-detail'
    
        def get_redirect_url(self, *args, **kwargs):
            article = get_object_or_404(Article, pk=kwargs['pk'])
            article.update_counter()
            return super().get_redirect_url(*args, **kwargs)

**urls.py 예제 :** 

    from django.urls import path
    from django.views.generic.base import RedirectView
    
    from article.views import ArticleCounterRedirectView, ArticleDetail
    
    urlpatterns = [
        path('counter/<int:pk>/', ArticleCounterRedirectView.as_view(), name='article-counter'),
        path('details/<int:pk>/', ArticleDetail.as_view(), name='article-detail'),
        path('go-to-django/', RedirectView.as_view(url='https://djangoproject.com'), name='go-to-django'),
    ]

**Attribute**

**url**

리디렉트할 URL입니다(문자열). **None**이면 410 (Gone) HTTP 에러가 발생합니다.

**pattern_name**

리디렉트할 URL 패턴의 이름입니다. 리버싱은 이 view에서 전달된 것과 동일한 args 및 kwargs를 사용하여 수행됩니다.

**permanent**

리디렉트가 영구적이어야하는지에 대한 여부. 유일한 차이점은 반환된 HTTP 상태코드입니다. **True**면 리디렉트는 상태코드 301을 사용합니다. **False**라면 리디렉트는 상태코드 302를 사용합니다. 기본적으로 **permanent**는 **False**입니다.

**query_string**

GET 쿼리 문자열을 새 위치로 전달할지에 대한 여부입니다. **True**면 쿼리 문자열이 URL에 추가됩니다. **False**면 쿼리 문자열이 폐기됩니다. 기본적으로 **query_string**은 **False**입니다.

**Methods**

**get_redirect_url(**args, **kwargs*)**

리디렉션의 목표 URL을 구축합니다.

기본 도구에서는 **`url`**을 시작 문자열로 사용하고 URL에 캡처된 명명된 그룹을 사용하여 해당 문자열에서 % 명명된 매개변수의 확장을 수행합니다.

**`url`**이 설정되지 않은 경우, **get_redirect_url()**은 URL에 캡처된 것을 사용하여 **`pattern_name`**을 리버스하려고 시도합니다(명명된 그리고 명명되지 않은 그룹 모두 사용됨).

**`query_string`**이 요청되면, 쿼리 문자열을 생성된 URL에 추가합니다. 서브클래스는 메소드가 리디렉트 가능한 URL 문자열을 반환하는 한 원하는 모든 동작을 구현할 수 있습니다.
