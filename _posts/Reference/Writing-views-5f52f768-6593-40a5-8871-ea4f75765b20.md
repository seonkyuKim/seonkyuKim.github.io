# Writing views

view함수 또는 간단히 말해 view는 웹 요청을 받아들여 웹 응답을 반환하는 파이썬 함수입니다. 이 응답은 웹 페이지의 HTML내용, 리디렉트, 404 에러, XML 문서, 이미지 또는 그 밖에 다른 것들일 수 있습니다. view 자체에는 해당 응답을 반환하는데 필요한 임의의 논리가 포함되어 있으며, 이 코드는 파이썬 경로에 있는 한 원하는 곳 어디에서나 사용할 수 있습니다. 그외의 다른 요구사항은 없습니다. 말하자면 "마법"은 없다고 말할 수 있습니다. 코드를 어딘가에 넣기 위한 관례로써, view를 프로젝트 또는 애플리케이션 디렉토리에 있는 views.py라는 파일에 넣습니다.

# A simple view

다음은 현재 날씨와 시간을 HTML 문서로 반환하는 view이다 : 

    from django.http import HttpResponse
    import datetime
    
    def current_datetime(request):
        now = datetime.datetime.now()
        html = "<html><body>It is now %s.</body></html>" % now
        return HttpResponse(html)

한 번에 한 줄씩 이 코드를 단계별로 살펴보면 : 

- 먼저, 파이썬의 **datetime** 라이브러리와 함께 **`django.http`**모듈에서 **`HttpResponse`**클래스를 가져옵니다.
- 다음으로 **current_datetime**이라는 함수를 정의합니다. 이것은 view함수입니다. 각 view함수는 첫 번째 매개변수로 **`HttpRequest`**객체를 사용하며, 일반적으로 **request**라는 이름이 사용됩니다.

    view함수의 이름은 중요하지 않습니다; 장고가 그것을 인식할 수 있도록 특정 방식으로 이름을 지정할 필요는 없습니다. 우리는 여기에서 그것을 **current_datetime**이라고 부르는 이유는 그 이름으로 분명히 나타내기 때문입니다.

- view는 생성된 응답을 포함하는 **`HttpResponse`**객체를 반환합니다. 각각의 view함수는 **`HttpResponse`**객체를 반환합니다. (예외는 있지만 나중에 설명하겠습니다.)

> **Django's Time Zone**

장고에는 **`TIME_ZONE`**설정이 기본적으로 **America/Chicago**로 설정되어 있습니다. 이것은 아마 당신이 살고있는 곳이 아니기 때문에, 당신은 설정파일에서 그것을 바꾸고 싶어할 것입니다.

---

# Mapping URLs to views

요약하자면, 이 view함수는 현재 날짜와 시간을 포함하는 HTML 페이지를 반환합니다. 특정 URL에 이 view를 표시하려면 URLconf를 만들어야 합니다; 자세한 내용은 `URL dispatcher`를 참조하세요.

---

# Returning errors

장고에서 HTTP error 코드를 리턴하는 것은 쉽습니다. 200(이는 "OK"를 의미함) 이외의 일반적인 HTTP 상태코드에 대한 **`HttpResponse`**의 하위클래스가 있습니다. 당신은 요청/응답 문서에서 사용가능한 하위클래스의 전체 리스트를 찾을 수 있습니다. 오류를 나타내기 위해선 일반 **`HttpResponse`**대신 해당 하위클래스 중 하나의 인스턴스만 반환하면 됩니다. 예를 들어 : 

    from django.http import HttpResponse, HttpResponseNotFound
    
    def my_view(request):
        # ...
        if foo:
            return HttpResponseNotFound('<h1>Page not found</h1>')
        else:
            return HttpResponse('<h1>Page was found</h1>')

가능한 모든 HTTP 응답코드에 대해 특수 하위클래스가 없는 이유는 그것들 중 많은 수가 흔히 사용되지는 않을 것이기 때문입니다. 그러나 **`HttpResponse`**문서에 설명된 것처럼 **`HttpResponse`**생성자에 HTTP상태코드를 전달하여 원하는 상태코드에 대한 반환클래스를 만들 수 있습니다. 예를 들어 : 

    from django.http import HttpResponse
    
    def my_view(request):
        # ...
    
        # Return a "created" (201) response code.
        return HttpResponse(status=201)

404 에러가 가장 일반적인 HTTP 에러이기 때문에 이러한 에러를 처리하는 더 쉬운 방법이 있습니다.

## The Http404 exception

**class django.http.Http404**

**`HttpResponseNotFound`**와 같은 에러를 반환할 때, 당신은 결과 오류 페이지의 HTML을 정의해야 할 필요가 있습니다 : 

    return HttpResponseNotFound('<h1>Page not found</h1>')

편의상 사이트 전체에 걸처 일관적인 404 에러 페이지를 갖는 것이 좋기 때문에, 장고는 **Http404** 예외를 제공합니다. view함수의 어느 지점에서 **Http404**를 발생시키면, 장고는 그것을 포착하여 HTTP 에러코드 404와 함께 애플리케이션의 표준 에러 페이지를 반환합니다.

사용 예 : 

    from django.http import Http404
    from django.shortcuts import render
    from polls.models import Poll
     
    def detail(request ,poll_id):
        try:
            p=Poll.objects.get(pk=poll_id)
        except Poll.DoesNotExist:
            raise Http404("Poll does not exist")
        return render(request, 'polls/detail.html', {'poll': p})

장고가 404를 반환할 때, 사용자 정의된 HTML을 표시하기 위해선 **404.html**이라는 HTML 템플릿을 만들어 템플릿 트리의 최상위 레벨에 배치하면 됩니다. **`DEBUG`**가 **False**로 설정되면 이 템플릿이 제공됩니다.

**`DEBUG`**가 **True**면 **Http404**에 메세지를 제공할 수 있으며, 표준 404 디버그 템플릿에 나타납니다. 이러한 메세지를 디버깅 목적으로 사용합니다; 그것들은 일반적으로 생산된 404 템플릿에서 사용하기에 적합하지 않습니다.

---

# Customizing error views

장고의 기본 에러 view는 대부분의 웹 애플리케이션에서 충분하지만 커스텀 동작이 필요한 경우 쉽게 오버라이드 할 수 있습니다. 아래에 표시된 것처럼 URLconf에서 handler를 지정하면 됩니다(다른 곳에서는 아무것도 설정하지 않아도 된다.)

**`page_not_found()`** view는 **`handler404`**에 의해 오버라이드된다 : 

    handler404 = 'mysite.views.my_custom_page_not_found_view'

`**server_error()**` view는 **`handler500`**에 의해 오버라이드된다 : 

    handler500 = 'mysite.views.my_custom_error_view'

**`permission_denied()`** view는 **`handler403`**에 의해 오버라이드된다 : 

    handler403 = 'mysite.views.my_custom_permission_denied_view'

**`bad_request()`** view는 **`handler400`**에 의해 오버라이드된다 : 

    handler400 = 'mysite.views.my_custom_bad_request_view'

> **See also**

**`CSRF_FAILURE_VIEW`**설정을 사용하여 **CSRF error view**를 **오버라이드**하십시오.

## Testing custom error views

사용자 정의 에러 handler의 응답을 테스트하려면, 테스트 view에서 적절한 예외를 발생시킵니다. 예 : 

    from django.core.exceptions import PermissionDenied
    from django.http import HttpResponse
    from django.test import SimpleTestCase, override_settings
    from django.urls import path
    
    
    def response_error_handler(request, exception=None):
        return HttpResponse('Error handler content', status=403)
    
    
    def permission_denied_view(request):
        raise PermissionDenied
    
    
    urlpatterns = [
        path('403/', permission_denied_view),
    ]
    
    handler403 = response_error_handler
    
    
    # ROOT_URLCONF must specify the module that contains handler403 = ...
    @override_settings(ROOT_URLCONF=__name__)
    class CustomErrorHandlerTests(SimpleTestCase):
    
        def test_handler_renders_template_response(self):
            response = self.client.get('/403/')
            # Make assertions on the response here. For example:
            self.assertContains(response, 'Error handler content', status_code=403)