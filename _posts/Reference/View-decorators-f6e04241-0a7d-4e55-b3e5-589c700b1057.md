# View decorators

장고는 다양한 HTTP 기능을 지원하기 위해 view에 적용할 수있는 몇가지 데코레이터를 제공합니다.

# Allowed HTTP methods

**`django.views.decorators.http`**의 데코레이터를 사용하여 요청 메소드를 기반으로 view에 대한 접근을 제한할 수 있습니다. 이 데코레이터는 조건이 충족되지 않을 시 **`django.http.HttpResponseNotAllowed`**를 반환합니다.

**require_http_methods(*request_method_list*)`[source]`**

데코레이터는 view가 특정 요청 메소드만 허용하도록 요구합니다. 사용 예 : 

    from django.views.decorators.http import require_http_methods
     
    @require_http_methods(["GET", "POST"])
    def my_view(request):
        # 이제는 GET 또는 POST 요청만으로 이 작업을 수행할 수 있다고 가정할 수 있습니다
        # ...
        pass

요청 메소드는 대문자여야한다는 것을 숙지하십시오.

**require_GET()**

데코레이터는 view가 GET 메소드만 허용하도록 요구합니다.

**require_POST()**

데코레이터는 view가 POST 메소드만 허용하도록 요구합니다.

**require_safe()**

데코레이터는 view가 GET 및 HEAD 메소드만 허용하도록 요구합니다. 이 메소드는 요청된 리소스를 검색하는 것 이외의 조치를 취하면 안되기 때문에 일반적으로 "safe"하다고 간주됩니다.

> **Note**

웹 서버는 헤더를 변경하지 않고 HEAD 요청에 대한 응답내용을 자동으로 삭제해야하므로 view의 GET 요청과 똑같이 HEAD 요청을 처리할 수 있습니다. 링크 검사기와 같은 일부 소프트웨어는 HEAD 요청에 의존하므로 **require_GET** 대신 **require_safe**를 사용하는 것이 좋습니다.

---

# Conditional view processing

**`django.views.decorators.http`**의 다음 데코레이터는 특정 view의 캐싱 동작을 제어하는데 사용할 수 있습니다.

**condition(*etag_func=None, last_modified_func=None*)`[source]`**

**etag(*etag_func*)`[source]`**

**last_modified(*last_modified_func*)`[source]`**

이러한 데코레이터들은 **ETag** 및 **Last-Modified**헤더를 생성하는데 사용할 수 있습니다; `조건부 뷰 처리`를 참조하십시오.

---

# GZip compression

**`django.views.decorators.gzip`**의 데코레이터는 view 단위로 내용 압축을 제어합니다.

**gzip_page()**

브라우저가 gzip 압축을 허용하면 이 데코레이터는 내용을 압축합니다. 이에 따라 **Vary**헤더가 설정되므로 캐시는 **Accept-Encoding**헤더에서 저장소의 기준이 됩니다.

---

# Caching

**django.views.decorators.cache**의 데코레이터는 서버와 클라이언트 측 캐싱을 제어합니다.

**cache_control(***kwargs*)`[source]`**

이 데코레이터는 모든 keyword argument를 추가하여 응답의 **Cache_Control**헤더를 패치합니다. 변환에 대한 자세한 내용은 **`patch_cache_control()`**을 참조하십시오.

**never_cache(*view_func*)`[source]`**

이 데코레이터는 **Cache-Control : max-age=0, no-cache, no-store, must-revalidate** 헤더를 응답에 추가하여 페이지를 절대 캐시하지 않아야 함을 나타냅니다.