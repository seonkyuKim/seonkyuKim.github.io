---
title: "Git의 기초"
categories: git-tutorial
tags:
- git
- tutorial
toc: true
author_profile: true
---

# 들어가며

Git은 왜 필요할까요? 프로젝트를 하다보면 데이터 백업을 해두어 원하는 버전으로 돌아가고 싶을 때가 있습니다. 아마 가장 유사한 예시는 '자기소개서'를 작성할 때가 아닌가 싶습니다. 수정을 계속하지만, 혹시 이전 버전으로 돌아갈 때를 대비하여 새로운 파일로 따로 저장합니다. 기본 자기소개서에서 원하는 대학, 혹은 기업에 따라 자기소개서 버전이 달라집니다. 해당 파일을 또 따로 만들어 둡니다:

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-0bb9fb7f-5f50-4b9a-9777-3e0044e9ae8b.png){: .align-center}

프로젝트를 할 때도 마찬가지 입니다. 혹시 모를 상황에 대비해 이전 버전들을 백업해 두어야 합니다. 또한, 시작은 한 프로젝트지만, 그 과정에서 여러 가지 갈래로 나뉠 수도 있습니다. 추가로, 자기소개서와 달리 프로젝트는 여러 사람이 협업을 해야하는 경우가 대부분입니다.

Git은 이와 같은 일들을 체계적으로 할 수 있게 도와줍니다. **여러분의 꿈이 단순 양산형 코더가 아닌, 주도적으로 프로젝트를 진행하는 것이라면 git을 잘 다루는 것은 필수적이라 할 수 있습니다.**

본 강의에서는 git을 자유롭게 다루는 것을 목표로 합니다. 그리고 이를 직접 경험하기 위해 하나의 소설을 여러분들과 같이 써볼 생각입니다. 여러분들의 상상력을 보여주세요!

# Git 설치하기

git에 대한 설명과 설치하기 방법을 알려주어야 하지만, 사실 이는 [git book](https://git-scm.com/book/ko/v2)에 너무 잘 나와 있습니다. **1단원을 모두 읽고 오시기 바랍니다**(이해가 안 되는 부분이 있어도 본 강의에서 다시 다루게 되므로 일단 한 번 읽고 오시기 바랍니다!). 

**Note**

git documentation 1 단원 "시작하기"에는 git에 대한 설명과 설치법, 최초 설정 방법이 나와있습니다. '1.5 Git 설치'에서 git을 설치하지 마시고 '1.6 Git 최초 설정'까지 읽으신 후 설치하는 것을 추천합니다.

**To-do List**

[ ]  git 설치하기

## 기본적인 리눅스/유닉스 명령어

---

> 터미널과 git bash를 다뤄보신 분은 이 부분을 넘어가셔도 좋습니다.

터미널을 열어보십시오. 윈도우 사용자께서는 git을 설치하면서 같이 설치된 git bash의 사용을 권해드립니다. 터미널을 처음 사용하시면 이것이 무엇인지조차 모르실 겁니다. 간단하게 mac에서는 finder, 윈도우에서는 윈도우탐색기(라이브러리)라고 생각하시면 됩니다. 차례대로 따라해 보시면 좋을 것 같습니다.

**Note**

bash란? [shell, bash, zbash의 간단 개념정리](https://ithub.tistory.com/205)를 보고 오시면 좋을 것 같습니다. 간단하게 명령 프롬포트에서는 사용하지 못하는 리눅스/유닉스 명령어를 윈도우에서 사용하실 수 있다고 생각하시면 됩니다.

**현재 위치 보기**: `pwd`

finder나 윈도우 탐색기를 처음 열 때, 특정 위치에서 열리게 됩니다. 터미널도 마찬가지입니다. `pwd` 명령어를 사용하여 현재 위치를 알 수 있습니다:

    mac$ pwd
    /Users/mac    # 출력 내용은 운영체제에 따라 다를 수 있습니다.

**파일 및 폴더 목록 보기** : `ls` 

finder나 윈도우 탐색기에서는 창을 열기만 하면 자동으로 어떤 파일과 폴더가 있는지 보여주지만, 터미널에서는 위의 명령어를 쳐주어야 합니다. `ls -a`는 현재 위치의 숨김 파일까지 모두 보여줍니다. 직접 확인해보세요!

    mac$ ls
    # 출력 내용은 사용자의 컴퓨터에 어떤 파일과 폴더가 있냐에 따라 달라집니다.
    Applications
    Desktop    # 이 폴더가 바탕화면을 의미합니다.
    Documents
    ...

**디렉토리 만들기**: `mkdir <filename>`

finder나 윈도우 탐색기에서의 '새폴더 만들기'와 같은 기능을 합니다. 현재 위치에 **mybook**이라는 디렉토리를 만들어 봅시다. 이후 `ls`를 실행하여 잘 만들어졌는지 확인해봅시다:

    $ mkdir mybook
    $ ls
    Applications
    Desktop
    Documents
    ...
    mybook    # 저희가 새로 만든 폴더입니다.

**이동하기** : `cd <path>` (  **.** 은 현재 디렉토리를, **..** 은 현재 위치를 기준으로 상위 디렉토리를 의미합니다)

`cd`를 이용하여 원하는 경로로 이동할 수 있습니다. 다음 예시를 보십시오:

    # 현재 위치 출력
    $ pwd
    /User/mac
    
    # 하위 디렉토리인 mybook으로 이동 후 현재 위치 출력
    $ cd mybook
    $ pwd
    /User/mac/mybook
    
    # 현재 디렉토리로 이동. 즉, 아무런 이동이 일어나지 않습니다.
    $ cd .
    $ pwd
    /User/mac/mybook
    
    # 상위 디렉토리로 이동
    $ cd ..
    $ pwd
    /User/mac

**파일 편집하기**: `vi <filename>` or `vim <filename>`

여러 종류의 에디터를 사용할 수 있습니다. 가장 많이 이용하는 vi/vim 에디터를 살펴보고 가도록 하겠습니다.

`vi <filename>`을 실행하면, 파일이 있는 경우 해당 파일의 내용을 볼 수 있습니다. 파일이 없는 경우, 해당 제목의 파일을 새로 만듭니다. 저희는 mybook 디렉토리로 이동하여 **mystory.txt** 이름의 파일을 만듭시다:

    $ vim mybook.txt

위 명령어를 실행하면 다음과 같이 뜹니다:

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/screenshot-1.png){: .align-center}


이때, 키보드에서 i를 누르시면 **INSERT MODE**로 변환되어 내용을 편집할 수 있습니다:

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/스크린샷 2019-02-20 오후 4.09.55.png){: .align-center}

(좌측 하단에 INSERT로 바뀐 것을 볼 수 있습니다)

내용을 다 입력했다면 **esc** → **:wq** 를 누르시면 저장됩니다:

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/스크린샷 2019-02-20 오후 4.11.17.png){: .align-center}

(**esc**를 누르고 입력하면 좌측 하단에 표시됩니다.)

만약 변경한 내용을 저장하지 않고 종료하고 싶다면 **esc** → **:q** 를 이용하시면 됩니다. 

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/스크린샷 2019-02-20 오후 4.11.47.png){: .align-center}

하단에 다음과 같은 메세지가 뜬다면 **esc** → **:q!**를 이용하시면 됩니다.

**파일 삭제하기**: `rm <filename>`

**폴더 삭제하기**: `rmdir <dirname>`

**Note**

파일이나 폴더가 삭제가 안 될 경우가 있습니다. 이때는 `-f` 옵션을 추가하여 실행해 보시길 바랍니다(강제로 삭제한다는 의미입니다). 다른 옵션들도 궁금하다면 참고하시길 바랍니다: [https://shaeod.tistory.com/506](https://shaeod.tistory.com/506)

# Git 저장소 만들기(git init)

저희의 소설을 관리해줄 저장소로 Git을 사용할 것이며, 주로 다음 두 가지 중 한 가지 방법으로 Git 저장소(repository)를 쓰기 시작합니다. 

1. 아직 버전관리를 하지 않는 로컬 디렉토리 하나를 선택해서 Git 저장소를 적용하는 방법
2. 다른 어딘가에서 Git 저장소를 *Clone* 하는 방법

첫 번째 방법으로 git 저장소를 만들어 보겠습니다. (두 번째 방법은 나중에 다룹니다.) 터미널을 열어 버전 관리를 하고자 하는 디렉토리로 이동하여 해당 디렉토리에 git을 시작합니다.

저희는 **mybook**이라는 디렉토리를 만들고 해당 디렉토리로 이동한 후 `git init` 명령을 실행합니다:

    $ mkdir mybook    # mybook 디렉토리를 만듭니다.
    $ cd mybook       # 해당 디렉토리로 이동합니다.
    $ git init        # 디렉토리에 git을 실행합니다.

`git init`은 해당 디렉토리 안에 '**.git**' 폴더를 만듭니다. '**.git**'의 내용에 대해서는  [git documentation](https://git-scm.com/book/ko/v2) '10. Git의 내부'에서 배우실 수 있습니다. `ls -a` 명령어를 치면 '**.git**' 디렉토리가 만들어 진 것을 확인할 수 있습니다.

**파일 앞의 .의 의미**

맥, 리눅스에서 숨김 폴더 및 파일를 의미합니다. 해당 폴더들은 `ls -a` 옵션을 이용해야만 볼 수 있습니다.

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-b64dc2b2-5656-42cc-8c65-c6e523193cf5.png){: .align-center}

**To-do List**

- [ ]  `git init` 실행 후 **.git** 폴더 확인하기

# 수정하고 저장소에 저장하기(git add, commit)

**mybook** 디렉토리 안에 `mystroy.txt`파일을 하나 만듭니다. 내용은 다음과 같습니다:

**mybook/mystory.txt**

    잭이라는 아이가 한국에 살았습니다. 머리가 좋지는 않았지만 매일매일 열심히 살았습니다.

> 파일 만들기에 어려움을 느끼시는 분께서는 **[기본적인 리눅스/유닉스 명령어](#)**를 보고 오시기 바랍니다.

`git add` 명령어를 사용하여 저장소에 저장할 수 있습니다:

    $ git add mystory.txt

아쉽게도 아직은 영구적인 '스냅샷'으로 저장되지 않았습니다. `git commit` 명령어를 이용하여 '스냅샷'인 커밋을 완료해 봅니다(이해가 안되시더라도 일단 따라해 봅시다):

    $ git commit -m "first stroy"

다음과 같이 표시된다면 첫 번째 커밋을 성공적으로 완료하신 겁니다:

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-1055ae5c-b16f-48ff-8945-8e4f2a7ed36c.png){: .align-center}

축하드립니다! 첫 번째 커밋을 완료했습니다. 이제 언제든지 "first story"가 '스냅샷'으로 저장되어 언제든 해당 버전으로 돌아갈 수 있습니다. 

## Working directory, Staging area, .git directory

---

왜 **add**와 **commit**, 총 두 번의 과정을 거쳐야 하는지 궁금하실 겁니다. 사실, 이 부분은 [git book](https://git-scm.com/book/ko/v2)의 '[1.3 Git의 기초](https://git-scm.com/book/ko/v2/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-Git-%EA%B8%B0%EC%B4%88)'에 기술되어 있지만 중요하기 때문에 한 번 더 다루고자 합니다. 

{% capture fig_image %}
![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-a11ad724-e6d0-404f-b735-6905c0ec09c8.png){: .align-center}
{% endcapture %}

{% capture fig_caption %}
(사진: [https://git-scm.com/book/ko/v2/시작하기-Git-기초](https://git-scm.com/book/ko/v2/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-Git-%EA%B8%B0%EC%B4%88))
{% endcapture %}

<figure>
{{ fig_img | markdownify | remove: "<p>" | remove: "</p>" }}
<figcaption>{{ fig_caption | markdownify | remove: "<p>" | remove: "</p>" }}</figcaption>
</figure>

git을 사용한 프로젝트에는 **크게 3가지 공간**이 있습니다. 작업을 하고 있는 로컬 컴퓨터의 공간인 '**워킹 디렉토리**(*working directory*)', 커밋할 파일에 대한 정보를 저장하는 '**스테이징 에어리어**(*staging area*)', 스테이징 에어리어의 파일들을 커밋하여 영구적인 스냅샷을 저장하는 장소인 '**Git 디렉토리**(.*git directory*)'가 있습니다. 

**Note**

사실, 스테이징 에어리어의 정보들도 '**.git**' 폴더 안에 있습니다. 위 세 가지 공간 구분은 물리적 구분이 아닌 공간의 성격에 따른 추상적인 구분이라 생각하시면 됩니다.

`git add <filename>` 명령어는 **워킹 디렉토리**의 **<filename>** 파일에 대한 정보를 **스테이징 에어리어**에 저장합니다. `git commit <filename>` 명령어는 **스테이징 에어리어**에 있는 **<filename>**의 파일의 정보를 이용하여 **.git** 디렉토리에 영구적인 스냅샷으로 저장합니다.(이 과정 자체와 저장된 영구적인 스냅샷 모두를 **'커밋'**이라 부릅니다).

즉, 저희는 `git add mystory.txt` 명령어를 이용하여 **mystory.txt** 파일에 대한 정보를 staging area에 저장한 후 `git commit mystory.txt` 명령어를 이용하여 **.git** 디렉토리에 커밋을 완료한 것입니다.

커밋을 할 때는 해당 커밋을 설명하는 메세지를 같이 저장해야 합니다. `-m "fisrt story"`의 의미는 커밋 메세지로 "first story"를 저장하라는 의미입니다.

**Note**

만약 `-m first story`를 입력하지 않을 경우 메세지를 입력할 수 있는 창이 새로 열릴 것입니다. 당황하지 마시고 INSERT모드로 바꾸신 후 메세지를 입력하고 저장하시면 됩니다. *만약 아무런 메세지를 입력하지 않을 경우 커밋되지 않습니다.*

**To-do List**

- [ ]  `git add`와 `git commit` 하기

## 파일의 상태 확인하기(git status)

---

아무것도 없이 소설을 쓰려니 너무 막막합니다. 새로운 파일을 추가하여 개요를 작성해 봅시다:

**mybook/outline.txt**

    머리가 좋지는 않아 열심히 살아도 성과가 안나옴.
    꿈에서 만난 토끼가 6자리 숫자를 알려줌.
    그 숫자로 로또가 당첨됨.

책의 내용을 수정해 봅시다:

**mybook/mystory.txt**

    잭이라는 아이가 한국에 살았습니다. 머리가 좋지는 않았지만 매일매일 열심히 살았습니다.
    하지만 그럼에도 불구하고 잭은 좋은 대학을 가지 못했습니다.

`git status` 명령어를 이용하여 파일들의 상태를 확인할 수 있습니다:

    $ git status

다음과 같이 나올 것입니다:

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-01be2ff7-cce4-481e-b620-1027d52cb8f5.png){: .align-center}

위 메세지를 이해하기 위해서는 **파일의 4가지 상태**에 대해 알아야 합니다.

**Note**

앞에서는 '공간'의 분류를 세 가지로 했다면, 지금은 '**파일의 상태**'를 분류하는 것입니다.

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-36f780e4-6dbd-4fc5-9782-778beffcf2e5.png){: .align-center}

(사진: [https://git-scm.com/book/ko/v2/Git의-기초-수정하고-저장소에-저장하기](https://git-scm.com/book/ko/v2/Git%EC%9D%98-%EA%B8%B0%EC%B4%88-%EC%88%98%EC%A0%95%ED%95%98%EA%B3%A0-%EC%A0%80%EC%9E%A5%EC%86%8C%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%98%EA%B8%B0))

**워킹 디렉토리의 파일은 먼저 크게 Untracked, Tracked의 두 가지 상태로 나뉩니다.** 파일을 새로 만들 경우 Untracked 상태, 즉 git이 파일을 추적하지 않는 상태가 됩니다. 저장할 필요가 없는 파일들은 Untracked 상태로 두시면 됩니다. 이후 `git add` 명령어를 이용하여 파일을 add해주면, 앞에서 배운 것처럼 해당 파일은 staging area에 저장되어 Tracked 상태, 즉 git이 파일을 추적하는 상태가 됩니다.

> 한 번 `git add`를 해주시면 직접 `git rm --cached <filename>` 명령어를 이용하지 않는 이상 Untracked 상태가 되지 않습니다. `git rm`에 대해서는 나중에 다시 다룹니다.

**Tracked 상태의 파일들은 다시 크게 Unmodified, Modified, Staged 3개의 상태로 나뉩니다.** staging area에 있는 파일들의 상태는 **Staged**입니다. staging area에 있는 파일들을 커밋하게 되면 해당 파일들은 하나의 커밋으로 저장된 후, 파일의 상태는 **Unmodified**로 내려오게 됩니다. Unmodified 상태의 파일들을 수정하게 되면 **Modified** 상태가 됩니다. 이후 다시 `git add` 명령어를 이용하여 Staged 상태로 올려준 후 커밋을 하는 과정을 반복하게 됩니다.

다시 출력된 메세지를 살펴봅시다:

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-01be2ff7-cce4-481e-b620-1027d52cb8f5.png){: .align-center}

**'Changes not staged for commit:'** 항목에 **'modified: mystory.txt'**가 있습니다. 이는 **Modified** 상태의 파일들을 보여줍니다. 

**'Untracked files:'** 항목에는 **'outline.txt'**가 있습니다. 이는 **Untracked** 상태의 파일들을 보여줍니다. 

**mystory.txt**는 커밋 후 수정을 했기 때문에 **Modified**의 상태에 있고 **outline.txt**는 새로 만들어준 후 아직 **add**를 안했기 때문에 **Untracked**의 상태에 남아있습니다.

**Note**

**On branch master**의 의미는 현재 **master** 브랜치에 있다는 것을 의미합니다. 브랜치에 대해서는 나중에 다룹니다.

저희는 **outline.txt**와 **mystory.txt**가 모두 git에 추적되어 관리되기를 원하므로 `git add`를 이용하여 커밋할 준비를 합시다.

    $ git add outline.txt mystory.txt    # 두 개의 파일을 한번에 add해 줍니다.

이후, `git status`를 이용하여 파일들의 상태를 확인해봅시다:

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-fca23fb6-c294-422c-b87e-a3f059b65509.png){: .align-center}

출력된 메세지가 **'Changes not staged for commit:'**에서 **'Changes to be commited:'**로 바뀌었다는 점에 유의하십시오. 

**'Changes to be commited:'** 항목에는 **'mystory.txt'**와 **'outline.txt'**가 있습니다. 이는 **Staged** 상태의 파일들을 보여줍니다. 이제 커밋할 준비가 모두 되었습니다.

**To-do List**

- [ ]  `git status` 명령어로 파일의 상태 확인해보기

## 다시 수정하기

---

갑자기 주인공의 이름이 마음에 안 듭니다. 커밋하기 전에 주인공의 이름을 '츠키'로 바꾸어 봅시다:

**mybook/mystory.txt**

    츠키라는 아이가 한국에 살았습니다. 머리가 좋지는 않았지만 매일매일 열심히 살았습니다.
    하지만 그럼에도 불구하고 잭은 좋은 대학을 가지 못했습니다.

이제 **mystory.txt**의 상태는 어떻게 되었을까요? **Staged**에서 **Modified**로 바뀌었을까요? `git status` 명령어를 사용하여 확인해봅시다:

![](({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-6b841074-8466-44ff-b5cb-fe334b0ebeb3.png){: .align-center}

**mystory.txt** 파일이 **Staged** 상태와 **Modified** 상태를 모두 갖고 있습니다. 어떻게 이런 일이 가능할까요? **Staged** **상태의 파일은 `git add` 명령을 실행한 순간의 버전만을 저장합니다.** 이후에 내용을 변경할 경우, 변경된 내용을 반영한 **Modified** 상태의 파일이 하나 더 생긴다고 생각하시면 됩니다. `git commit` 명령어는 **Staging area**에 저장된 파일 정보를 토대로 커밋하므로, 명령어를 실행하는 시점의 버전이 커밋되는 것이 아니라 마지막으로 `git add` 명령을 실행했을 때의 버전이 커밋됩니다. 저희의 경우, 다시 `git add`를 안했기 때문에 수정하기 전의 **mystory.txt** 파일만이 커밋됩니다. 아직 둘러볼 것이 남아 있으니 커밋은 하지 마세요!

> `git status`에 여러 옵션을 추가하여 실행할 수 있습니다. 사실, 모든 명령어에 추가적인 옵션을 다룰 수 있는데 이는 시간이 되면 다루도록 하겠습니다. 궁금하신 분들은 [https://git-scm.com/docs](https://git-scm.com/docs)에서 찾아보시면 좋을 것 같습니다.

## Staged와 Unstaged 상태의 변경 내용을 보기(git diff)

---

주로 `git status` 명령어로 충분하지만, **Staged** 상태와 **Modified** 상태의 같은 파일이 있을 경우 변경된 내용을 확인할 수 있습니다. `git diff` 명령어를 사용하시면 됩니다:

    $ git diff

다음과 같이 출력됩니다:

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-60239ba8-57e6-44ba-8229-2d5667c3a636.png){: .align-center}

**'--- <from-file>'** 은 변경 이전의 파일이고 **'+++ <to-file>'** 은 변경 후의 파일입니다.

**'-1, 2'** 의 의미는 변경 이전 파일 1번째 라인부터 2번째 라인 사이에서 변경이, **'+1, 2'** 의 의미는 변경된 파일 1번째 라인부터 2번째 라인까지 변경이 있었다는 뜻입니다.

빨간색의 **'-(content)'**의 의미는 변경 이전 내용, 초록색의 **'+(content)'**의 의미는 변경 이후의 내용입니다.

**Note**

출력창의 내용은 git 버전에 따라 조금씩 다를 수 있습니다. 화면이 다르거나 출력 내용을 자세히 알고 싶다면 구글이나 stackoverflow를 이용하여 검색해 보세요.

## 변경사항 저장하기(git commit)

---

이제 `git commit` 명령어를 사용하여 커밋을 해봅시다(아직 `git add`를 안 했기 때문에 변경 이전의 파일이 커밋될 것입니다). 이번에는 `-m` 옵션을 사용하지 말고 해봅시다:

    $ git commit

메세지를 작성하라는 창이 뜨면 당황하지 말고 INSERT 모드로 바꾼 후 메세지를 입력해 줍니다: 

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-f769d4d0-1058-405b-ab8a-455070bc0928.png){: .align-center}

이후 저장을 하면 완료됩니다:

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-82b0892a-c2f9-4207-8660-05ee190c6a2c.png){: .align-center}

## Staging Area 생략하기(git commit -a)

---

아직 저희는 주인공 이름이 변경된 파일을 커밋하지 않았습니다. 이번에는 `-a` 옵션을 사용하여 **staging area**를 생략하고 커밋을 해봅시다:

    $ git add mystory.txt    # Modified의 상태이기 때문에 add를 해주어야 합니다.
    $ git commit -a -m "change the name of main character"

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-095bd0f5-387a-4e6d-968f-d97abdbcaac0.png){: .align-center}

# GitHub 시작하기

지금까지 저희는 로컬 저장소에만 데이터를 백업해 두었습니다. 하지만, 여러 명의 사람들과 프로젝트를 진행하거나, 오픈 소스 프로젝트를 만들고 싶다면 서버를 만들어 공유할 수 있어야 합니다. 직접 서버를 만들 수도 있지만, 저희는 GitHub라는 Git 저장소 호스트를 이용하겠습니다.

GitHub은 가장 큰 Git 저장소 호스트입니다. 수백만 개발자가 모여서 수백만 프로젝트를 수행하는 중추입니다. Git 저장소를 GitHub에 만들어 운영하는 비율이 높습니다. 많은 오픈 소스 프로젝트는 GitHub을 이용해서 Git 호스팅, 이슈 트래킹, 코드 리뷰, 등등의 일을 합니다. Git을 많이 사용하다 보면 Git 프로젝트 자체에는 참여하지 않더라도 GitHub을 꼭 써야 하는 상황이 오거나 스스로 쓰고 싶어질 것입니다.

**Github의 중요성**

프로젝트 경험이 없으신 분들은 github의 중요성을 무시할 수 있습니다. 하지만 다시 한 번 말씀드립니다. 여러분들이 다른 사람들과 프로젝트를 진행하게 될 것이라면 버전 관리는 필수입니다.

또한 github에는 무궁무진한 오픈 소스가 있습니다. 여러분들이 github를 알아야 이런 오픈소소를 사용할 수 있고, 또 여러분들의 오픈소스를 공유할 수 있습니다.

github를 주소창에 검색하고 계정을 만듭니다. 무료 버전으로 진행하시면 됩니다.

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-7b20d6cc-9050-4337-af2c-d88b4460c649.png){: .align-center}

계정을 만드셨다면 로그인 후 좌측 sidebar에서 New 버튼을 눌러 새로운 저장소(Repository)를 만드세요. 이 저장소를 여러분의 원격 저장소(remote)로 사용할 것입니다. 저장소의 이름을 **mybook**이라 하겠습니다.

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-f0347478-ffe5-4959-a51b-cf61a1abde5f.png){: .align-center}

Create repository 버튼을 누르시면 다음 화면과 같이 나올 것입니다:

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-7f527bf9-4cd9-4fd3-afe4-4d5e2c308c12.png){: .align-center}

화면에 나오는 해당 주소를 일단 복사합니다.

**To-do List**

- [ ]  github에 저장소(repository) 만들기

## 리모트 저장소(git remote)

---

리모트 저장소는 인터넷이나 네트워크 어딘가에 있는 저장소를 말합니다. 저희의 경우 아까 만든 github 저장소를 사용할 것입니다.

그런데 github에는 저희가 만든 저장소 이외에도, 다른 사람들이 만든 많은 어마어마한 수의 저장소가 있습니다. 그렇다면 우리의 파일을 원하는 저장소에 보내기 위해서는 어떻게 해야할까요? **위에서 복사한 경로의 저장소에 파일을 보내라고 git에게 알려주어야 합니다. 이를 리모트 저장소를 추가한다고 말합니다.**

리모트 저장소를 관리할 줄 알아야 다른 사람과 함께 일할 수 있습니다. 저장소는 여러 개가 있을 수 있는데 어떤 저장소는 읽고 쓰기 모두 할 수 있고 어떤 저장소는 읽기만 가능할 수 있습니다. 다른 사람들과 함께 일한다는 것은 리모트 저장소를 관리하면서 데이터를 거기에 Push 하고 Pull 하는 것입니다.

**mybook** 디렉토리로 이동하여 `git remote` 명령어를 치면 프로젝트에 저장된 리모트 저장소 목록을 확인할 수 있습니다:

    $ git remote

저희는 아무런 리모트 저장소를 등록하지 않았으므로 아무런 출력이 없습니다:

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-6c197abc-145e-4907-bd53-39d9d768d8d7.png){: .align-center}

## 리모트 저장소 추가하기(git remote add)

---

`git remote add <remotename> <url>`명령어를 이용하여 해당 <url>의 리모트 저장소를 쉽게 등록할 수 있습니다. <remotename>은 사용할 리모트 저장소의 이름입니다. 저희는 위에서 복사한 github 주소를 <url>로 사용하고, origin을 <remotename>으로 사용할 것입니다.

**Note**

origin 대신 다름 이름을 사용해도 괜찮습니다. origin의 의미는 나중에 다루도록 하겠습니다.

    $ git remote add origin https://github.com/seonkyuKim/mybook.git    # 자신의 github url 주소를 이용해 주세요

`git remote` 명령어를 사용하여 리모트 저장소가 잘 등록 되었는지 확인해 봅시다:

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-38949bba-e66a-4637-bb18-690100500478.png){: .align-center}

**To-do List**

- [ ]  리모트 저장소 등록하기

## 리모트 저장소에 push하기(git push)

---

로컬 디렉토리에 저장된 커밋을 리모트 저장소에 옮기는 것을 **push**한다고 합니다. (반대로 리모트 저장소에 있는 내용을 가져오는 것을 **pull**한다고 합니다.) [git book](https://git-scm.com/book/ko/v2) "[1.1 시작하기 - 버전관리란?](https://git-scm.com/book/ko/v2/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EB%B2%84%EC%A0%84-%EA%B4%80%EB%A6%AC%EB%9E%80%3F)"에 나온 내용을 잠깐 다시 보고자 합니다.

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-f1197653-b761-429e-81a7-84e77c699821.png){: .align-center}

(사진: [https://git-scm.com/book/ko/v2/시작하기-버전-관리란%3F](https://git-scm.com/book/ko/v2/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EB%B2%84%EC%A0%84-%EA%B4%80%EB%A6%AC%EB%9E%80%3F))

DVCS(분산 버전 관리 시스템)은 단순히 파일의 마지막 스냅샷만을 저장하지 않습니다. 그냥 저장소를 히스토리와 더불어 전부 복제합니다. 로컬 저장소에 있는 모든 커밋을 리모트 저장소로 보내기 위해서는 `git push <remotename> <branchname>` 명령어를 사용하면 됩니다. 브랜치에 대해서는 아직 배우지 않았으므로, 현재 master 브랜치에 있다는 점만 기억하시고 다음 명령어를 실행합시다:

    $ git push origin master

다음과 같은 화면이 출력됩니다:

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-21b395b2-36f6-4c4e-8c84-f60125fc3bca.png){: .align-center}

이후 github의 mybook repository에 들어가면 데이터가 잘 복제된 것을 확인할 수 있습니다:

![]({{ site.url }}{{ site.baseurl }}/assets/images/2019-2-20-git-기초/Untitled-b812b894-7890-479b-908a-468f2350112c.png){: .align-center}

**To-do List**

- [ ]  자신의 리모트 저장소에 `push`하기

# 마치며

**첫 글인지라 상당히 많은 개념들이 포함되어 있습니다.** 특히 git 프로젝트의 3가지 공간 구분과 파일의 4가지 상태 분류에 대한 개념은 상당히 낯설 수 있습니다. 하지만, 앞에서 말한 두 가지 개념은 앞으로 git을 배우는데 기초가 되는 내용이므로 시간이 걸리더라도 꼭 이해하시고 넘어 가시길 바랍니다. 이해가 안 되는 부분은 [git book](https://git-scm.com/book/ko/v2)을 보시거나 구글에 검색하면 그와 관련된 많은 설명들이 있으니 참고하셔도 좋습니다 (꼭 보고 와주세요..!).

조금 더 나은 강의를 위해 언제나 피드백은 환영입니다. 댓글이나 이메일로 보내주시면 감사하겠습니다.

## To-do List

- [ ]  git 설치하기
- [ ]  `git init` 실행 후 **.git** 폴더 확인하기
- [ ]  `add`와 `commit` 하기
- [ ]  `git status` 명령어로 파일의 상태 확인해보기
- [ ]  github에 저장소(repository) 만들기
- [ ]  리모트 저장소 등록하기
- [ ]  자신의 리모트 저장소에 `push`하기
