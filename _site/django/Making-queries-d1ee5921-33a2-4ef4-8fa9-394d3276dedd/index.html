<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.15.1 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Django document 번역 - Making queries - GONNABE</title>
<meta name="description" content="*본 글은 작성중입니다.">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="GONNABE">
<meta property="og:title" content="Django document 번역 - Making queries">
<meta property="og:url" content="http://localhost:4000/django/Making-queries-d1ee5921-33a2-4ef4-8fa9-394d3276dedd/">


  <meta property="og:description" content="*본 글은 작성중입니다.">







  <meta property="article:published_time" content="2018-01-25T00:00:00+09:00">





  

  


<link rel="canonical" href="http://localhost:4000/django/Making-queries-d1ee5921-33a2-4ef4-8fa9-394d3276dedd/">







  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Person",
      "name": "Seonkyu Kim(김선규)",
      "url": "http://localhost:4000",
      "sameAs": null
    }
  </script>







<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="GONNABE Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE ]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">GONNABE</a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/django/index/" >Django</a>
            </li><li class="masthead__menu-item">
              <a href="/database/index" >Database</a>
            </li><li class="masthead__menu-item">
              <a href="/jekyll/index" >Jekyll</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Seonkyu Kim(김선규)</h3>
    
    
      <p class="author__bio" itemprop="description">
        개발자 블로그
      </p>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">South Korea</span>
        </li>
      

      
        
          
        
          
        
          
        
          
        
          
        
          
        
      

      

      
        <li>
          <a href="mailto:hopsprings2ternal@gmail.com">
            <meta itemprop="email" content="hopsprings2ternal@gmail.com" />
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i> Email
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Django document 번역 - Making queries">
    <meta itemprop="description" content="*본 글은 작성중입니다.">
    <meta itemprop="datePublished" content="January 25, 2018">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Django document 번역 - Making queries
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  17 minute read
</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
        <p>*본 글은 작성중입니다.</p>

<h1 id="making-queries">Making queries</h1>

<p>너가 <code class="highlighter-rouge">data models</code>를 만들고 나면, Django는 create, retrieve, update 그리고 delete object를 할 수 있는 database-abstraction API를 자동적으로 제공할 것이다. 이 문서는 이 API를 어떻게 사용하는지를 알려준다. 모든 다양한 model lookup options에 대한 자세한 내용은 <code class="highlighter-rouge">data model reference</code>를 참조하여라.</p>

<p>이 가이드를 설명하는 동안, 우리는 다음과 같이 Weblog application을 구성하는 models를 사용할 것이다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from django.db import models

class Blog(models.Model):
	name = models.CharField(max_length=100)
	tagline = models.TextField()
	
	def __str__(self):
		return self.name

class Author(models.Model):
	name = models.CharField(max_length=200)
	email = models.EmailField()

	def __str__(self):
		return self.name

class Entry(models.Model):
	blog = models.ForeignKey(Blog, on_delete=models.CASCADE)
	headline = models.CharField(max_length=255)
	body_text = models.TextField()
	pub_date = models.DateField()
	mod_date = models.DateField()
	authors = models.ManyToManyField(Author)
	n_comments = models.IntegerField()
	n_pingbacks = models.IntegerField()
	rating = models.IntegerField()

	def __str__(self):
		return self.headline
</code></pre></div></div>

<h1 id="creating-objects">Creating objects</h1>

<p>Python object의 database-table data를 나타내기 위해, Django는 직관적인 시스템을 사용한다: database class를 나타내는 model class, 그리고 그 class의 instance는 database table 안의 특정 기록들을 나타낸다.</p>

<p>object를 생성하기 위해, model class의 keyword arguments를 사용하여 그것을 instantiate 한 뒤, database에 저장하기 위해 <strong><code class="highlighter-rouge">save()</code></strong>를 호출해라.</p>

<p>models가 <strong>mysite/blog/models.py</strong> 파일 안에 있다고 가정하자. 예시는 다음과 같다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; from blog.models import Blog
&gt;&gt;&gt; b = Blog(name='Beatles Blog', tagline='All the latest Beatles news.')
&gt;&gt;&gt; b.save()
</code></pre></div></div>

<p>이는 뒤에서 <strong>INSERT</strong> SQL statement를 실행한다. Django는 너가 명시적으로 <strong><code class="highlighter-rouge">save()를</code></strong> 호출하기 전까지 database를 건드리지 않는다.</p>

<p><strong><code class="highlighter-rouge">save()</code></strong> method는 return 값이 없다.</p>

<ul>
  <li>
    <p><strong>See also</strong></p>

    <p><strong><code class="highlighter-rouge">save()</code></strong>는 여기에서 설명하지 않은 다수의 advanced option들이 있다. 모든 세부 사항을 위해서 <strong><code class="highlighter-rouge">save()</code></strong> 문서를 참조하라</p>

    <p>object를 생성하고 저장하는 것을 한 번에 하기 위해서는 <strong><code class="highlighter-rouge">create()</code></strong> method를 사용하여라.</p>
  </li>
</ul>

<hr />

<h1 id="saving-changes-to-objects">Saving changes to objects</h1>

<p>databse 에 이미 있는 object의 변경 사항을 저장하기 위해서는 <strong><code class="highlighter-rouge">save()</code></strong>를 사용해라.</p>

<p>주어진 <strong>Blog</strong> instance <strong>b5</strong>는 이미 database에 저장되어 있다. 이 예시는 그것의 이름을 바꾸고, database에 그것의 record를 update하는 것이다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; b5.name = 'New name'
&gt;&gt;&gt; b5.save()
</code></pre></div></div>

<p>이것은 뒤에서 <strong>UPDATE</strong> SQL statement를 실행한다. Django는 너가 명시적으로 <strong><code class="highlighter-rouge">save()</code></strong> 호출하기 전까지 database를 건드리지 않는다.</p>

<h2 id="saving-foreignkey-and-manytomanyfield-fields">Saving ForeignKey and ManyToManyField fields</h2>

<p><strong><code class="highlighter-rouge">ForeignKey</code></strong> field를 update하는 것은 일반적인 field를 저장하는 것과 정확히 같은 방법으로 작동한다 - 단순히 옳은 타입의 object를 할당 해주는 것이다. 이 예시는 <strong>Entry</strong> instance <strong>entry</strong>의 <strong>blog</strong> attribute를 update하는 것이다. <strong>Entry</strong>와 <strong>Blog</strong>의 적당한 instances들이 이미 database에 저장되어 있다고 가정하자(따라서 우리는 다음과 같이 그들을 retrieve 할 수 있다):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; from blog.models import Blog, Entry
&gt;&gt;&gt; entry = Entry.objects.get(pk=1)
&gt;&gt;&gt; chees_blog = Blog.objects.get(name="Cheddar Talk")
&gt;&gt;&gt; entry.blog = cheese_blog
&gt;&gt;&gt; entry.save()
</code></pre></div></div>

<p><strong><code class="highlighter-rouge">ManyToManyField</code></strong>를 updating하는 것은 약간 다르게 작동한다 - relation에 record를 추가하기 위해 field에 <strong><code class="highlighter-rouge">add()</code></strong> method를 사용해라. 이 예시는 <strong>Author</strong> instance <strong>joe</strong>를 <strong>entry</strong> object에 추가한 것이다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; from blog.models import Author
&gt;&gt;&gt; joe = Author.objects.create(name="Joe")
&gt;&gt;&gt; entry.authors.add(joe)
</code></pre></div></div>

<p><strong><code class="highlighter-rouge">ManyToManyField</code></strong>에 많은 수의 record를 한 번에 저장하기 위해, 많은 arguments를 <strong><code class="highlighter-rouge">add()</code></strong> 의 호출 안에 포함해라. 다음과 같다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; john = Author.objects.create(name="John")
&gt;&gt;&gt; paul = Author.objects.create(name="Paul")
&gt;&gt;&gt; george = Author.objects.create(name="George")
&gt;&gt;&gt; ringo = Author.objects.create(name="Ringo")
&gt;&gt;&gt; entry.authors.add(john, paul, george, ringo)
</code></pre></div></div>

<p>Django는 만약 너가 다른 종류의 object를 추가하거나 할당 할 때 error를 일으킬 것이다.</p>

<hr />

<h1 id="retrieving-objects">Retrieving objects</h1>

<p>너의 database로부터 objects를 retrieve하기 위해, 너의 model class의 <strong><code class="highlighter-rouge">Manager</code></strong>를 통해 <strong><code class="highlighter-rouge">QuerySet</code></strong>을 구성해라.</p>

<p><strong><code class="highlighter-rouge">QuerySet</code></strong>은 너의 database의 objects의 모음을 나타낸다. 이것은 없거나 한 개일 수도 있고, 많은 <em>filter</em>일 수도 있다. Filters는 주어진 parmeters에 따라서 query results를 줄여 나간다. SQL 용어로는, <strong><code class="highlighter-rouge">QeurySet</code></strong>은 <strong>SELECT</strong> 명령어에 해당하고, filter은 제한하는 구절인 <strong>WHERE</strong> 또는 <strong>LIMIT</strong>이다.</p>

<p>너는 너의 model <strong><code class="highlighter-rouge">Manager</code></strong>를 사용함으로써 <strong><code class="highlighter-rouge">QuerySet</code></strong>을 얻는다. 각각의 model은 적어도 한 개의 <strong><code class="highlighter-rouge">Manager</code></strong>를 갖고 있고, 이는 기본적으로 <strong><code class="highlighter-rouge">objects</code></strong>라고 불리운다. 다음와 같이 model class를 통해 직접적으로 접근할 수 있다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Blog.objects
&lt;django.db.models.manager.Manager object at ...&gt;
&gt;&gt;&gt; b = Blog(name='Foo', tagline='Bar')
&gt;&gt;&gt; b.objects
Traceback:
	...
AttributeError: "Manager isn't accessible via Blog instances."
</code></pre></div></div>

<ul>
  <li>
    <p><strong>Note</strong></p>

    <p><strong><code class="highlighter-rouge">Managers</code></strong>는 model class를 통해서만 접근할 수 있고 model instances를 통해서는 안된다. 이는 “table-level” operations와 “record-level” operations를 분리하기 위함이다.</p>
  </li>
</ul>

<p><strong><code class="highlighter-rouge">Manager</code></strong>은 한 model에 대한 <strong>QuerySets</strong>의 메인 소스이다. 예를 들어, <strong>Blog.objects.all()</strong>은 database에서 모든 <strong>Blog</strong> objects를 담고 있는 <strong><code class="highlighter-rouge">QuerySet</code></strong>을 반환한다.</p>

<h2 id="retrieving-all-objects">Retrieving all objects</h2>

<p>table로 부터 objects를 retrieve하는 가장 쉬운 방법은 모든 것들을 받는 것이다. 이를 하기 위해서 <strong><code class="highlighter-rouge">Manager</code></strong>에 <strong><code class="highlighter-rouge">all()</code></strong> method를 사용해라:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; all_entries = Entry.objects.all()
</code></pre></div></div>

<p><strong><code class="highlighter-rouge">all()</code></strong> mothod는 database에 있는 모든 objects의 <strong><code class="highlighter-rouge">QuerySets</code></strong>을 반환한다.</p>

<hr />

<h2 id="retrieving-specific-objects-with-filters">Retrieving specific objects with filters</h2>

<p><strong><code class="highlighter-rouge">all()</code></strong>에 의해 반환된 <strong><code class="highlighter-rouge">QuerySet</code></strong>은 database table의 모든 objects를 묘사한다. 그러나 보통, 너는 완전한 objects의 집합에서 일부만 선택해야 할 필요가 있을 것이다.</p>

<p>이러한 부분집합을 만들기 위해서, 너는 filter conditions를 추가하여 초기의 <strong><code class="highlighter-rouge">Queryset</code></strong>을 수정한다. 다음은 <strong><code class="highlighter-rouge">QuerySet</code></strong>을 refine하는 대표적인 두 가지 방법이다:</p>

<p><strong>filter(</strong>kwargs)**</p>

<p>주어진 lookup parameters와 match하는</p>

<p><strong>exclude(</strong>kwargs)**</p>

<p>주어진 lookup parameters와 match하지 않는 objects를 포함하고 있는 새로운 <strong><code class="highlighter-rouge">QuerySet</code></strong>을 반환한다.</p>

<p>lookup parameters (위 함수의 정의에서 <strong>**kwargs</strong>)는 <code class="highlighter-rouge">Field lookups</code> 아래에 기술된 포멧을 따라야 한다.</p>

<p>예를 들어, 2006년의 blog entries의 <strong><code class="highlighter-rouge">QuerySet</code></strong>을 얻고 싶다면 다음과 같이 <strong><code class="highlighter-rouge">filter()</code></strong>를 사용해라:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entry.objects.filter(pub_date__year=2006)
</code></pre></div></div>

<p>기본 manager class를 사용하면 이는 다음과 같다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entry.objects.all().filter(pub_date__year=2006)
</code></pre></div></div>

<p><strong>Chaining filters</strong></p>

<p><strong><code class="highlighter-rouge">QuerySet</code></strong>을 refine한 결과는 <strong><code class="highlighter-rouge">QuerySet</code></strong> 그 자신이기 때문에 연속적인 refinement을 함께 할 수 있다. 예시를 보자:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Entry.objects.filter(
...		headline__startswith='What'
...).exclude(
...		pub_date__gte=datetime.date.today()
...).filter(
...		pub_date__gte=datetime.date(2005, 1, 30)
...)
</code></pre></div></div>

<p>이는 모든 database의 entries를 시작 <strong><code class="highlighter-rouge">QuerySet</code></strong>으로 받고, filter를 추가하고, exclusion하고, 다른 filter를 추가했다. 최종 <strong><code class="highlighter-rouge">QuerySet</code></strong>의 결과는 “What”으로 시작하는 headline과 현재 날짜와 2005년 1월 30일 사이에 출판된 모든 entries를 갖고 있다.</p>

<hr />

<p><strong>Filtered QuerySets are unique</strong></p>

<p>너가 <strong><code class="highlighter-rouge">QuerySet</code></strong>을 refine할 때마다, 너는 이전의 <strong><code class="highlighter-rouge">QuerySet</code></strong>과 전혀 연결되지 않은 새로운 <strong><code class="highlighter-rouge">QuerySet</code></strong>을 을 얻는다. 각각의 refinement는 저장되고, 사용되고, 다시 쓸 수 있는 분리되고 별개의 <strong><code class="highlighter-rouge">QuerySet</code></strong>을 생성한다.</p>

<p>다음은 예시이다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; q1 = Entry.objects.filter(headline__startswith="What")
&gt;&gt;&gt; q2 = q1.exclude(pub_date__dte=datetime.date.today())
&gt;&gt;&gt; q3 = q1.filter(pub_date__gte=datetime.date.today())
</code></pre></div></div>

<p>이 세 가지 <strong>QuerySets</strong>는 각각 별개이다. 첫 번째 것은 “What”으로 시작하는 headline을 갖고 있는 모든 entries를 포함하는 <strong><code class="highlighter-rouge">QuerySet</code></strong>이다. 두 번째 것은 첫 번째 것의 하위 집합으로, <strong>pub_date</strong>가 오늘이거나 미래인 것들의 records를 제외하는 추가적인 기준을 갖고 있다. 세 번째 것은 첫 번째의 하위 집합으로, <strong>pub_date</strong>가 오늘이거나 미래인 것들만 고르는 추가적인 기준을 갖고 있다. 초기 <strong><code class="highlighter-rouge">QuerySet</code></strong>(<strong>q1</strong>)은 refinement 과정에 영향을 받지 않는다.</p>

<hr />

<p><strong>QuerySets are lazy</strong></p>

<p>QuerySets는 게으르다 - <strong><code class="highlighter-rouge">QuerySet</code></strong>을 생성하는 작업은 어떠한 database activity도 포함하지 않는다. 너는 매우 길게 filters를 쌓을 수 있지만, Django는 <strong><code class="highlighter-rouge">QuerySet</code></strong>가 <em>evaluated</em> 되기 전까지 실제로 query를 실행하지 않는다. 다음 예시를 보자:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; q = Entry.objects.filter(headline__startswith="What")
&gt;&gt;&gt; q = q.filter(pub_date__lte=datetime.date.today())
&gt;&gt;&gt; q = q.exclude(body_text__icontains="food")
&gt;&gt;&gt; print(q)
</code></pre></div></div>

<p>이는 세 번의 database hit처럼 보이지만, 사실 이것은 마지막 line의 (print(q))에서 database를 단 한 번만 hit한다. 일반적으로, 너가 <strong><code class="highlighter-rouge">QuerySet</code></strong>의 결과를 요구하지 않는 이상, 그것들은 database로 부터 도출되지 않을 것이다. 너가 그것을 할 때, <strong><code class="highlighter-rouge">QuerySet</code></strong>은 database에 접근하여 <em>evaluated</em>된다. 언제 evaluation이 일어나는지에 대한 자세한 디테일은 <code class="highlighter-rouge">When QuerySets are evalutated</code>를 보아라.</p>

<hr />

<h2 id="retrieving-a-single-object-with-get">Retrieving a single object with get()</h2>

<p><strong><code class="highlighter-rouge">filter()</code></strong>는 너에게 항상 <strong><code class="highlighter-rouge">QuerySet</code></strong>을 줄 것이다, 단 하나의 object가 query에 해당할 지라도 - 이 경우에, 이는 하나의 요소를 갖고 있는 <strong><code class="highlighter-rouge">QuerySet</code></strong>이 될 것이다.</p>

<p>만약 너가 query에 해당하는 하나의 object가 있다는 것을 안다면, 그 object를 직접적으로 반환하는 <strong><code class="highlighter-rouge">Manager</code></strong>의 <strong><code class="highlighter-rouge">get()</code></strong> mehtod를 사용해라:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; one_entry = Entry.objects.get(pk=1)
</code></pre></div></div>

<p>너는 마치 <strong><code class="highlighter-rouge">filter()</code></strong>처럼 어떠한 query expression과도 함께 <strong><code class="highlighter-rouge">get()</code></strong>을 사용할 수 있다 - 다시 말하지만, <code class="highlighter-rouge">Field looups</code> 아래를 참고해라.</p>

<p><strong><code class="highlighter-rouge">get()</code></strong>을 사용하는 것과 <strong>[0]</strong> 슬라이싱과 함께 <strong><code class="highlighter-rouge">filter()</code></strong>를 사용하는 것에 차이가 있다는 점을 알고 있어라. 만약 query와 맞는 결과가 없다면, <strong><code class="highlighter-rouge">get()</code></strong>은 <strong>DoesNotExist</strong> exception을 일으킬 것이다. 이 exception은 query가 수행되고 있는 model class의 attribute이다 - 따라서 위의 코드에서 만약 primary key가 1인 <strong>Entry</strong> object가 없다면, Django는 <strong>Entry.DoesNotExist</strong>를 일으킬 것이다.</p>

<p>비슷하게, Django는 <strong><code class="highlighter-rouge">get()</code></strong> query에 한 개 이상의 해당하는 것이 있을 경우 에러를 일으킬 것이다. 이 경우, 그것은 <strong><code class="highlighter-rouge">MultipleObjectsReturned</code></strong>를 일으킬 것이고, 이 역시 model class 자체의 attribute이다.</p>

<hr />

<h2 id="other-queryset-methods">Other QuerySet methods</h2>

<p>너가 <strong><code class="highlighter-rouge">all()</code></strong>, <strong><code class="highlighter-rouge">get()</code></strong>, <strong><code class="highlighter-rouge">filter()</code></strong>, 그리고 <strong><code class="highlighter-rouge">exclude()</code></strong>를 사용할 대부분의 경우는 너가 database로부터 objects를 찾아볼 필요가 있을 때이다. 그러나 이 외에도 많은 것이 있다; 다양한 <strong><code class="highlighter-rouge">QuerySet</code></strong> method의 전체 리스트를 보기 위해서는 <code class="highlighter-rouge">QuerySet API Reference</code>를 보아라.</p>

<hr />

<h2 id="limiting-querysets">Limiting QuerySets</h2>

<p>너의 <strong><code class="highlighter-rouge">QuerySet이</code></strong> 특정 개수의 결과를 갖게 제한하고 싶다면 Python의 array-slicing syntax를 이용해라. 이는 SQL의 <strong>LIMIT</strong> 과 <strong>OFFSET</strong> clauses와 같다.</p>

<p>예를 들어 다음은 첫 5개의 objects를 반환한다(<strong>LIMIT 5</strong>):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Entry.objects.all()[:5]
</code></pre></div></div>

<p>다음은 6번째 부터 10번째 objects를 반환한다(<strong>OFFSET 5 LIMIT 5</strong>):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Entry.objects.all()[5:10]
</code></pre></div></div>

<p>Negative indexing(i.e. <strong>Entry.objects.all()[-1]</strong>)은 지원되지 않는다.</p>

<p>일반적으로, slicing QuerySet은 새로운 QuerySet을 반환한다 - 이것은 query를 evaluate하지 않는다. 예외는 너가 Python slice syntax에서 “step” parameter를 사용할 경우이다. 예를 들어, 이것은 첫 10개의 매 두 번째 objects를 반환하기 위해 query를 실행한다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Entry.objects.all()[:10:2]
</code></pre></div></div>

<p>sliced queryset에 filtering을 추가하거나 순서를 매기는 것은 그것이 어떻게 작동할지에 대한 모호성 때문에 금지된다.</p>

<p>리스트가 아니라 하나의 단일 object를 얻고 싶다면(e.g. <strong>SELECT foo FROM bar LIMIT 1</strong>), slice 대신에 간단한 index를 사용해라. 예를 들어, 이는 headline을 알파벳 순서로 정렬한 후, database의 첫 번째 <strong>Entry</strong>를 반환할 것이다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Entry.objects.order_by('headline')[0] 
</code></pre></div></div>

<p>이것은 대략 다음과 같다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Entry.objects.order_by('headline')[0:1].get()
</code></pre></div></div>

<p>그러나, 만약 기준에 합당한 objects가 없다면 첫 번째 것은 <strong>IndexError</strong>를 일으키는 반면, 두 번째 것은 <strong>DoesNotExist</strong>를 일으킬 것이다. 자세한 사항은 <strong><code class="highlighter-rouge">get()</code></strong>을 보아라.</p>

<hr />

<h2 id="field-lookups">Field lookups</h2>

<p>Field lookups는 SQL <strong>WHERE</strong> clause의 항목을 지정하는 방법이다. 그들은 <strong>QuerySet</strong> method인 <strong><code class="highlighter-rouge">filter()</code></strong>, <strong><code class="highlighter-rouge">exclude()</code></strong>, 그리고 <strong><code class="highlighter-rouge">get()</code></strong>에 keyword arguments로 명시돼 있다.</p>

<p>기본 lookups keyword arguments들은 <strong>field__lookuptype=value</strong>와 같은 형식을 취한다. (두 개의 underscore이다). 예시를 보자:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Entry.objects.filter(pub_date__lte='2006-01-01')
</code></pre></div></div>

<p>대략 다음과 같은 SQL로 바뀐다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT * FROM blog_entry WHERE pub_date &lt;= '2006-01-01';
</code></pre></div></div>

<ul>
  <li>
    <p><strong>How this is possible</strong></p>

    <p>Python은 runtime에 names와 values가 evalutated되는 임의의 name-value arguments를 허용하는 함수를 정의 할 수 있다. 자세한 내용은 공식 Python 튜토리얼의 <code class="highlighter-rouge">Keyword Arguments</code>를 참조하여라.</p>
  </li>
</ul>

<p>lookup에 명시된 field는 model field의 이름이어야 한다. 한 가지 예외가 있는데, <strong><code class="highlighter-rouge">ForeignKey</code></strong>의 경우, 너는 접미사로 <strong>_id</strong>가 추가된 field name을 명시할 수 있다. 이 경우에 value parameter는 foreign model의 primary key의 raw value를 포함할 것을 기대된다. 예시를 보자:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Entry.objects.filter(blog_id=4)
</code></pre></div></div>

<p>만약 너가 유효하지 않은 keyword argument를 넘겨준다면, lookup 함수는 <strong>TypeError</strong>를 일으킬 것이다.</p>

<p>datase API는 약 24개의 lookup type들을 소개한다; 완전한 reference는 <code class="highlighter-rouge">field lookup reference</code>를 참조하여라. 무엇이 가능한지 잠깐 소개를 하기 위해 여기에는 너가 자주 사용하게 될 몇 가지를 소개하겠다:</p>

<p><strong><code class="highlighter-rouge">exact</code></strong></p>

<p>'’exact’’ match이다. 예시를 보자:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Entry.objects.get(headline__exact="Cat bites dog")
</code></pre></div></div>

<p>이는 다음과 같은 SQL lines이다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT ... WHERE headline = 'Cat bites dog';
</code></pre></div></div>

<p>만약 너가 lookup type을 제공하지 않는다면 - 즉, 너의 keyword argument가 double underscore을 포함하지 않는다면 - lookup type은 <strong>exact</strong>라고 가정된다.</p>

<p>예를 들어, 다음 두 문장은 동일하다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Blog.objects.get(id__exact=14)   # Explicit form
&gt;&gt;&gt; Blog.objects.get(id=14           # __exact is implied
</code></pre></div></div>

<p><strong>exact</strong> lookups는 일반적인 경우이므로, 이는 편의를 위한 것이다.</p>

<p><strong><code class="highlighter-rouge">iexact</code></strong></p>

<p>case-insensitive match이다. 따라서 다음 query:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Blog.objects.get(name__iexact="beatles blog")
</code></pre></div></div>

<p>는 “Beatles Blog”, “beatles blog”, 또는 심지어 “BeAtlES blOG”의 제목을 가진 Blog를 match한다.</p>

<p><strong><code class="highlighter-rouge">contains</code></strong></p>

<p>case-sensitive한 포함 테스트이다. 예시를 보자:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entry.objects.get(haadline__contains='Lennon')
</code></pre></div></div>

<p>이는 대략 다음 SQL과 같다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT ... WHERE headline LIKE '%Lennon%';
</code></pre></div></div>

<p>이는 ‘Today Lennon honored’ 의 headline을 match하지만, ‘today lennon honored’는 match하지 않는다는 점을 주의해라.</p>

<p>또한 case-insensitive 버전인 <strong><code class="highlighter-rouge">icontains</code></strong>가 있다.</p>

<p><strong><code class="highlighter-rouge">startswith</code></strong>, <strong><code class="highlighter-rouge">endswith</code></strong></p>

<p>각각 Starts-with와 ends-with search이다. 또한 case-insensitive 버전인 <strong><code class="highlighter-rouge">istartswith</code></strong>와 <strong><code class="highlighter-rouge">iendswith</code></strong>가 있다.</p>

<p>다시 말하지만, 이는 오직 표면만 다룬 것이다. 전체 reference는 <code class="highlighter-rouge">field lookup reference</code>에서 볼 수 있다.</p>

<hr />

<h2 id="lookups-that-span-relationships">Lookups that span relationships</h2>

<p>Django는 뒤에서 자동으로 SQL <strong>JOIN</strong>s를 다루면서, lookups에서 relatioships를 “follow”할 수 있는 강력하고 직관적인 방법을 제공한다. relationship을 확장하기 위해, 너가 원하는 field에 도달할 때까지, double underscore으로 분리하여, model 사이의 related fields의 이름을 사용해라.</p>

<p>다음 예시는 <strong>Blog</strong>의 <strong>name</strong>이 <strong>‘Beatles Blog’</strong>인 모든 <strong>Entry</strong> objects를 받는다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Entry.objects.filter(blog__name='Beatles Blog')
</code></pre></div></div>

<p>이런 확장은 너가 원하는 만큼 깊이 할 수 있다.</p>

<p>이는 또한 뒤 방향으로도 진행 가능하다. “reverse” relationship을 참조하고 싶다면, 단지 model의 소문자 이름을 사용해라.</p>

<p>다음 예시는 <strong>headline</strong>이 <strong>‘Lennon’</strong>을 포함하고 있는 <strong>Entry</strong>가 적어도 하나 있는 모든 <strong>Blog</strong> objects를 받는다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Blog.objects.filter(entry__headline__contains='Lennon')
</code></pre></div></div>

<p>만약 너가 multiple relationships를 가로질러 filtering하고 있고 중간 model이 filter 조건에 맞는 value를 갖고 있지 않다면, Django는 그것을 거기에 마치 유효하지만 비어있는(모든 values가 <strong>NULL</strong>) object가 있다고 다룰 것이다. 즉, error가 발생하지 않을 것이라는 의미이다. 예를 들어, 다음 filter를 보자:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Blog.objects.filter(entry__authors__name='Lennon')
</code></pre></div></div>

<p>(만약, 연관된 <strong>Author</strong> model이 있고), 만약 한 entry와 연관된 <strong>author</strong>이 없다면, error를 일으키는 대신에 그것은 연관된 <strong>name</strong> 또한 없다고 다뤄진다. 보통 이는 너가 원하는 것일 것이다. 헷갈리는 유일한 경우는 만약 너가 <strong><code class="highlighter-rouge">isnull</code></strong>을 사용할 경우이다. 즉:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Blog.objects.filter(entry__authors__name__isnull=True)
</code></pre></div></div>

<p>은 <strong>author</strong>에 비어있는 <strong>name</strong>을 갖고 있는 <strong>Blog</strong> objects 뿐만 아니라, <strong>entry</strong>에 비어있는 <strong>author</strong>을 갖고 있는 <strong>Blog</strong> objects 또한 반환할 것이다. 만약 너가 후자를 원하지 않는다면 이렇게 써야 한다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Blog.objects.filter(entry__authors__isnull=False,
entry__authors__name__isnull=True)
</code></pre></div></div>

<p><strong>Spanning multi-valued relationships</strong></p>

<p>이 파트는 글로는 어렵게 써 있지만, 실행 과정과 결과를 보면 당연하다고 여겨질 것이다. 따라서 글이 헷갈리게 써 있더라도 코드를 보면서 읽으면 어렵지 않게 이해할 수 있을 것이다.</p>

<p>너가 <strong><code class="highlighter-rouge">ManyToManyField</code></strong> 혹은 reverse <strong><code class="highlighter-rouge">ForeignKey</code></strong>에 기초하여 object를 filtering할 때, 두 가지 흥미있는 filter의 종류가 있다. <strong>Blog</strong>/<strong>Entry</strong>의 relationship을 생각해 보아라(<strong>Blog</strong>에서 <strong>Entry</strong> 관계는 one-to-many relationship이다). 우리는 headline에 <em>“Lennon”</em>이 포함되어 있고 2008년에 출판된 entry를 갖고 있는 blog를 찾고 싶을 수 있다. 한 <strong>Blog</strong>에 연관된 많은 entries가 있기 때문에, 이 두 개의 queries는 모두 사용 가능하고 몇 가지 상황에서 합당하다.</p>

<p><strong><code class="highlighter-rouge">ManyToManyField</code></strong>에서도 비슷한 종류의 상황이 발생한다. 예를 들어, <strong>Entry</strong>가 tags에 <strong><code class="highlighter-rouge">ManyToManyField</code></strong>를 갖고 있다면, 우리는 <em>“music”</em>과 <em>“band”</em> tags 에 연결된 entries를 찾고 싶을 수 있고, 아니면 <em>“music”</em> tag와 <em>“public”</em> 상태의 entries를 찾고 싶을 수 있다.</p>

<p>이와 같은 상황들을 모두 다루기 위해, Django는 <strong><code class="highlighter-rouge">filter()</code></strong> 호출을 가공하는 일관된 방법을 갖고 있다. 하나의 <strong><code class="highlighter-rouge">filter()</code></strong>안에 있는 모든 것은 동시에 적용되는데 이런 요구사항에 맞는 모든 items를 filter out하기 위함이다. 연속적인 <strong><code class="highlighter-rouge">filter()</code></strong> 호출들은 objects의 집합을 점점 제한하지만, multi-valued relations에서는 앞의 <strong><code class="highlighter-rouge">filter()</code></strong> 호출에 의한 objects일 필요 없이 primary model에 연결된 모든 object에게 적용된다.</p>

<p>살짝 헷갈리게 들릴 수 있지만, 다음 예시가 명확하게 해주길 바란다. headline에 <em>“Lennon”</em>이 포함되어 있고 2008년에 출판된 entry(두 개의 조건을 모두 만족하는 같은 entry)를 선택하기 위해 우리는 다음과 같이 쓴다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Blog.objects.filter(entry__headline__contains='Lennon', entry__pub_date__year=2008)
</code></pre></div></div>

<p>headline에 <em>“Lennon”</em>을 포함하고 있는 entry <strong>뿐만 아니라</strong> 2008년에 출판된 entry도 갖고 있는 모든 blog를 갖기 위해서는 다음과 같이 쓴다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Blog.objects.filter(entry__headline__contains='Lennon').filter(entry__pub_date__year=2008)
</code></pre></div></div>

<p>headline에 <em>“Lennon”</em>을 포함하고 있는 entries와 2008년에 나온 entries 둘 다 갖고 있는 blog가 한 개만 있고, <em>“Lennon”</em>을 포함하고 있는 2008년에 나온 entries를 갖고 있는 블로그는 없다고 가정하자. 첫 번째 query는 아무런 blogs를 반환하지 않지만, 두 번째 query는 그 한 개의 blog를 반환한다.</p>

<p>두 번째 예시에서 첫 번째 filter는 headline에 <em>“Lennon”</em>을 포함하고 있는 entries와 연결된 blogs의 queryset으로 제한한다. 두 번째 filter는 그 blogs의 집합을 2008년에 출판된 entries도 연결된 blogs들로 <em>더</em> 제한한다. 두 번째 filter에서 선택된 entires는 첫 번째 filter에서 선택된 entries와 같을 수도 있고 같지 않을 수도 있다. 우리는 각 filter statement에서 <strong>Blog</strong> items를 filtering했지, <strong>Entry</strong> items를 filtering 하지 않았다.</p>

<ul>
  <li>
    <p><strong>Note</strong></p>

    <p>multi-value relations를 확장한 queries에 대한 <strong><code class="highlighter-rouge">filter()</code></strong>의 행동은, 위에 기술된 대로, <strong><code class="highlighter-rouge">exclude()</code></strong>와 동일하게 implemented되지 않는다. 대신에, 하나의 exclude() 호출에 있는 조건이 반드시 같은 item를 참조하지는 않는다.</p>

    <p>예를 들어, 다음 query는 headline에 <em>“Lennon”</em>을 포함하고 있는 entries와 2008년에 출판된 entries를 모두 갖고 있는 blogs를 exclude할 것이다:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Blog.objects.exclude(
  	entry__headline__contains='Lennon',
  	entry__pub_date__year=2008,
  )
</code></pre></div>    </div>

    <p>그러나, filter()를 사용할 때와는 달리, 이것은 두 개의 조건을 모두 만족시키는 entries에 기초하여 blogs를 제한하지 않는다. 이를 하기 위해서, 즉 <em>“Lennon”</em>을 포함하고 2008년에 출판된 entries를 갖고 있지 않은 모든 blogs를 선택하기 위해서는 다음과 같이 두 개의 query를 만들어야 한다:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Blog.objects.exclude(
  	entry__in=Entry.objects.filter(
  		headline__contains='Lennon',
  		pub_date__year=2008,
  	),
  )
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h2 id="filters-can-reference-fields-on-the-model">Filters can reference fields on the model</h2>

<p>지금까지 주어진 모든 예시에서, 우리는 model filed 값을 상수와 비교하는 filter들만 만들었었다. 그러나, 한 field의 값과 같은 model에 있는 다른 field의 값을 비교하고 싶으면 어떡할까?</p>

<p>Django는 이와 같은 비교를 가능하게 하기 위해 <strong><code class="highlighter-rouge">F expressions</code></strong>를 제공한다. <strong>F()</strong>의 instances는 query 안에서 model field를 참조하는 역할을 한다. 이 references는 같은 model instance에 있는 다른 두 개의 fields 값들을 비교하기 위해 query filters에서 사용될 수 있다.</p>

<p>예를 들어, pingbacks보다 많은 수의 comments를 갖고 있는 blog entries의 list를 찾기 위해, 우리는 pingback 수를 reference하기 위한 <strong>F()</strong> object를 구성하고, query에서 그 <strong>F()</strong> object를 사용한다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; from django.db.models import F
&gt;&gt;&gt; Entry.objects.filter(n_comments__gt=F('n_pingbacks'))
</code></pre></div></div>

<p>Django는 <strong>F()</strong> objects와 상수들에게 모두 적용 가능한 addition, subtraction, multiplication, division, modulo, 그리고 power arithmetic의 사용을 지원한다. pingbacks보다 두 배 많은 comments를 갖고 있는 모든 blog entries를 찾기 위해, 우리는 다음과 같이 query를 수정한다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Entry.objects.filter(n_comments__gt=F('n_pingbacks')*2)
</code></pre></div></div>

<p>entry의 rating이 pingback 수와 comment 수의 합보다 적은 모든 entries를 찾기 위해, 우리는 다음과 같이 query를 만든다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Entry.objects.filter(rating__lt=F('n_commnets') + F('n_pingbacks'))
</code></pre></div></div>

<p>너는 또한 <strong>F()</strong> object에서 relationship을 확장하기 위해 double underscore 표기를 사용할 수 있다. double underscore을 갖는 <strong>F()</strong> object는 연결된 object에 접근할 수 있는 모든 연결을 제공한다. 예를 들어, author의 이름이 blog의 이름과 같은 모든 entries를 받기 위해, 우리는 다음과 같이 query를 만든다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Entry.objects.filter(authors__name=F('blog_name'))
</code></pre></div></div>

<p>date와 date/time fields에 대하여, 너는 timedelta object를 더하거나 뺄 수 있다. 다음은 출판된 후 3일 이상 수정된 모든 entries를 반환한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; from datetime import timedelta
&gt;&gt;&gt; Entry.objects.filter(mod_date__gt=F('pub_date') + timedelta(days=3))
</code></pre></div></div>

<p><strong>F()</strong> object는 <strong>.bitand()</strong>, <strong>.bitor()</strong>, .<strong>bitrightshift()</strong>, 그리고 <strong>.bitleftshift()</strong>와 같은 bitwise operations를 지원한다. 다음과 같이 사용한다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; F('somefield').bitand(16)
</code></pre></div></div>

<hr />

<h2 id="the-pk-lookup-shortcut">The pk lookup shortcut</h2>

<p>편의를 위해서, Django는 “primary key”를 나타내는 <strong>pk</strong> lookup shortcut을 제공한다.</p>

<p><strong>Blog</strong> model 예시에서, primary key는 <strong>id</strong> field이기 때문에, 다음과 같은 세 개의 statements가 있다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Blog.objects.get(id__exact=14) # Explicit form
&gt;&gt;&gt; Blog.objects.get(id=14) # __exact is implied
&gt;&gt;&gt; Blog.objects.get(pk=14) # pk implies id__exact
</code></pre></div></div>

<p><strong>pk</strong>의 사용은 <strong>__exact</strong> queries로 제한되어 있지 않다 - 어떠한 query term이라도 <strong>pk</strong>와 결합되어 model의 primary key에 대한 query를 진행할 수 있다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Get blogs entries with id 1, 4 and 7
&gt;&gt;&gt; Blog.objects.filter(pk__in=[1,4,7])

# Get all blog entries with id &gt; 14
&gt;&gt;&gt; Blog.objects.filter(pk__gt=14)
</code></pre></div></div>

<p>pk lookups는 또한 joins에 걸쳐 적용된다. 예를 들어, 다음 세 가지 statements는 동일하다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Entry.objects.filter(blog__id__exact=3) # Explicit form
&gt;&gt;&gt; Entry.objects.filter(blog__id=3)        # __exact is implied
&gt;&gt;&gt; Entry.objects.filter(blog__pk=3)        # __pk implies __id__exact
</code></pre></div></div>

<hr />

<h2 id="escaping-percent-signs-and-underscores-in-like-statements">Escaping percent signs and underscores in LIKE statements</h2>

<p><strong>LIKE</strong> SQL statements와 같은 field lookups(<strong>iexact</strong>, <strong>contains</strong>, <strong>icontains</strong>, <strong>startswith</strong>, <strong>istartswith</strong>, <strong>endswith</strong>, 그리고 <strong>iendswith</strong>)는 <strong>LIKE</strong> statements에서 특별하게 사용되는 문자들을 자동적으로 escape할 것이다 - percent sign과 underscore 문자이다. (<strong>LIKE</strong> statement에서, percent sign은 multiple character wildcard를, underscore은 single-character wildcard를 의미한다)</p>

<p>이것은 작업들을 직관적으로 만들기 위함이고, 추상화 과정에서 새는 부분이 없다. 예를 들어, percent sign을 갖고 있는 모든 요소들을 받기 위해, 어느 다른 문자들처럼 percent sign을 사용해라:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; Entry.objects.filter(headline__contains='%')
</code></pre></div></div>

<p>Django는 너를 위해 quoting을 신경 써 줄 것이다; 최종 SQL은 이와 비슷하다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT ... WHERE headline LIKE '%\%%';
</code></pre></div></div>

<p>underscores에 대해서도 똑같이 적용된다. percent sign과 underscore은 너를 위해 투명하게 다뤄질 것이다.</p>

<hr />

<h2 id="caching-and-querysets">Caching and QuerySets</h2>

<p>각각의 <strong><code class="highlighter-rouge">QuerySets</code></strong>은 database access를 최소화하기 위해 cache를 갖고 있다. 이 작업을 이해하고 있는 것은 더 효율적인 코드 작성을 도와줄 것이다.</p>

<p>새롭게 생긴 <strong><code class="highlighter-rouge">QuerySet</code></strong>의 cache는 비어 있다. <strong><code class="highlighter-rouge">QuerySet</code></strong>이 처음으로 evalutate될 때 - 그리고, 그래서, database query가 발생하고 - Django는 query 결과를 <strong><code class="highlighter-rouge">QuerySet</code></strong>의 cache에 저장하고 명시적으로 요구 될 때 그 값을 반환한다(e.g. <strong><code class="highlighter-rouge">QuerySet</code></strong>이 iterate 되는 경우, 다음 요소). <strong><code class="highlighter-rouge">QuerySet</code></strong>의 연속적인 evaluation은 cache된 결과를 재사용 할 것이다.</p>

<p>이 caching 동작을 명심해 두어라. 왜냐하면 너가 <strong><code class="highlighter-rouge">QuerySet</code></strong>s을 정확히 사용하지 않을 경우 해가 될 것이다. 예를 들어, 다음은 두 개의 <strong><code class="highlighter-rouge">QuerySet</code></strong>s를 만들 것이고, 그들을 evaluate하고 버릴 것이다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; print([e.headline for e in Entry.objects.all()])
&gt;&gt;&gt; print([e.pub_date for e in Entry.objects.all()])
</code></pre></div></div>

<p>이는 똑같은 database query가 두 번 실행될 것이므로, database 부하가 두 배 될 것을 의미한다. 또한 두 개의 list가 같은 database record를 갖고 있지 않을 가능성도 있다. 왜냐하면 <strong>Entry</strong>가 두 개의 요청 사이의 몇 초 사이에 추가되거나 삭제될 수 있기 때문이다.</p>

<p>이 문제를 피하기 위해, <strong><code class="highlighter-rouge">QuerySet</code></strong>을 저장하고 그것을 재사용하라.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; queryset = Entry.objects.all()
&gt;&gt;&gt; print([p.headline for p in queryset]) # Evaluate the query set.
&gt;&gt;&gt; print([p.pub_date for p in queryset]) # Re-use the cache from the evaluation.
</code></pre></div></div>

<h2 id="when-querysets-are-not-cached">When QuerySets are not cached</h2>

<p>QuerySets가 항상 그들의 결과를 cache하는 것은 아니다. queryset의 단지 일부분을 evalutate할 때, cache가 있는지 없는지는 검사되지만, 만약 없을 경우 subsequent query에 의해 반환된 item들은 cache 되지 않는다. 특히, 이것은 array slice나 index를 사용하여 <code class="highlighter-rouge">limiting the queryset</code>을 한 것은 cache를 발생하지 않는다는 뜻이다.</p>

<p>예를 들어, 특정 index를 qeuryset object에서 반복적으로 얻는 것은 database를 각각 query하게 될 것이다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; queryset = Entry.objects.all()
&gt;&gt;&gt; print(queryset[5]) # Queries the database
&gt;&gt;&gt; print(queryset[5]) # Queries the database again
</code></pre></div></div>

<p>그러나 만약 전체 queryset이 이미 evaluated 되었었다면, cache를 대신 사용할 것이다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; [entry for entry in queryset]
&gt;&gt;&gt; bool(queryset)
&gt;&gt;&gt; entry in queryset
&gt;&gt;&gt; list(queryset)
</code></pre></div></div>

<ul>
  <li>
    <p>Note</p>

    <p>단지 queryset을 출력하는 것은 cache를 발생시키지 않는다. 이것은 왜냐하면 <strong>__repr__()</strong> 의 호출은 전체 queryset의 slice만 반환할 것이기 때문이다.</p>
  </li>
</ul>

<hr />

<hr />

<h1 id="related-objects">Related objects</h1>

<p>만약 너가 model에 relationship을 정의하고 싶다면(i.e. <strong><code class="highlighter-rouge">ForeignKey</code></strong>, <strong><code class="highlighter-rouge">OneToOneField</code></strong>, 또는 <strong><code class="highlighter-rouge">ManyToManyField</code></strong>), model의 instances는 related object에 접근할 수 있는 편리한 API를 갖고 있다.</p>

<p>이 페이지의 맨 위에 있는 model들을 예시로 삼는다면, <strong>Entry</strong> object인 <strong>e</strong>는 그것과 연관된 <strong>Blog</strong> obejct를 blog attribute를 통해서 얻을 수 있다: <strong>e.blog.</strong></p>

<p>(배후에서 이 기능은 Python <code class="highlighter-rouge">descriptors</code>에 의해 구현된다. 이 내용은 사용자에게 중요하지는 않지만 호기심을 유발하기 위해 여기에서 설명한다.)</p>

<p>Django는 또한 API accessors를 relationship의 다른 쪽에 생성한다 - related model에서 그 relationship을 정의한 모델로의 link이다. 예를 들어 <strong>Blog</strong> object <strong>b</strong>는 모든 related <strong>Entry</strong> objects의 리스트를 <strong>entry_set</strong> attribute를 이용하여 접근할 수 있다:<strong>b.entry_set.all()</strong>.</p>

<h2 id="one-to-many-relationships">One-to-many relationships</h2>

<p><strong>Forward</strong></p>

<p>만약 model이 <strong><code class="highlighter-rouge">ForeignKey</code></strong>를 갖고 있다면, 그 model의 instances는 간단히 그 model의 attribute를 통하여 related (foreign) object에 접근할 수 있다.</p>

<p>예시를 보자:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; e = Entry.objects.get(id=2)
&gt;&gt;&gt; e.blog # Returns the related Blog object.
</code></pre></div></div>

<p>너는 foreign-key attribute를 통해 가져오고 설정할 수 있다. 너가 예상한 대로, foreign key의 변화는 <strong><code class="highlighter-rouge">save()</code></strong>를 호출하기 전까지 너의 database에 저장되지 않는다. 예시를 보자:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; e = Entry.objects.get(id=2)
&gt;&gt;&gt; e.blog = some_blog
&gt;&gt;&gt; e.save()
</code></pre></div></div>

<p>만약 <strong><code class="highlighter-rouge">ForeignKey</code></strong> field가 <strong>null=True</strong> 설정을 갖고 있다면(i.e. 그것이 <strong>NULL</strong> 값을 허락한다면), 너는 <strong>None</strong>을 설정하여 relation을 제거할 수 있다. 예시이다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; e = Entry.objects.get(id=2)
&gt;&gt;&gt; e.blog = None
&gt;&gt;&gt; e.save() # "UPDATE blog_entry SET blog_id = NULL...;"
</code></pre></div></div>

<p>one-to-many relationships에서 forward access는 related object에 처음 접근할 때 cached된다. 같은 object instance에 있는 foreign key로의 후속 접근들은 cached된다. 예시이다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; e = Entry.objects.get(id=2)
&gt;&gt;&gt; print(e.blog) # Hits the database to retrieve the associated Blog.
&gt;&gt;&gt; print(e.blog) # Doesn't hit the database; use cached version.
</code></pre></div></div>

<p><code class="highlighter-rouge">**select_related() QuerySet**</code> method 모든 one-to-many relationships의 cache를 미리 recursive하게 미리 채운다. 예시이다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; e = Entry.objects.selected_related().get(id=2)
&gt;&gt;&gt; print(e.blog) # Doesn't hit the database; uses cached version.
&gt;&gt;&gt; print(e.blog) # Doesn't hit the database; uses cached version.
</code></pre></div></div>

<hr />

<p><strong>Following relationships “backward”</strong></p>

<p>만약 model이 <strong><code class="highlighter-rouge">ForeignKey</code></strong>를 갖고 있다면, foreign-key model의 instances는 첫 번째 model(ForeignKey를 갖고 있는 앞의 model)의 모든 instances를 반환하는 <strong><code class="highlighter-rouge">Manager</code></strong>에 접근할 수 있다. 기본적으로, 이 <strong><code class="highlighter-rouge">Manager</code></strong>의 이름은 <strong>F00_set</strong>인데, <strong>F00</strong>는 source model의 소문자 이름이다. 이 <strong><code class="highlighter-rouge">Manager</code></strong>는 <strong>QuerySets</strong>를 반환하는데, 이것은 위의 “Retrieving objects” 부문에 기술되어 있는 대로 filtered 되고 manipulated 될 수 있다.</p>

<p>다음은 예시이다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; b = Blog.objects.get(id=1)
&gt;&gt;&gt; b.entry_set.all() # Returns all Entry objects related to Blog.

# b.entry_set is a Manager that returns QuerySets.
&gt;&gt;&gt; b.entry_set.filter(headline__conatains='Lennon')
&gt;&gt;&gt; b.entry_set.count()
</code></pre></div></div>

<p><strong>F00_set</strong> 이름을 <strong><code class="highlighter-rouge">ForeignKey</code></strong> 정의에 있는 <strong><code class="highlighter-rouge">related_name</code></strong> parameter를 설정함으로써 override할 수 있다. 예를 들어, 만약 <strong>Entry</strong> model이 <strong>blog = ForeignKey(Blog, on_delete=models.CASCADE, related_name=’entries’)</strong>로 바뀌었을 경우, 위의 코드는 다음과 같이 바뀐다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; b = Blog.objects.get(id=1)
&gt;&gt;&gt; b.entries.all() # Returns all Entry objects related to Blog.

# b.entries is a Manager that returns QuerySets.
&gt;&gt;&gt; b.entries.filter(headline__contains='Lennon')
&gt;&gt;&gt; b.entries.count()
</code></pre></div></div>

<hr />

<p><strong>Using a custom reverse manager</strong></p>

<p>기본적으로 reverse relations로 사용되는 <strong><code class="highlighter-rouge">RelatedManager</code></strong>는 해당 model의 <code class="highlighter-rouge">default manager</code>의 하위 class이다. 만약 너가 주어진 query에 대하여 다른 manager를 사용하고 싶다면 너는 다음과 같은 syntax를 사용하면 된다:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from django.db import models

class Entry(models.Model):
	# ...
	objects = models.Manager() # Default Manager
	entries = EntryManager()   # Custom Manager

b = Blog.objects.get(id=1)
b.entry_set(manager='entries').all()
</code></pre></div></div>

<p>만약 <strong>EntryManager</strong>의 해당 <strong>get_queryset()</strong> method에서 기본 filtering을 수행하면 해당 filtering이 <strong>all()</strong> 호출에 적용된다.</p>

<p>물론, custom reverse manager를 명시하는 것은 너가 그것의 custom method의 사용도 가능하게 한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>b.entry_set(manager='entries').is_published()
</code></pre></div></div>

<hr />

        
      </section>

      <footer class="page__meta">
        
        


  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#django" class="page__taxonomy-item" rel="tag">django</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2018-01-25T00:00:00+09:00">January 25, 2018</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?text=Django+document+%EB%B2%88%EC%97%AD+-+Making+queries%20http%3A%2F%2Flocalhost%3A4000%2Fdjango%2FMaking-queries-d1ee5921-33a2-4ef4-8fa9-394d3276dedd%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Fdjango%2FMaking-queries-d1ee5921-33a2-4ef4-8fa9-394d3276dedd%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://plus.google.com/share?url=http%3A%2F%2Flocalhost%3A4000%2Fdjango%2FMaking-queries-d1ee5921-33a2-4ef4-8fa9-394d3276dedd%2F" class="btn btn--google-plus" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Google Plus"><i class="fab fa-fw fa-google-plus" aria-hidden="true"></i><span> Google+</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Fdjango%2FMaking-queries-d1ee5921-33a2-4ef4-8fa9-394d3276dedd%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/django/Introduction-to-models/" class="pagination--pager" title="Django document 번역 - Introduction to models
">Previous</a>
    
    
      <a href="/database/introduction-to-database/" class="pagination--pager" title="Introduction to database
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/jekyll/Starting-Jekyll/" rel="permalink">Starting Jeykll
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  less than 1 minute read
</p>
    
    <p class="archive__item-excerpt" itemprop="description">안녕하세요 GONNABE의 김선규입니다. 몇 년 전부터 블로그를 개설하고 싶다는 생각이 있었는데요, 생각만 했던 것들을 이제 실천해 볼 생각입니다. 문제는, 저 역시 Jekyll을 공부하는 중이기 때문에 많은 시행착오가 예상됩니다… 본 Jekyll page에서는 제가 공부한 Jek...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/database/introduction-to-database/" rel="permalink">Introduction to database
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  3 minute read
</p>
    
    <p class="archive__item-excerpt" itemprop="description">Database

</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/django/Introduction-to-models/" rel="permalink">Django document 번역 - Introduction to models
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  28 minute read
</p>
    
    <p class="archive__item-excerpt" itemprop="description">이 글을 읽으며 이해가 안 되고 꽉 막힌듯한 느낌이 드신다면 이는 아마 다른 개념들이 부족하기 때문이실 겁니다. 혹시 database에 대한 개념이 부족한 것은 아닌지, 아니면 객체와 상속에 대한 개념이 부족한 것은 아닌지 확인해보시면 좋을 것 같습니다.

</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2019 Seonkyu Kim(김선규). Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script defer src="https://use.fontawesome.com/releases/v5.6.0/js/all.js" integrity="sha384-z9ZOvGHHo21RqN5De4rfJMoAxYpaVoiYhuJXPyVmSs8yn20IE3PmBM534CffwSJI" crossorigin="anonymous"></script>







    

  



  </body>
</html>
