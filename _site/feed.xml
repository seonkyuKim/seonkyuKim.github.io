<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-02-12T15:39:14+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">GONNABE</title><subtitle>Developer</subtitle><author><name>Seonkyu Kim(김선규)</name><email>hopsprings2ternal@gmail.com</email></author><entry><title type="html">Django 2.1 reference 번역: Field options</title><link href="http://localhost:4000/reference/Field-options/" rel="alternate" type="text/html" title="Django 2.1 reference 번역: Field options" /><published>2019-02-12T00:00:00+09:00</published><updated>2019-02-12T00:00:00+09:00</updated><id>http://localhost:4000/reference/Field-options</id><content type="html" xml:base="http://localhost:4000/reference/Field-options/">&lt;blockquote&gt;
  &lt;p&gt;들어가며: 본 글은 장고 공식 문서 중 Field types의 Field options에 관한 번역입니다. 피드백은 언제나 감사합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;원본 링크: &lt;a href=&quot;https://docs.djangoproject.com/en/2.1/ref/models/fields/&quot;&gt;https://docs.djangoproject.com/en/2.1/ref/models/fields/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 문서는 장고가 제공하는 모든 &lt;code class=&quot;highlighter-rouge&quot;&gt;field options&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;field types&lt;/code&gt;을 포함한 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Field&lt;/code&gt;&lt;/strong&gt;에 대해 설명하고 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;See also&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;만약 내장된 field가 작동하지 않으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;django-localflavor&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;documentation&lt;/code&gt;)를 시도해 보십시오. 이는 특별한 국가와 문화에 대해서 갖가지 유용한 code의 조각을 가지고 있습니다.&lt;/p&gt;

    &lt;p&gt;또한 당신은 쉽게 당신만의 &lt;code class=&quot;highlighter-rouge&quot;&gt;custom model fields&lt;/code&gt;를 만들 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;기술적으로, 이런 모델들은 &lt;strong&gt;django.db.models.fields&lt;/strong&gt;에 저장되어 있으나 편리함을 위해 그들은 &lt;strong&gt;django.db.models&lt;/strong&gt;안에 imported 되어있습니다. 기본적인 명명 관습은 &lt;strong&gt;from django.go import models&lt;/strong&gt;를 사용하는 것이며, fields는 **models.&lt;Foo&gt;Field**로 나타나는 것입니다.&lt;/Foo&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;field-options&quot;&gt;Field options&lt;/h1&gt;

&lt;p&gt;아래의 arguments는 모두 field의 타입들입니다. 모든 것은 선택적입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Field options는 Field type안에 포함되는 설정입니다. 예시: name = CharField(max_length=150, null=False). null은 field option이고, max_length는 필수 arguement입니다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;null&quot;&gt;null&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.null&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 &lt;strong&gt;True&lt;/strong&gt;라면, 장고는 데이터 베이스에 비어 있는 값으로 &lt;strong&gt;NULL&lt;/strong&gt;을 저장할 것입니다. 기본적으로 &lt;strong&gt;False&lt;/strong&gt;로 설정 되어있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CharField&lt;/strong&gt; 와 &lt;strong&gt;TextField&lt;/strong&gt;와 같은 문자열 기반 field의 경우는 &lt;strong&gt;null&lt;/strong&gt;의 사용을 피하는 것이 좋습니다. 문자열을 저장하는 field에 &lt;strong&gt;null=True&lt;/strong&gt; 라면, 데이터가 없을 경우 field에는 &lt;strong&gt;NULL&lt;/strong&gt;과 빈 문자열 두 값이 모두 저장될 수 있습니다. 같은 값에 대해 두 가지 가능한 값을 갖는 것은 지양해야 합니다. 장고의 관습은 빈 문자열을 저장하는 것입니다.&lt;/p&gt;

&lt;p&gt;한 가지 예외는 &lt;strong&gt;CharField&lt;/strong&gt;가 &lt;strong&gt;unique=True&lt;/strong&gt;와 &lt;strong&gt;blank=True&lt;/strong&gt;를 전부 가지고 있는 때입니다. 이는 복수의 객체에서 blank value를 저장할 때 &lt;strong&gt;unique&lt;/strong&gt; 조건에 위배되는 것을 피하기 위함입니다. (NULL은 여러 개 가질 수 있고, 빈 문자열은 하나의 값으로 인식되어 unique 때문에 하나만 가질 수 있는 것 같습니다.)&lt;/p&gt;

&lt;p&gt;string-based 와 non-string-based field 에서 forms에 빈값을 넣는 것을 원한다면 &lt;strong&gt;blank=True&lt;/strong&gt;로 설정해 주어야 합니다. &lt;strong&gt;null&lt;/strong&gt; 값은 단지 database storage에 영향을 미치기 때문입니다(&lt;strong&gt;blank&lt;/strong&gt;를 보십시오).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Oracle database backend를 사용할 때, &lt;strong&gt;NULL&lt;/strong&gt;은 이 attribute와 상관없이 빈 값을 나타내는 것으로 저장될 것입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;blank&quot;&gt;blank&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.blank&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 &lt;strong&gt;True&lt;/strong&gt; 라면 field는 blank를 허용합니다. 기본적으로 &lt;strong&gt;Flase&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;은 순수하게 database-related 인 반면에 &lt;code class=&quot;highlighter-rouge&quot;&gt;blank&lt;/code&gt;는 validation-related 입니다. 만약 field가 &lt;strong&gt;blank=True&lt;/strong&gt;를 가진다면 form validation은 empty value의 입력을 허용 해줄 것입니다. 만약 field가 &lt;strong&gt;blank=False&lt;/strong&gt; 라면 field는 반드시 채워져야 합니다&lt;/p&gt;

&lt;h2 id=&quot;choices&quot;&gt;Choices&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.choices&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;field에 choices로 사용하기 위해서는 두 items의 iterables 이거나 이를 포함하고 있는 iterable이어야 합니다(e.g. [(A, B), (A, B), …]). 만약 choice가 주어진다면, 그들은 &lt;a href=&quot;https://docs.djangoproject.com/en/2.1/ref/models/instances/#validating-objects&quot;&gt;model validation&lt;/a&gt;에 의해 실행되고, text field가 아닌, select box에 선택지가 담긴 기본 위젯 form이 실행 될 것입니다.&lt;/p&gt;

&lt;p&gt;각 튜플에서 첫번째 요소는 model에 저장되는 실질적 값이고, 두 번째 요소(element)는 사람이 읽게 되는 이름입니다. 예시:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;YEAR_IN_SCHOOL_CHOICES = (
    ('FR', 'Freshman'),
    ('SO', 'Sophomore'),
    ('JR', 'Junior'),
    ('SR', 'Senior'),
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일반적으로 model class 안에 choices를 각 값에 대해서 변함 없게 알맞은 이름을 정의하는 가장 좋은 방법은 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Student(models.Model):
    FRESHMAN = 'FR'
    SOPHOMORE = 'SO'
    JUNIOR = 'JR'
    SENIOR = 'SR'
    YEAR_IN_SCHOOL_CHOICES = (
        (FRESHMAN, 'Freshman'),
        (SOPHOMORE, 'Sophomore'),
        (JUNIOR, 'Junior'),
        (SENIOR, 'Senior'),
    )
    year_in_school = models.CharField(
        max_length=2,
        choices=YEAR_IN_SCHOOL_CHOICES,
        default=FRESHMAN,
    )

    def is_upperclass(self):
        return self.year_in_school in (self.JUNIOR, self.SENIOR)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;choices list를 model class의 외부에 정의하여 참조하게 할 수 있지만, model class 내부에 각 choice를 정의하는 것은 이것을 사용한 class에 모든 정보를 보관할 수 있다는 장점이 있습니다. 그리고 choices를 쉽게 참조 할 수 있게 합니다.(e.g. &lt;strong&gt;Student&lt;/strong&gt; 모델이 import 된 어느 곳에서라도 &lt;strong&gt;Student.SOPHOMORE&lt;/strong&gt;이 작동할 것입니다)&lt;/p&gt;

&lt;p&gt;사용 가능한 choices를 체계화 하기 위한 목적으로 그룹에 이름을 지을 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MEDIA_CHOICES = (
    ('Audio', (
            ('vinyl', 'Vinyl'),
            ('cd', 'CD'),
        )
    ),
    ('Video', (
            ('vhs', 'VHS Tape'),
            ('dvd', 'DVD'),
        )
    ),
    ('unknown', 'Unknown'),
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;각 tuple의 첫 번째 요소는 그룹을 나타낼 이름입니다. 두 번째 요소는 두 값의 iterable로, 저장되는 값과 사람이 읽을 수 있는 값으로 묶여진 tuple입니다. 하나의 list를 사용하여 그룹화 된 선택지들과 그룹화 되지 않은 선택지들을 합칠 수 있습니다.(예를 들면, 위에서의 unknown option들은 그룹화 되지 않은 선택지입니다)&lt;/p&gt;

&lt;p&gt;choices 을 가진 model field 별로, field의 현재 값에 대응되는 사람에게 보여지는 이름을 받아오는 method를 추가합니다. 더 자세한 것은 database API documentation 안에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;get_FOO_display()&lt;/code&gt;를 참고하십시오.&lt;/p&gt;

&lt;p&gt;choices는 그 어떤 iterable object로도 받을 수 있다는 것을 기억하십시오. 굳이 list나 tuple 로 구성할 필요가 없습니다. 이것은 choices를 dynamically하게 만들 수 있다는 의미입니다. 어쩌면 choices를 dynamic 하게 만들 방법을 찾아낼 수도 있지만, 아마 적절한 데이터베이스 테이블을 foreignkey와 함께 사용하는 것이 더 좋을 것입니다. choices는 어차피 크게 바꾸지 않을 정적 데이터이기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;default&lt;/strong&gt;로 &lt;strong&gt;blank=False&lt;/strong&gt;가 field에 설정되지 않는 이상 select box label에는 “——————————”가 담겨 제공될 것이다. 이를 override 하기 위해서는 &lt;strong&gt;None&lt;/strong&gt;을 가진 choices tuple을 추가하십시오; e.g. &lt;strong&gt;(None, ‘Your String For Dispay’).&lt;/strong&gt; 대안으로 예를 들어 CharField와 같이 적절한 곳에서는 empty string 대신 &lt;strong&gt;None&lt;/strong&gt;을 자주 쓸 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;db_colum&quot;&gt;db_colum&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.db_column&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;field에 사용할 database column의 이름입니다. 만약 주어지지 않았다면, 장고는 field의 이름을 사용할 것이다.&lt;/p&gt;

&lt;p&gt;만약 database column name 이 SQL reserved word, 또는 파이썬 변수이름에서는 사용할 수 없는 문자열을 포함하고 있어도 - 예를 들어 하이픈 - 장고에서는 사용할 수 있습니다. Django quotes column and table names behind the scenes.&lt;/p&gt;

&lt;h2 id=&quot;db_index&quot;&gt;db_index&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.db_index&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 True 이면 이 field를 위해 database index가 생성될 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;db_tablespaces&quot;&gt;db_tablespaces&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.db_tablespace&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 field가 indexed 되어 있다면, 필드의 index에 대해 사용할 database tablespace의 이름입니다. 기본 값은 프로젝트의 &lt;strong&gt;DEFAULT_INDEX_TABLESPACE&lt;/strong&gt; 설정, 또는 모델의 &lt;strong&gt;db_tablespace&lt;/strong&gt;(설정된 경우)입니다. 만약 backend가 tablespace를 지원하지 않는다면 이 옵션은 무시될 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;default&quot;&gt;default&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.default&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;필드에 대한 기본 값입니다. 이는 한 값이나 callable 객체가 될 수도 있습니다. 만약 callable 객체라면 새로운 객체가 생성될 때마다 호출될 것입니다.&lt;/p&gt;

&lt;p&gt;default는 변경 가능한 객체(model instance, list, set 등)일 수 없으며, 이 객체의 동일한 인스턴스에 대한 참조는 모든 새로운 모델 인스턴스에서 기본 값으로 사용될 것입니다. 대신에, callable로 원하는 default를 wrap할 수 있습니다. 예를 들어, &lt;strong&gt;JSONField&lt;/strong&gt;에 대해 default &lt;strong&gt;dict&lt;/strong&gt;을 명시하고 싶다면, 다음 함수를 사용하십시오:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def contact_default():
	return {&quot;email&quot;: &quot;to1@example.com&quot;}

contact_info = FSONField(&quot;ContactInfo&quot;, default=contact_default)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;default&lt;/strong&gt;와 같은 field option으로 &lt;strong&gt;lamda&lt;/strong&gt;는 사용할 수 없습니다. 왜냐하면 이들은 Migrations로 serialized되지 않기 때문입니다. 해당 설명서를 참고하십시오.&lt;/p&gt;

&lt;p&gt;모델 인스턴스로 매핑하는 &lt;strong&gt;ForeignKey&lt;/strong&gt;와 같은 필드에 대해서는, default는 모델 인스턴스 대신 그들이 참조하는 필드 값(&lt;strong&gt;to_field&lt;/strong&gt;가 설정되지 않은 경우 &lt;strong&gt;pk&lt;/strong&gt;)이어야 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;default 값을 모델을 설정하지 말고, 해당 모델의 field로 설정해야 한다는 뜻 같습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;default(기본 값)은 새로운 모델 인스턴스가 생기고, 해당 필드에 대해 값이 주어지지 않을 경우 사용됩니다. 필드가 primary key일 경우, 필드가 None으로 설정되어 있어도 default를 사용합니다.&lt;/p&gt;

&lt;h2 id=&quot;editable&quot;&gt;editable&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.editable&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 &lt;strong&gt;False&lt;/strong&gt;라면, 이 field는 admin이나 &lt;strong&gt;ModelForm&lt;/strong&gt;에서 표시되지 않을 것입니다. 또한 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;validation&lt;/span&gt;&lt;/code&gt;을 생략할 것입니다. 기본적으로 &lt;strong&gt;True&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h2 id=&quot;error_messages&quot;&gt;error_messages&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Fields.error_messages&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;error_messages&lt;/strong&gt; arguments는 이 field에서 에러가 발생할 때의 기본 메세지를 override합니다. override하고 싶은 에러에 대한 메세지를 dictionary로 넘겨주십시오.&lt;/p&gt;

&lt;p&gt;에러 메세지의 key는 &lt;strong&gt;null, blank, invalid, invalid_choice, unique,&lt;/strong&gt; 그리고 &lt;strong&gt;unique_for_date&lt;/strong&gt;를 포함합니다. 추가적인 error message의 key들은 Field types 섹션에 각각의 필드에 명시돼 있습니다.&lt;/p&gt;

&lt;p&gt;에러 메세지들은 종종 form으로 전달되지 않습니다. 모델의 error_messages에 대해 고려해야 할 사항에 대한 문서를 참조하십시오.&lt;/p&gt;

&lt;h2 id=&quot;help_text&quot;&gt;help_text&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.help_text&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;폼 위젯(form widget)에 표시될 추가적인 도움말입니다. 만약 폼에서 해당 필드를 사용하지 않는다 하더라도 설명하기에 유용합니다.&lt;/p&gt;

&lt;p&gt;이 값은 자동으로 생성된 폼에서 HTML을 &lt;strong&gt;help_text&lt;/strong&gt;에 원하는 대로 포함할 수 있게 해줍니다. 다음은 예시입니다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;help_text=&quot;Please use the following format: &amp;lt;em&amp;gt;YYYY-MM-DD&amp;lt;/em&amp;gt;.&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일반 텍스트와 &lt;strong&gt;django.utils.html.escape()&lt;/strong&gt;를 사용하여 HTML 특수 문자를 사용하지 않을 수 있습니다. cross-site scripting attack를 피하기 위해서 신뢰할 수 없는 사용자로부터 온 help text를 확실히 escape 해야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;primary_key&quot;&gt;primary_key&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.primary_key&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;True&lt;/strong&gt;라면, 이 필드는 해당 모델에 primary key입니다.&lt;/p&gt;

&lt;p&gt;어떤 모델에도 &lt;strong&gt;primary_key=Ture&lt;/strong&gt;를 설정하지 않았다면, 장고는 자동으로 primary key 역할을 할 &lt;strong&gt;AutoField&lt;/strong&gt;를 추가할 것입니다. 따라서 기본 primary-key behavior을 override하지 않는 이상, &lt;strong&gt;primary_key=Ture&lt;/strong&gt;을 명시할 필요가 없습니다. 자세한 사항은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Automatic primary key fields&lt;/code&gt;를 보십시오.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;primary_key=True&lt;/strong&gt;는 &lt;strong&gt;null=False&lt;/strong&gt;와 &lt;strong&gt;unique=True&lt;/strong&gt;를 암시합니다. 한 객체에 대해서는 하나의 Primary key만 허용됩니다.&lt;/p&gt;

&lt;p&gt;primary key 필드는 읽을 수만 있습니다. 만약 존재하는 객체의 primary key 값을 변경하고 저장한다면, 새로운 객체가 옛날 것 옆에 만들어질 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;unique&quot;&gt;unique&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.unique&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;True&lt;/strong&gt;라면, 이 필드는 테이블 전체에 걸쳐 고유해야 합니다.&lt;/p&gt;

&lt;p&gt;이는 데이터베이스 레벨에서, model validation에 의해 시행됩니다. 만약 unique 필드에 중복된 값의 객체를 저장하려 한다면, &lt;strong&gt;django.db.IntegrityError&lt;/strong&gt;가 모델의 &lt;strong&gt;save()&lt;/strong&gt; method에 의해 발생할 것입니다.&lt;/p&gt;

&lt;p&gt;이 옵션은 &lt;strong&gt;ManyToManyField&lt;/strong&gt;와 &lt;strong&gt;OneToOneField&lt;/strong&gt;를 제외하고 모든 필드에서 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;unique&lt;/strong&gt;가 &lt;strong&gt;True&lt;/strong&gt;일 때, &lt;strong&gt;db_index&lt;/strong&gt;를 명시할 필요가 없습니다. 왜냐하면 &lt;strong&gt;unique&lt;/strong&gt;는 index의 생성을 의미합니다.&lt;/p&gt;

&lt;h2 id=&quot;unique_for_date&quot;&gt;unique_for_date&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.unique_for_date&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 필드가 date field 값에 대해 unique하게 하기 위해서 &lt;strong&gt;DateField&lt;/strong&gt; or &lt;strong&gt;DateTimeField&lt;/strong&gt;의 이름으로 이 값을 설정하십시오.&lt;/p&gt;

&lt;p&gt;예를 들어, &lt;strong&gt;unique_for_date=”pub_date”&lt;/strong&gt;를 갖고 있는 &lt;strong&gt;title&lt;/strong&gt; field를 갖고 있다고 가정하면, 장고는 &lt;strong&gt;title&lt;/strong&gt;과 &lt;strong&gt;pub_date&lt;/strong&gt;를 동시에 갖고 있는 레코드의 입력을 허락하지 않을 것입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;pub_date = models.DateField( … )&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;title = models.CharField( … , unique_for_date=”pub_date”)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 설정을 &lt;strong&gt;DateTimeField&lt;/strong&gt;를 가리키도록 설정하면, 오직 필드의 날짜 부분만 고려된다는 점을 주의하십시오. 게다가 &lt;strong&gt;USE_TZ&lt;/strong&gt;가 &lt;strong&gt;True&lt;/strong&gt;라면, 객체가 저장될 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;현재 시간대&lt;/code&gt;에서 점검(check)이 수행될 것입니다.&lt;/p&gt;

&lt;p&gt;이는 &lt;strong&gt;Model.validate_unique()&lt;/strong&gt;에 의해 수행되는데, model validation 동안 시행되지만 데이터베이스 레벨에서는 시행되지 않습니다. 만약 &lt;strong&gt;unique_for_date&lt;/strong&gt; 제약 조건이 &lt;strong&gt;ModelForm&lt;/strong&gt;의 일부가 아닌 필드(예: 필드 중 하나가 제외되거나 &lt;strong&gt;editable=False&lt;/strong&gt;)라면, &lt;strong&gt;Model.validate_unique()&lt;/strong&gt;는 해당 제약 조건에 대한 유효성(validation) 검사를 생략합니다.&lt;/p&gt;

&lt;h2 id=&quot;unique_for_month&quot;&gt;unique_for_month&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.unique_for_month&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;unique_for_date&lt;/strong&gt;와 비슷하지만, 달(month)에 대해서 고유한 필드를 요구합니다.&lt;/p&gt;

&lt;h2 id=&quot;unique_for_year&quot;&gt;unique_for_year&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.unique_for_year&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;unique_for_date&lt;/strong&gt;와 &lt;strong&gt;unique_for_month&lt;/strong&gt;와 비슷합니다.&lt;/p&gt;

&lt;h2 id=&quot;verbose_name&quot;&gt;verbose_name&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.verbose_name&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;해당 필드에 대해 사람이 읽기 쉬운 이름입니다. 만약 verbose name이 주어지지 않는다면, 장고는 자동적으로 field의 attribute 이름에서 undersocre을 띄어쓰기로 바꾸어 사용할 것입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Verbose field names&lt;/code&gt;를 보십시오.&lt;/p&gt;

&lt;h2 id=&quot;validators&quot;&gt;validators&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Field.validators&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;해당 필드에 대해서 실행할 validator의 list입니다. 자세한 사항은 validator document를 보십시오.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Registering and fetching lookups&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Field&lt;/strong&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;lookup registration API&lt;/code&gt;를 구현했습니다. API를 사용하여 필드 클래스에 사용할 수 있는 lookup과 필드에서 lookup을 가져오는 방법을 customize할 수 있다.&lt;/p&gt;</content><author><name>Seonkyu Kim(김선규)</name><email>hopsprings2ternal@gmail.com</email></author><category term="dango 2.1" /><category term="reference" /><summary type="html">들어가며: 본 글은 장고 공식 문서 중 Field types의 Field options에 관한 번역입니다. 피드백은 언제나 감사합니다.</summary></entry><entry><title type="html">Django 2.1 reference 번역: Introduction to models 1</title><link href="http://localhost:4000/reference/Introduction-to-models-1/" rel="alternate" type="text/html" title="Django 2.1 reference 번역: Introduction to models 1" /><published>2019-01-30T00:00:00+09:00</published><updated>2019-01-30T00:00:00+09:00</updated><id>http://localhost:4000/reference/Introduction-to-models-1</id><content type="html" xml:base="http://localhost:4000/reference/Introduction-to-models-1/">&lt;blockquote&gt;
  &lt;p&gt;들어가며: 본 글의 장고 공식 문서 중 Introduction to models의 앞의 절반, 즉 모델 상속 전까지의 번역본 입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;원본 링크: &lt;a href=&quot;https://docs.djangoproject.com/en/2.1/topics/db/models/&quot;&gt;https://docs.djangoproject.com/en/2.1/topics/db/models/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;models&quot;&gt;Models&lt;/h1&gt;

&lt;p&gt;model은 데이터에 대한 하나의, 결정적인 정보입니다. 모델은 필수적인 field들과 저장하고 있는 데이터들의 행동을 결정합니다. 일반적으로, 각각의 model은 하나의 database table로 매핑됩니다.&lt;/p&gt;

&lt;p&gt;기초 사항:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각각의 model은 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;django.db.models.Model&lt;/code&gt;&lt;/strong&gt;의 하위 python 클래스입니다.&lt;/li&gt;
  &lt;li&gt;model 클래스의 각각의 attribute는 database field를 나타냅니다.&lt;/li&gt;
  &lt;li&gt;이것들과 함께, Django는 기본적인 database-access API를 제공합니다; &lt;code class=&quot;highlighter-rouge&quot;&gt;Making queries&lt;/code&gt;참고하십시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;quick-example&quot;&gt;Quick example&lt;/h1&gt;

&lt;p&gt;다음 예시는 &lt;strong&gt;first_name&lt;/strong&gt;과 &lt;strong&gt;last_name&lt;/strong&gt;을 갖고 있는 &lt;strong&gt;Person&lt;/strong&gt; model입니다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Person(models.Model):
	first_name = models.CharField(max_length=30)
	last_name = models.CharField(max_length=30)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;first_name&lt;/strong&gt;과 &lt;strong&gt;last_name&lt;/strong&gt;은 model의 &lt;code class=&quot;highlighter-rouge&quot;&gt;field&lt;/code&gt;입니다. 각각의 field는 class attribute로 구체화되며, 각각의 attribute는 하나의 database column으로 매핑됩니다.&lt;/p&gt;

&lt;p&gt;위의 &lt;strong&gt;Person&lt;/strong&gt; model은 다음과 같은 데이터베이스 테이블을 생성합니다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE myapp_person (
	&quot;id&quot; serial NOT NULL PRIMARY KEY,
	&quot;first_name&quot; varchar(30) NOT NULL,
	&quot;last_name&quot; varchar(30) NOT NULL
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Some technical notes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;테이블의 이름인 &lt;strong&gt;myapp_person&lt;/strong&gt;은 model metadata로부터 자동적으로 생성되지만, override할 수 있습니다. 자세한 사항은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Table names&lt;/code&gt;를 참조하십시오.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;id&lt;/strong&gt; field는 자동적으로 추가되지만 이 역시 override할 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Automatic primary key fields&lt;/code&gt;를 참조하십시오.&lt;/li&gt;
  &lt;li&gt;위 예시의 &lt;strong&gt;CREATE TABLE&lt;/strong&gt;은 PostgreSQL 문법으로 쓰여 있는데, Django가  &lt;code class=&quot;highlighter-rouge&quot;&gt;settings file&lt;/code&gt;에 명시된 database backend 맞춤 SQL 을 사용한다는 것을 기억하십시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;using-models&quot;&gt;Using models&lt;/h1&gt;

&lt;p&gt;models를 정의한 후, Django의 settings file을 수정하여 앞으로 그 models를 사용할 것이라고 알려주어야 합니다. 이를 위해 &lt;strong&gt;INSTALLED_APPS&lt;/strong&gt;파일에 &lt;strong&gt;models.py&lt;/strong&gt;를 포함하고 있는 module의 이름을 추가하십시오.&lt;/p&gt;

&lt;p&gt;예를 들어, 만약 당신의 application의 models가 &lt;strong&gt;myapp.models&lt;/strong&gt; module 안에 있다면 (&lt;strong&gt;manage.py startapp&lt;/strong&gt; 명령어를 사용하여 만든 application package structure 안에 있다면), &lt;strong&gt;INSTALLED_APPS&lt;/strong&gt;는 다음과 같습니다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSTALLED_APPS = [
	#...
	'myapp',
	#...
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;새로운 app들을 &lt;strong&gt;INSTALLED_APPS&lt;/strong&gt;에 추가한 뒤, &lt;strong&gt;manage.py makemigrations&lt;/strong&gt;를 이용하여 부분적 migrations를 만든 후, &lt;strong&gt;manage.py migrate&lt;/strong&gt;를 꼭 실행하도록 하십시오.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;fields&quot;&gt;Fields&lt;/h1&gt;

&lt;p&gt;기존에 정의된 database field들의 리스트를 아는 것은 model에서 가장 중요한 부분입니다 (그리고 model에서 신경써야 할 유일한 부분입니다). Fields는 class attirbute에 의해 명시됩니다. &lt;strong&gt;clean, save&lt;/strong&gt; 또는 &lt;strong&gt;delete&lt;/strong&gt;와 같은 &lt;code class=&quot;highlighter-rouge&quot;&gt;models API&lt;/code&gt;와 field의 이름이 충돌하지 않도록 주의하십시오.&lt;/p&gt;

&lt;p&gt;예시 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Musician(models.Model):
	first_name = models.CharField(max_length=50)
	last_name = models.CharField(max_length=50)
	instrument = models.CharField(max_length=100)

class Album(models.Model):
	artist = models.ForeignKey(Musician, on_delete=models.CASCADE)
	name = models.CharField(max_length=100)
	release_date = models.DateField()
	num_starts = models.IntegerField()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;field-types&quot;&gt;Field types&lt;/h2&gt;

&lt;p&gt;model 안의 각각의 field는 적당한 &lt;strong&gt;Field&lt;/strong&gt; class안의 instance여야 합니다. Django는 다음 몇 가지를 결정하기 위해 field class types를 사용합니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Column type은 어떤 종류의 database를 저장할지 알려 줍니다.(e.g.&lt;strong&gt;INTEGER, VARCHAR, TEXT&lt;/strong&gt;)&lt;/li&gt;
  &lt;li&gt;Default HTML &lt;code class=&quot;highlighter-rouge&quot;&gt;widget&lt;/code&gt;은 form field들을 rendering할 때 사용됩니다.(e.g. **&lt;input type=&quot;text&quot; /&gt;&lt;select&gt;**)&lt;/select&gt;&lt;/li&gt;
  &lt;li&gt;Minimal validation requirements는 Django의 admin과 자동으로 생성되는 form에서 사용됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Django는 수십 개의 내장 field-type들을 갖고 있습니다; 그 전체 목록을 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reference&lt;/span&gt;&lt;/code&gt;에서 확인할 수 있다. 만약 Django의 내장 field가 제 기능을 못 할 경우, 당신만의 field를 쉽게 작성할 수 있다; &lt;code class=&quot;highlighter-rouge&quot;&gt;Writing custom model fields&lt;/code&gt;를 참조하십시오.&lt;/p&gt;

&lt;h2 id=&quot;field-options&quot;&gt;Field options&lt;/h2&gt;

&lt;p&gt;각각의 field는 해당 field에 필수적인 각각의 arguments를 갖고 있습니다(&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reference&lt;/span&gt;&lt;/code&gt;에 표시되어 있습니다). 예를 들어, &lt;strong&gt;CharField&lt;/strong&gt;(그리고 그것의 subclasses)는 데이터를 저장하는데 사용되는 &lt;strong&gt;VARCHAR&lt;/strong&gt; database field의 사이즈를 명시해주는 &lt;strong&gt;max_length&lt;/strong&gt; 인자를 필요로 합니다.&lt;/p&gt;

&lt;p&gt;또한 모든 field type에 적용되는 공통 argument들이 있습니다. 모두 optional 입니다. 이들은 &lt;code class=&quot;highlighter-rouge&quot;&gt;reference&lt;/code&gt;에서 전부 설명되어 있지만, 여기에서는 가장 많이 사용하는 몇 가지만 요약을 하겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;제 블로그 reference 에 Field options 문서를 번역해놓았으니 참고하시면 좋을 것 같습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;null&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 &lt;strong&gt;True&lt;/strong&gt;라면, Django는 database에 빈 값인 &lt;strong&gt;NULL&lt;/strong&gt;값을 저장할 수 있습니다. 초기 값은 &lt;strong&gt;False&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;blank&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 &lt;strong&gt;True&lt;/strong&gt;라면, field는 빈 칸이 있을 수 있습니다. 초기 값은 False입니다.&lt;/p&gt;

&lt;p&gt;blank는 null과 다릅니다. null은 database-related인 반면, blank는 validation-related입니다. 만약 field에서 &lt;strong&gt;blank=True&lt;/strong&gt;라면, form validation은 entry의 비어있는 값을 허락합니다. 만약 field에서 &lt;strong&gt;blank=False&lt;/strong&gt;라면, 그 field의 값은 항상 요구됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;choices&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2-tuples로 구성된 iteralbe(e.g. list or tuple)을 이 field의 choices로 사용할 수 있습니다. 만약 choices가 주어지면, default form widget은 기본적인 text field가 아니라 select box가 될 것이고, 주어진 choices로 선택권이 제한될 것입니다.&lt;/p&gt;

&lt;p&gt;choices list의 예시는 다음과 같습니다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;YEAR_IN_SCHOOL_CHOICES = (
	('FR', 'Freshman'),
	('SO', 'Sophomore'),
	('JR', 'Junior'),
	('SR', 'Senior'),
	('GR', 'Graduate'),
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;각각의 tuple의 첫 번째 요소는 database에 저장되는 값입니다. 두 번째 요소는 field의 form widget에 나타나는 값(display value)입니다.&lt;/p&gt;

&lt;p&gt;model instance가 주어졌을 때, &lt;strong&gt;choices&lt;/strong&gt;를 갖고 있는 field에서 display value는 &lt;strong&gt;get_F00_display()&lt;/strong&gt; method를 이용하여 접근할 수 있다. 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Person(models.Model):
	SHIRT_SIZES = (
		('S', 'Small'),
		('M', 'Medium'),
		('L', 'Large'),
	)
	name = models.CharField(max_length=60)
	shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)

&amp;gt;&amp;gt;&amp;gt; p = Person(name=&quot;Fred Flintsone&quot;, shirt_size='L')
&amp;gt;&amp;gt;&amp;gt; p.save()
&amp;gt;&amp;gt;&amp;gt; p.shirt_size
'L'
&amp;gt;&amp;gt;&amp;gt; p.get_shirt_size_display()
'Large'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;field의 초기 값이다. 이는 한 값이나 callable object가 될 수 있다. 만약 callable하다면 이것은 새로운 object가 생성될 때마다 실행될 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;help_text&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;form widget에 표시될 추가적인 “help” text이다. 이는 field가 form에서 사용되지 않더라도 documentation하는데 유용하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;primary_key&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 &lt;strong&gt;True&lt;/strong&gt;라면, 이 field는 model의 primary key가 된다.&lt;/p&gt;

&lt;p&gt;만약 너가 model에서 어떤 field에도 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;primary_key=True&lt;/code&gt;&lt;/strong&gt;로 설정해 두지 않았다면, Django는 자동적으로 primary key로 사용할 &lt;code class=&quot;highlighter-rouge&quot;&gt;**IntegerField**&lt;/code&gt;를 추가하기 때문에 너가 default primary-key를 override하고 싶지 않은 이상 어떤 field에 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;primary_key=True&lt;/code&gt;&lt;/strong&gt;를 설정할 필요없다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Automatic primary key fields&lt;/code&gt;에 더 자세히 기술되어 있다.&lt;/p&gt;

&lt;p&gt;primary key field는 읽을 수만 있다. 만약 너가 기존 object의 primary key 값을 변경한다면, 기존 object옆에 새로운 object가 생성될 것이다. 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Fruit(models.Model):
	name = models.CharField(max_length=100, primary_key=True)

&amp;gt;&amp;gt;&amp;gt; fruit = Fruit.objects.create(name='Apple')
&amp;gt;&amp;gt;&amp;gt; fruit.name = 'Pear'
&amp;gt;&amp;gt;&amp;gt; fruit.save()
&amp;gt;&amp;gt;&amp;gt; Fruit.objects.values_list('name', flat=True)
&amp;lt;QuerySet ['Apple', 'Pear']&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unique&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 True라면, 이 field는 table 전체에서 유일해야 한다.&lt;/p&gt;

&lt;p&gt;다시 한 번 말하지만, 이들은 모두 공통된 field option들에 대한 짧은 설명이다. 자세한 내용은 &lt;code class=&quot;highlighter-rouge&quot;&gt;common model field option reference&lt;/code&gt;에 기술되어 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;automatic-primary-key-fields&quot;&gt;Automatic primary key fields&lt;/h2&gt;

&lt;p&gt;초기 값으로, Django는 각각의 model에 다음과 같은 field를 생성한다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id = models.AutoField(primary_key=True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 auto-incrementing primary key이다.&lt;/p&gt;

&lt;p&gt;만약 너가 custom primary key를 명시하고 싶다면, 너의 field들 중 하나에 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;primary_key=True&lt;/code&gt;&lt;/strong&gt;를 명시하여라. 만약 명시적으로 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Field.primary_key&lt;/code&gt;&lt;/strong&gt;를 설정 했다면, Django는 자동적으로 생성된 &lt;strong&gt;id&lt;/strong&gt; column을 추가하지 않을 것이다.&lt;/p&gt;

&lt;p&gt;각각의 model은 오직 하나의 field만이 primary_key=True를 갖고 있어야 한다(명시적으로 추가 되었든지 아니면 자동적으로 추가 되었든지).&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;verbose-field-names&quot;&gt;Verbose field names&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;와 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;를 제외하고, 각각의 field type들은 선택적인 첫 번째 위치의 argument들을 갖는다 - 바로 verbose name이다. 만약 verbose name이 주어지지 않았다면, Django는 자동적으로 field의 attribute name에 있는 underscores를 space로 바꾸어 verbose name을 생성한다.&lt;/p&gt;

&lt;p&gt;이 예시에서 verbose name은 “&lt;strong&gt;person’s first name&lt;/strong&gt;“이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;first_name = models.CharField(&quot;person's first name&quot;, max_length=30)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 예시에서 verbose name은 “&lt;strong&gt;first name&lt;/strong&gt;“이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;first_name = models.CharField(max_length=30)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;와 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;는 첫 번째 argument로 model class가 필요로 하기 때문에 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;verbose_name&lt;/code&gt;&lt;/strong&gt; keyword argument를 사용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;poll = models.ForeignKey(
	Poll,
	on_delete=models.CASCADE,
	verbose_name=&quot;the related poll&quot;,
)
sites = models.ManyToManyField(Site, verbose_name=&quot;list of sites&quot;)
place = models.OneToOneField(
	Place,
	on_delete=models.CASCADE,
	verbose_name=&quot;related place&quot;,
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;관습적으로 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;verbose_name&lt;/code&gt;&lt;/strong&gt;의 첫 글자는 대문자를 쓰지 않는다. Django가 자동적으로 첫 번째 글자를 대문자로 바꾸어주기 때문이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;relationships&quot;&gt;Relationships&lt;/h2&gt;

&lt;p&gt;명확하게, relational database의 강점은 table간에 relating이 되어있다는 점이다. Django는 가장 많이 사용되는 세 가지 database relationship을 정의해준다: many-to-one, many-to-many 그리고 one-to-one이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Many-to-one relationships&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;many-to-one relationship을 정의하기 위해, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;django.db.models.ForeignKey&lt;/code&gt;&lt;/strong&gt;를 사용해라. 너는 이것을 다른 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Field&lt;/code&gt;&lt;/strong&gt; type처럼 사용하면 된다: 너의 model에 class attribute처럼 추가하여라.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;는 지정된 위치의 argument를 요구한다: 모델과 relate된 class를 지정하는 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어, &lt;strong&gt;Car&lt;/strong&gt; model이 &lt;strong&gt;Manufacturer&lt;/strong&gt;을 갖고 있다면 - 즉, &lt;strong&gt;Manufacturer&lt;/strong&gt;은 다양한 cars를 만들지만 각각의 &lt;strong&gt;Car&lt;/strong&gt;는 단 하나의 &lt;strong&gt;Manufacturer&lt;/strong&gt;를 갖고 있다 - 다음과 같은 정의를 써라:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Manufacturer(models.Model):
	# ...
	pass

class Car(models.Model):
	manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)
	# ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너는 또한 &lt;code class=&quot;highlighter-rouge&quot;&gt;recursive relationship&lt;/code&gt;(자기 자신에게 many-to-one relationship을 갖고 있는 object)을 만들 수 있고 &lt;code class=&quot;highlighter-rouge&quot;&gt;아직 정의되지 않은 model에게 relationship&lt;/code&gt;을 만들 수 있다; 자세한 사항은 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reference&lt;/span&gt;&lt;/code&gt;를 참고하라.&lt;/p&gt;

&lt;p&gt;필수적인 것은 아니지만, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey field&lt;/code&gt;&lt;/strong&gt;의 이름(위의 예에서는 &lt;strong&gt;manufacturer&lt;/strong&gt;)은 소문자의 model 이름을 사용하는 것이 좋다. 물론, 너는 너가 원하는 대로 field 이름을 정해도 된다. 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Car(models.Model):
	company_that_makes_it = models.ForeignKey(
		Manufacturer,
		on_delete=models.CASCADE,
	)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;See also&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt; field는 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;references&lt;/span&gt;&lt;/code&gt;에 설명되어 있는 다른 arguements도 사용할 수 있다. 이 option들은 relationship이 어떻게 작동할지 규정한다; 모두 optional이다.&lt;/p&gt;

    &lt;p&gt;backward-related objects에 접근하는 방법에 대해서는 Following relationships backward example을 참고하라.&lt;/p&gt;

    &lt;p&gt;sample code를 보고 싶다면 Many-to-one relationship model example을 참고하라.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Many-to-many relationships&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Many-to-many relationships를 정의하기 위해, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;를 사용해라. 너는 이것을 다른 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Field&lt;/code&gt;&lt;/strong&gt; type처럼 사용하면 된다: 너의 model에 class attribute처럼 추가하여라.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;는 지정된 위치의 argument를 요구한다: relate할 class를 지정하는 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어, &lt;strong&gt;Pizza&lt;/strong&gt; 가 다양한 &lt;strong&gt;Topping&lt;/strong&gt; objects를 갖고 있다면 - 즉, 한 &lt;strong&gt;Topping&lt;/strong&gt;이 다양한 pizzas에 있을 수 있고 각각의 &lt;strong&gt;Pizza&lt;/strong&gt;는 다양한 toppings를 가질 수 있다 - 다음과 같이 이를 나타내면 된다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Topping(models.Model):
	# ...
	pass

class Pizza(models.Model):
	# ...
	toppings = models.ManyToManyField(Topping)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;와 마찬가지로, 너는 &lt;code class=&quot;highlighter-rouge&quot;&gt;recursive relationship&lt;/code&gt;(자기 자신에게 many-to-many relationship을 갖고 있는 object)을 만들 수 있고 &lt;code class=&quot;highlighter-rouge&quot;&gt;아직 정의되지 않은 model에게 relationship&lt;/code&gt;을 만들 수 있다.&lt;/p&gt;

&lt;p&gt;필수적인 것은 아니지만, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;의 이름(위 예에서는 &lt;strong&gt;toppings&lt;/strong&gt;)을 related model objects를 묘사하고 있는 복수형으로 하는 것이 좋다.&lt;/p&gt;

&lt;p&gt;어떤 model이 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;를 갖고 있는지는 중요하지 않지만, 너는 두 쪽 모두가 아니라 한 쪽에만 이것을 설정해야 한다.&lt;/p&gt;

&lt;p&gt;일반적으로, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt; instance는 form에서 수정되어야 하는 object에 있어야 한다. 위의 예에서는 &lt;strong&gt;toppings&lt;/strong&gt;는 &lt;strong&gt;Pizza&lt;/strong&gt;에 있는데(&lt;strong&gt;Topping&lt;/strong&gt;이 많은 &lt;strong&gt;pizzas &lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;를 갖고 있는 것이 아니다) 그 이유는 pizza가 많은 topping들이 갖고 있다고 생각하는 것이 topping이 많은 pizza들 위에 있다고 생각하는 것보다 자연스럽기 때문이다. 위에서는 이와 같이 설정되어 있으며, Pizza는 사용자들이 topppings들을 선택할 수 있게 해준다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;See also&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;전체 예시를 보기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Many-to-many relationship model example&lt;/code&gt;을 참조하라.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt; field는 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;references&lt;/span&gt;&lt;/code&gt;에 설명되어 있는 다른 arguements도 사용할 수 있다. 이 option들은 relationship이 어떻게 작동할지 규정한다; 모두 optional이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Extra fields on many-to-many relationships&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;pizza와 topping과 같은 단순한 many-to-many relationship을 다루고 있다면, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;가 너가 필요한 전부이다. 하지만, 때때로 너는 relationship이 있는 두 models간의 데이터들을 연결지어야 한다.&lt;/p&gt;

&lt;p&gt;예를 들어 musicians이 속해있는 musical group을 추적하는 경우를 생각해보자. 여기에는 person과 그들이 멤버로서 속해있는 group들 간의 many-to-many relationship이 있고, 너는 이 관계를 나타내기 위해 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;를 사용할 수 있다. 그러나, 너가 얻고 싶어하는 membership과 관련된 세부 사항들, 예를 들어 person들이 group에 들어간 날짜 등이 많이 있다.&lt;/p&gt;

&lt;p&gt;이러한 상황들에서, Django에서 너는 many-to-many relationship을 관리하는 model을 명시할 수 있다. 또한 너는 이 intermidate model에 추가적인 field들을 넣을 수 있다. intermediary 역할을 할 model을 알려주는  &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;through&lt;/code&gt;&lt;/strong&gt; argument를 이용하여 intermediate model은 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;와 연결될 수 있다. 우리의 musician 예시는 다음 코드와 같이 쓸 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Person(models.Model):
	name = models.CharField(max_length=128)
	
	def __str__(self):
		return self.name

class Group(models.Model):
	name = models.CharField(max_length=128)
	members = models.ManyToManyField(Person, through='Membership')
	
	def __str__(self):
		return self.name

class Membership(models.Model):
	person = models.ForeignKey(Person, on_delete=models.CASCADE)
	group = models.ForeignKey(Group, on_delete=models.CASCADE)
	date_joined = models.DateField()
	invite_reason = models.CharField(max_length=64)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너가 intermediary model을 만들 때, 너는 many-to-many relationship에 포함될 model들에게 foreign key를 명시적으로 지정해주어야 한다. 이 명시적 선언은 두 model들이 어떻게 relate되는지 정의한다.&lt;/p&gt;

&lt;p&gt;다음은 intermediate model에서 몇 가지 제약 사항이다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;너의 intermediate model은 source model(우리의 예에서는 &lt;strong&gt;Group&lt;/strong&gt;)로 향하는 foreign key는 단 하나만 갖고 있어야 한거나, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField.through_fields&lt;/code&gt;&lt;/strong&gt;를 사용하여 Django가 relationship을 위해 사용해야 하는 foreign key를 명시적으로 지정해야 한다. 만약 한 개 이상의 foreign key를 갖고 있거나 through_fields가 명시되어 있지 않으면 validation error가 발생할 것이다. 비슷한 제약은 target model(우리의 예에서는 &lt;strong&gt;Person&lt;/strong&gt;)에서도 적용된다.&lt;/li&gt;
  &lt;li&gt;intermediary model을 이용하여 자기 자신에게 many-to-many relationship을 갖고 있는 model에 대해서는, 같은 model로 두 개의 foreign key가 있을 수 있다. 하지만 그들은 many-to-many relationship에서 서로 다른 측면에 있는 것으로 간주된다. 만약 두 개 이상의 foreign key가 있다면, 너는 역시 &lt;strong&gt;through_fields&lt;/strong&gt;를 위와 같이 명시해 주어야 validation error가 발생하지 않을 것이다.&lt;/li&gt;
  &lt;li&gt;intermediary model을 이용하여 자기 자신에게 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;many-to-many relationship&lt;/code&gt;&lt;/strong&gt;을 정의할 때, 너는 &lt;code class=&quot;highlighter-rouge&quot;&gt;symmetrical=False&lt;/code&gt; 를 사용해야 한다(model field reference를 참조하라).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 너의 intermediatry model(우리의 경우 &lt;strong&gt;Membership&lt;/strong&gt;)을 이용하기 위한 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt; 준비 작업을 마쳤고, 너는 many-to-many relationship을 사용할 준비가 되었다. 너는 이것을 intermediate model의 instances를 만들어 사용할 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; ringo = Person.objects.create(name=&quot;Ringo Starr&quot;)
&amp;gt;&amp;gt;&amp;gt; paul = Person.objects.create(name=&quot;Paul McCartney&quot;)
&amp;gt;&amp;gt;&amp;gt; beatles = Group.objects.create(name=&quot;The Beatles&quot;)
&amp;gt;&amp;gt;&amp;gt; m1 = Membership(person=ringo, group=beatles,
...			date_joined=date(1962, 8, 16),
...	 	 	invite_reason=&quot;Needed a new drummer.&quot;)
&amp;gt;&amp;gt;&amp;gt; m1.save()
&amp;gt;&amp;gt;&amp;gt; beatles.members.all()
&amp;lt;QuerySet [&amp;lt;Person: ringo Starr&amp;gt;]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; ringo.group_set.all()
&amp;lt;QuerySet [&amp;lt;Group: The Beatles&amp;gt;]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; m2 = Membership.objects.create(person=paul, group=beatles,
...			date_joined=date(1960, 8, 1),
...			invite_reason=&quot;Wanted to form a band.&quot;)
&amp;gt;&amp;gt;&amp;gt; beatles.memebers.all()
&amp;lt;QuerySet [&amp;lt;Person: Ringo starr&amp;gt;, &amp;lt;Person: Paul McCartney&amp;gt;]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;보통의 many-to-many field과는 다르게, 너는 &lt;strong&gt;add()&lt;/strong&gt;, &lt;strong&gt;create()&lt;/strong&gt;, 또는 &lt;strong&gt;set()&lt;/strong&gt; 을 relationship을 만들기 위해 사용할 수 없다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; # The following statements will not work
&amp;gt;&amp;gt;&amp;gt; beatles.members.add(john)
&amp;gt;&amp;gt;&amp;gt; beatles.members.create(name=&quot;George Harrison&quot;)
&amp;gt;&amp;gt;&amp;gt; beatles.members.set([john, paul, ringo, george])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;왜 그럴까? 너는 단순히 &lt;strong&gt;Person&lt;/strong&gt;과 &lt;strong&gt;Group&lt;/strong&gt;사이의 relationship을 만들 수 없다 - 너는 &lt;strong&gt;Membership&lt;/strong&gt; model이 필요로 하는 모든 세부 사항들을 명시해 주어야 한다. 단순히 &lt;strong&gt;add&lt;/strong&gt;, &lt;strong&gt;create&lt;/strong&gt; 그리고 assignment call으로는 이러한 추가적인 세부 사항들을 알려줄 방법이 없다. 결과적으로, 이들은 intermediate model을 이용하는 many-to-many relationship에 사용 불가능하다. 이런 종류의 relationship을 만드는 유일한 방법은 intermeidate model의 instance들을 생성하는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;remove()&lt;/code&gt;&lt;/strong&gt; method도 비슷한 이유로 사용 불가능하다. 예를 들어, 만약 intermediate model을 사용하여 정의한 custom들이 &lt;strong&gt;(model1, model2)&lt;/strong&gt;의 유일성을 보장하지 않는다면, &lt;strong&gt;remove()&lt;/strong&gt; 호출은 어떤 어떤 intermediate model의 instance를 삭제해야 하는지 충분한 정보를 제공하지 않는다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Membership.objects.create(person=ringo, group=beatles,
...			date_joined=date(1968, 9, 4),
...			invite_reason=&quot;You've been gone for a month and we miss you.&quot;)
&amp;gt;&amp;gt;&amp;gt; beatles.members.all()
&amp;lt;QuerySet [&amp;lt;Person: Ringo Starr&amp;gt;, &amp;lt;Person: Paul McCartney&amp;gt;, 
&amp;lt;Person: Ringo Starr&amp;gt;]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; # This will not work because it cannot tell which membership to remove
&amp;gt;&amp;gt;&amp;gt; beatles.members.remove(ringo)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러나, &lt;strong&gt;clear()&lt;/strong&gt; method는 모든 many-to-many relationships의 instance들을 삭제하기 위해 사용할 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; # Beatles have broken up
&amp;gt;&amp;gt;&amp;gt; beatles.members.clear()
&amp;gt;&amp;gt;&amp;gt; # Note that this deletes the intermediate model instances
&amp;gt;&amp;gt;&amp;gt; Membership.objects.all()
&amp;lt;QuerySet []&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일단 너가 너의 intermediate model의 instance를 생성하여 many-to-many relationship을 형성했다면, 너는 queries를 볼 수 있다. 평범한 many-to-many relationship과 마찬가지로, 너는 many-to-many로 연결된 model들의 attribute들을 이용하여 query할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Find all the groups with a member whose name starts with 'Paul'
&amp;gt;&amp;gt;&amp;gt; Group.objects.filter(members__name__startswith='Paul')
&amp;lt;QuerySet [&amp;lt;Group: The Beatles&amp;gt;]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너는 또한 intermediate model들을 attributes들을 이용하여 query 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Find all the members of the Beatles that joined after 1 Jan 1961
&amp;gt;&amp;gt;&amp;gt; Person.objects.filter(
...			group__name='The Beatles',
...			membership__date_joined__gt=date(1961,1,1))
&amp;lt;QuerySet [&amp;lt;Person: Ringo Starr]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 너가 membership의 정보들에 접근할 필요가 있으면 너는 &lt;strong&gt;Membership&lt;/strong&gt; model을 직접적으로 querying함으로써 할 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; ringos_membership = Membership.objects.get(group=beatles, person=ringo)
&amp;gt;&amp;gt;&amp;gt; ringos_membership.date_joined
datetime.date(1962, 8, 16)
&amp;gt;&amp;gt;&amp;gt; ringos_membership.invite_reason
'Needed a new drummer.'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;같은 정보에 접근할 수 있는 또 다른 방법은 &lt;strong&gt;Person&lt;/strong&gt; object로부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;many-to-many reverse relationship&lt;/code&gt;을 querying하는 것이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; ringos_membership = ringo.membership_set.get(group=beatles)
&amp;gt;&amp;gt;&amp;gt; ringos_membership.date_joined
datetime.date(1962, 8, 16)
&amp;gt;&amp;gt;&amp;gt; ringos_membership.invite_reason
'Needed a new drummer.'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;One-to-one relationships&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;one-to-one relationship을 정의하기 위해, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;를 사용해라. 너는 어느 다른 &lt;strong&gt;Field&lt;/strong&gt; type처럼 이용하면 된다: 너의 model의 class attribute로 추가해라.&lt;/p&gt;

&lt;p&gt;이것은 한 object가 다른 object를 “extends” 하고 있을 때 그 object의 primary key에서 가장 유용하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;는 지정된 위치의 argument를 요구한다: 모델과 relate된 class를 지정하는 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어, 만약 너가 “places”라는 database를 만들고 있다면, 너는 address, phone number 등과 같은 평범한 것들을 데이터 베이스에 포함할 것이다. 그리고 나서, 너가 그 place들 위에 restaurant들의 데이터 베이스를 세우고 싶다면, &lt;strong&gt;Restaurant&lt;/strong&gt; model에 그 fields들을 복제하는 것 대신에, &lt;strong&gt;Restaurant&lt;/strong&gt;가 &lt;strong&gt;Place&lt;/strong&gt;로 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;를 갖게 만들어 주면 된다(왜냐하면 reataurant “is a” place이기 때문이다; 사실, 이것을 다루기 위해 전형적으로 inheritance를 사용하는데, 이것은 암묵적으로 one-to-one relation을 갖는다).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt; 와 함께 &lt;code class=&quot;highlighter-rouge&quot;&gt;recursive relationship&lt;/code&gt;은 정의될 수 있고 &lt;code class=&quot;highlighter-rouge&quot;&gt;references to as-yet undefined model&lt;/code&gt;도 만들어 질 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;See also&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;전체 예시를 보기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;One-to-one relationship model example&lt;/code&gt;을 참고하라.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;는 또한 optional &lt;code class=&quot;highlighter-rouge&quot;&gt;**parent_link**&lt;/code&gt; argument를 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt; class들은 자동적으로 model의 primary key가 되곤 했다. 이는 더 이상 사실이 아니다(너가 직접 &lt;code class=&quot;highlighter-rouge&quot;&gt;**primary_key**&lt;/code&gt; argument들을 넘겨주어도 말이다). 그러므로, 이제 하나의 model에서 OneToOneField type의 다양한 field를 갖는 것이 가능하다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;models-across-files&quot;&gt;Models across files&lt;/h2&gt;

&lt;p&gt;한 model에서 다른 app에 있는 model로 relate을 하는 것은 완벽히 괜찮다. 이를 하기 위해서, 너의 모델이 정의되어 있는 곳 파일 가장 위에 related model을 import해야 한다. 이후, 필요한 곳 어디든지 그 다른 model class를 참조하면 된다. 예를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models
from geography.models import ZipCode

class Restaurant(models.Model):
	# ...
	zipe_code = models.ForeignKey(
		ZipCode,
		on_delete=models.SET_NULL,
		blank=True,
		null=True,
	)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;field-name-restrictions&quot;&gt;Field name restrictions&lt;/h2&gt;

&lt;p&gt;Django는 model field 이름에 단 두 가지 제약만이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;filed name은 Python reserved word가 될 수 없다. 왜냐하면 이는 Python syntax error를 발생시킬 것이다. 예시를 보자:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; class Example(models.Model):
 	pass = models.IntegerField() # 'pass' is a reserved word!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;field name은 두 개 이상의 underscore을 가질 수 없는데, 이는 Django의 query lookup syntax words이기 때문이다. 예시를 보자:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; class Example(models.Model):
 	foo__bar = models.IntegerField() # 'foo__bar' has two underscores!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 제약 사항들은 해결될 수 있는데, 왜냐하면 너의 field name은 너의 database column 이름과 꼭 어울릴 필요가 없기 때문이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;db_column&lt;/code&gt; option을 참조하여라.&lt;/p&gt;

&lt;p&gt;SQL reserved words, 예를 들어 &lt;strong&gt;join&lt;/strong&gt;, &lt;strong&gt;where&lt;/strong&gt; 또는 &lt;strong&gt;select&lt;/strong&gt;는 model field name으로 사용할 수 있는데, 왜냐하면 Django는 기본 SQL query에 있는 모든 database table 이름과 column 이름들을 직접적으로 사용하지 때문이다. 그것은 너의 특정 database 엔진의 quoting syntax를 사용한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;custom-field-types&quot;&gt;Custom field types&lt;/h2&gt;

&lt;p&gt;만약 기존에 존재하는 model fields들이 너의 목적에 맞게 사용할 수 없다면, 또는 너가 일반적으로 사용되지 않는 database column type을 이용하려면 너만의 자체 field class를 만들 수 있다. 고유의 field를 만드는 전체 방법은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Writing custom model fields&lt;/code&gt;에 나와 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;meta-options&quot;&gt;Meta options&lt;/h1&gt;

&lt;p&gt;inner &lt;strong&gt;class Meta&lt;/strong&gt;를 다음과 같이 사용하여 너의 model에게 metadata를 줄 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Ox(models.Model):
	horn_length = models.IntegerField()

	class Meta:
		ordering = [&quot;horn_length&quot;]
		verbose_name_plural = &quot;oxen&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Model의 metadata는 “field가 아닌 모든 것”이다. 예를 들어 ordering options(&lt;strong&gt;ordering&lt;/strong&gt;), database table name(&lt;strong&gt;db_table&lt;/strong&gt;), 또는 사람이 읽을 수 있는 복수형 또는 단수형 이름들(&lt;strong&gt;verbose_name&lt;/strong&gt; 그리고 &lt;strong&gt;verbose_name_plural&lt;/strong&gt;)이 있다. 모두 필수는 아니고 &lt;strong&gt;class Meta&lt;/strong&gt;를 model에 추가하는 것은 전적으로 optional이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Meta&lt;/strong&gt; option에 대한 전체 목록은 model option reference에서 확인 할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;model-attributes&quot;&gt;Model attributes&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;objects&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;model의 가장 중요한 attribute는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;이다. 이는 interface인데 database query operation들이 이를 통해 Django model로 제공되고 database로부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;retrieve the instances&lt;/code&gt; 하는데 사용된다. 만약 custom &lt;strong&gt;Manager&lt;/strong&gt;가 정의되지 않는다면, 초기 이름은 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;objects&lt;/code&gt;&lt;/strong&gt;이다. Managers은 model instance가 아니라, 단지 model class를 통해서만 접근 할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;model-methods&quot;&gt;Model methods&lt;/h1&gt;

&lt;p&gt;너의 obejcts를 위한 custom “row-leve” functionality를 model에 추가하기 위해 custom method를 정의해라. &lt;code class=&quot;highlighter-rouge&quot;&gt;**Manager**&lt;/code&gt; mehods들은 “table-wide” 관련 작업들을 하기 위해 만들어진 반면, model methods는 특정 model instance에 대해 작동한다.&lt;/p&gt;

&lt;p&gt;이는 business logic을 한 곳에 유지하기 위한 값진 기술이다 - the model&lt;/p&gt;

&lt;p&gt;예를 들어, 이 model은 몇 개의 custom method를 갖고 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Person(models.Moel):
	first_name = models.CharField(max_length=50)
	last_name = models.CharField(max_length=50)
	birth_date = models.DateField()

	def baby_boomer_status(self):
		&quot;Returns the person's baby-boomer status.&quot;
		import datetime
		if self.birth_date &amp;lt; datetime.date(1945, 8, 1):
			return &quot;Pre-boomer&quot;
		elif self.birth_date &amp;lt; datetime.date(1965, 1, 1):
			return &quot;Baby boomer&quot;
		else:
			return &quot;Post-boomer&quot;

	@property
	def full_name(self):
		&quot;Returns the person's full name.&quot;
		return '%s %s' % (self.first_name, self.last_name)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 예시의 마지막 method는 &lt;code class=&quot;highlighter-rouge&quot;&gt;property&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;model i&lt;code class=&quot;highlighter-rouge&quot;&gt;nstance reference&lt;/code&gt;에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;각각의 model에게 자동적으로 주어진 mothod&lt;/code&gt;들의 전체 리스트가 있다. 너는 이들을 override할 수 있다 - &lt;code class=&quot;highlighter-rouge&quot;&gt;overriding predefined model methods&lt;/code&gt;를 참고하라 - 그러나 너가 거의 항상 정의해야 할 몇 가지 method들이 있다:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;__str__()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;모든 object의 문자 표현을 반환하는 Python의 “magic method”이다. model instance가 순수 string으로 표현되어야 할 때마다 Python과 Django이 이를 호출할 것이다. 제일 알아 두어야 할 것은, 이는 너가 대화형 console이나 admin에 obejct를 표시해야 할 때 일어난다.&lt;/p&gt;

&lt;p&gt;너는 항상 이 mothod를 정의하고 싶어할 것이다; 초기 값이 전혀 도움이 되지 않기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;get_absolute_url()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이는 Django에게 한 object에 대해 URL을 계산하라 말한다. Django는 이를 그것의 admin interface 안에서 사용하고 한 object의 URL을 알아내야 할 때 필요하다.&lt;/p&gt;

&lt;p&gt;object를 고유하게 식별하는 URL을 가진 object는 이 method를 정의해야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;overriding-predefined-model-methods&quot;&gt;Overriding predefined model methods&lt;/h2&gt;

&lt;p&gt;customize 할 database 동작을 encapsulate하고 있는 또 다른 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;/code&gt; 집합이 있다. 특히 너는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;&lt;/strong&gt;와 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;delete()&lt;/code&gt;&lt;/strong&gt;가 동작하는 방법을 종종 바꾸고 싶을 것이다.&lt;/p&gt;

&lt;p&gt;너는 자유롭게 이 methods(그리고 다른 model methods) 역시 override할 수 있고 동작을 바꿀 수 있다.&lt;/p&gt;

&lt;p&gt;내장 method들을 override하는 전형적인 경우는 너가 object를 저장할 때마다 어떤 일이 일어나게 하고 싶을 때이다. 예시를 보자(&lt;code class=&quot;highlighter-rouge&quot;&gt;**save()**&lt;/code&gt;에서 받아들이는 parameter의 문서를 참조하라):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Blog(models.Model):
	name = models.CharField(max_length=100)
	tagline = models.TextFeild()

	def save(self, *args, **kwargs):
		do_something()
		super().save(*args, **kwargs)
		do_something_else()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너는 또한 잘못된 저장을 방지할 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Blog(models.Model):
	name = models.CharField(max_length=100)
	tagline = models.TextField()

	def save(self, *args, **kwargs):
		if self.name == &quot;Yoko One's blog&quot;:
			return # Yoko shall never have her own blog!
		else:
			super().save(*args, **kwargs) # Call the &quot;real&quot; save() method
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;database에 object가 저장되는 것을 확실히 하기 위해 superclass의 method를 호출해야 하는 것을 기억해야 한다 - 바로 &lt;strong&gt;super.save(*args, **kwargs)&lt;/strong&gt; 이다. 만약 너가 superclass의 method를 호출하는 것을 잊는다면, default behavior은 발생하지 않을 것이고 database는 변하지 않을 것이다.&lt;/p&gt;

&lt;p&gt;또한 model method 에 전달할 수 있는 parameter를 전달하는 것이 중요하다 - 이것이 바로 &lt;strong&gt;&lt;em&gt;args, **kwargs**들이 하는 것이다. Django는 수시로 새로운 argument를 추가하면서 내장된 model method 기능들을 확장한다. 만약 너가 method를 정의할 때 **&lt;/em&gt;args&lt;/strong&gt;, &lt;strong&gt;**kwargs&lt;/strong&gt;를 사용한다면, 너의 코드는 argument들이 추가될 때 자동적으로 이들을 지원할 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Overriden model methods are not called on bulk operations&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;deleting objects in bulk using a QuerySet&lt;/code&gt;을 하거나 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cascading delete&lt;/code&gt;&lt;/strong&gt;의 결과로 삭제 될 때 object의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;delete()&lt;/code&gt;&lt;/strong&gt; method는 필수적으로 호출 될 필요 없다. customized delete logic이 실행 되었는지 확인하고 싶다면, 너는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pre_delete&lt;/code&gt;&lt;/strong&gt; 또는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;post_delete&lt;/code&gt;&lt;/strong&gt;를 사용할 수 있다.&lt;/p&gt;

    &lt;p&gt;불행히도 bulk로 object를 creating과 updating 할 때는 해결할 수 있는 방법이 없다. 왜냐하면 &lt;strong&gt;save()&lt;/strong&gt;, &lt;strong&gt;pre_save&lt;/strong&gt;, 그리고 &lt;strong&gt;post_save&lt;/strong&gt; 그 어느 것도 호출되지 않기 때문이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;executing-custom-sql&quot;&gt;Executing custom SQL&lt;/h2&gt;

&lt;p&gt;다른 일반적인 패턴은 custom SQL statements를 model method와 module-level method에 작성하는 것이다. raw SQL을 사용하는데 더 세부적인 사항은 &lt;code class=&quot;highlighter-rouge&quot;&gt;using raw SQL&lt;/code&gt; 을 참조하여라.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;model-inheritance&quot;&gt;Model inheritance&lt;/h1&gt;

&lt;p&gt;Django에서의 model inheritance는 Python에서 일반적인 class inheritance와 거의 동일하게 작동하지만, 이 페이지의 시작 부분의 기초 사항들은 따라야 한다. 즉, base class 역시 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;django.db.models.Model&lt;/code&gt;&lt;/strong&gt;의 하위 클래스여야 한다.&lt;/p&gt;

&lt;p&gt;너가 결정해야 할 유일한 것은 너의 부모 model이 그 고유의 model(자신의 database table을 갖고 있는)이 될 것인지, 아니면 부모 model이 단지 자식 class들을 통해서만 볼 수 있는 공통된 정보들을 담고 있을 것인지이다.&lt;/p&gt;

&lt;p&gt;다음은 Django에서 가능한 세 가지 유형의 inheritance이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;종종 너는 부모 class를 사용하여 각 하위 model에 입력하고 싶지 않은 정보들을 보유하게 하기를 원할 것이다. 이 class는 따로 분리하여 사용하지 않으므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Abstract base classes&lt;/code&gt; 가 다음에 볼 내용이다.&lt;/li&gt;
  &lt;li&gt;만약 너가 이미 존재하는 model을 상속 받기 원하고(아마 완전히 다른 application으로 부터) 각각의 model이 그들의 database table을 갖고 있기를 원한다면, &lt;code class=&quot;highlighter-rouge&quot;&gt;Multi-table inheritnace&lt;/code&gt;를 살펴야 한다.&lt;/li&gt;
  &lt;li&gt;마지막으로 model field를 수정하지 않고 단지 model의 Python-level behavior를 수정하기 원한다면, 너는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Proxy models&lt;/code&gt;를 사용할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;abstract-base-classes&quot;&gt;Abstract base classes&lt;/h2&gt;

&lt;p&gt;abstract base classes는 다수의 다른 model들에게 공통된 정보들을 담고 싶을 때 유용하다. 너는 &lt;strong&gt;base class&lt;/strong&gt;를 작성하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class에 abstract=True라고 설정하면 된다. 그러면 이 model은 database를 만드는데 사용되지 않는다. 대신에 이것이 다른 model들을 위한 base class로 사용될 때, 이것의 field들이 child class의 field들에 추가된다.&lt;/p&gt;

&lt;p&gt;다음 예시를 보자 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class CommonInfo(models.Model):
	name = models.CharField(max_length=100)
	age = models.PositiveIntegerField()

		class Meta:
			abstract= True

class Student(CommonInfo):
	home_group = models.CharField(max_length=5)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Student&lt;/strong&gt; model은 세 가지 field를 갖게 될 것이다: &lt;strong&gt;name&lt;/strong&gt;, &lt;strong&gt;age&lt;/strong&gt;, 그리고 &lt;strong&gt;home_group&lt;/strong&gt;이다. &lt;strong&gt;CommonInfo&lt;/strong&gt; model은 보통의 Django model처럼 사용될 수 없는데, 이것은 abstract base class이기 때문이다. 이것은 database table을 생성하지 않고 manager를 갖고 있지 않으며 instantiated 될 수 없고 직접적으로 저장 될 수 없다.&lt;/p&gt;

&lt;p&gt;abstract base classes로부터 상속된 fields들은 또 다른 field나 값으로 override 할 수 있고 &lt;strong&gt;None&lt;/strong&gt;으로 제거 할 수 있다.&lt;/p&gt;

&lt;p&gt;많은 용도로 이런 종류의 model inheritance는 너가 정확히 원하는 것일 것이다. 이것은 Python level에서 공통 정보를 분석하는 방법을 제공하면서 동시에 database level에서는 자식 model 당 하나의 database table을 만든다.&lt;/p&gt;

&lt;h2 id=&quot;meta-inheritance&quot;&gt;Meta inheritance&lt;/h2&gt;

&lt;p&gt;abstract base class가 생성될 때, Django는 base class에서 선언 한 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; inner class를 attribute로 사용할 수 있게 한다. 만약 자식 class가 그것 고유의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class를 선언하지 않았을 경우, 그것은 부모의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt;를 상속받는다. 만약 자식이 부모의 Meta class를 extend하고 싶다면, 상속받으면 된다. 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class CommonInfo(models.Model):
	# ...
	class Meta:
		abstract = True
		ordering = ['name']

class Student(CommonInfo):
	# ...
	class Meta(CommonInfo.Meta):
		db_table = 'student_info'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Django는 abstract base class의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class에 단 하나의 값을 조정 해준다: &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; attribute를 installing하기 전에, &lt;strong&gt;abstract=False&lt;/strong&gt;로 설정한다. 이것은 abstract base classes의 자식들이 자동적으로 abstract class가 되지 않는다는 것을 의미한다. 물론, 너는 다른 abstract base class로부터 상속받는 또 다른 abstract base class를 만들 수 있다. 단지 매번 명시적으로 abstract=True라고 설정해야 한다는 것을 기억하면 된다.&lt;/p&gt;

&lt;p&gt;몇몇 attribute들은 abstract base class의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class 안에 있기에 부적합하다. 예를 들어 &lt;strong&gt;db_table&lt;/strong&gt;을 포함한다는 것은 (그들 고유의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt;를 명시하지 않은) 모든 자식 classes이 모두 같은 database table을 이용한다는 것인데, 이것은 너가 원하는 작업 아닐 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;be-careful-with-related_name-and-related_query_name&quot;&gt;Be careful with related_name and related_query_name&lt;/h2&gt;

&lt;p&gt;만약 너가 &lt;strong&gt;ForeignKey&lt;/strong&gt; 또는 &lt;strong&gt;ManyToManyField&lt;/strong&gt;에서 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_name&lt;/code&gt;&lt;/strong&gt; 또는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_query_name&lt;/code&gt;&lt;/strong&gt;을 사용한다면, 너는 항상 반드시 field에 대한 &lt;em&gt;unique&lt;/em&gt; reverse name과 query name을 명시해 주어야 한다. 이것은 보통 abstract base class에서 문제를 유발하는데, 이 class에 있는 field들이 매번 같은 값의 attribute(&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_name&lt;/code&gt;&lt;/strong&gt;과 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_query_name&lt;/code&gt;&lt;/strong&gt;을 포함해서)로 각각의 자식 class에 포함되기 때문이다.&lt;/p&gt;

&lt;p&gt;abstract base class에서 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_name&lt;/code&gt;&lt;/strong&gt; 또는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_query_name&lt;/code&gt;&lt;/strong&gt;을 사용할 때 이 문제를 해결하기 위해서는, value의 일부분이 ‘&lt;strong&gt;%(app_label)s&lt;/strong&gt;‘와 ‘&lt;strong&gt;%(class)s&lt;/strong&gt;‘를 포함하고 있어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;‘&lt;strong&gt;%(class)s&lt;/strong&gt;‘는 field가 사용되는 자식 class의 소문자 이름으로 대체된다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;’%(app_label)s’&lt;/strong&gt;는 자식 class가 포함되어 있는 app의 소문자 이름으로 대체된다. 각각의 installed applicatoin은 유일하고 app 안에 있는 model class 이름도 유일한 것이 틀림 없기에, 최종 이름은 서로 다르게 될 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어 &lt;strong&gt;comon/models.py&lt;/strong&gt;에 다음과 같은 app이 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Base(models.Model):
	m2m = models.ManyToManyField(
		OtherModel,
		related_name=&quot;%(app_label)s_%(class)s_related&quot;,
		related_query_name=&quot;%(app_label)s_%(class)ss&quot;,
	)
	
	class Meta:
		abstract = True

class ChildA(Base):
	pass

class ChildB(Base):
	pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;rare/models.py&lt;/strong&gt;에도 다음 app이 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from common.models import Base

class ChildB(Base):
	pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;common.ChildA.m2m&lt;/strong&gt; field의 reverse name은 &lt;strong&gt;common_childa_related&lt;/strong&gt;가 될 것이고 reverse query name은 &lt;strong&gt;common_childas&lt;/strong&gt;가 될 것이다. &lt;strong&gt;common.childB.m2m&lt;/strong&gt; field의 reverse name은 &lt;strong&gt;common_childb_related&lt;/strong&gt;가 될 것이고 reverse query name은 &lt;strong&gt;common_chlidbs&lt;/strong&gt;가 될 것이다. 마지막으로 &lt;strong&gt;rare.ChildB.m2m&lt;/strong&gt; field의 reverse name은 &lt;strong&gt;rare_childb_related&lt;/strong&gt;가 될 것이고 reverse query name은 &lt;strong&gt;rare_childbs&lt;/strong&gt;가 될 것이다. 너의 related name이나 related query name을 구성하기 위해 ‘&lt;strong&gt;%(class)s&lt;/strong&gt;‘와 &lt;strong&gt;’%(app_label)s’&lt;/strong&gt; 부분들을 어떻게 사용하는지는 너에게 달려있지만, 만약 너가 그것의 사용을 잊어버린다면, Django는 너가 system check(또는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;migrate&lt;/code&gt;&lt;/strong&gt;)를 사용할 때 error를 일으킬 것이다.&lt;/p&gt;

&lt;p&gt;만약 너가 abstract base class의 field에 대한 &lt;code class=&quot;highlighter-rouge&quot;&gt;**related_name**&lt;/code&gt; attribute를 명시하지 않았다면, default reverse name은 child class 이름 뒤에 &lt;strong&gt;‘_set’&lt;/strong&gt;이 붙은 것이 될 것이고, 너가 child class에 직접적으로 선언한 것처럼 정상적으로 작동할 것이다. 예를 들어 위의 코드에서, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_name&lt;/code&gt;&lt;/strong&gt; attribute가 생략 되었다면, &lt;strong&gt;m2m&lt;/strong&gt; field의 reverse name은 &lt;strong&gt;ChildA&lt;/strong&gt;의 경우 &lt;strong&gt;childa_set&lt;/strong&gt;이 될 것이고 &lt;strong&gt;ChildB&lt;/strong&gt;의 경우 &lt;strong&gt;childb_set&lt;/strong&gt;이 될 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;multi-table-inheritance&quot;&gt;Multi-table inheritance&lt;/h2&gt;

&lt;p&gt;Django에서 지원하는 두 번째 타입의 model inheritance는 계층 구조의 각 model이 모두 하나의 model일 때이다. 각각의 model은 그들 고유의 database table에 대응되고 독립적으로 queried 되고 생성될 수 있다. inheritance relationship은 자식 model과 그들의 부모 사이의 links를 소개한다(자동적으로 생성되는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;를 통해서). 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Place(models.Model):
	name = models.CharField(max_length=50)
	address = models.CharField(max_length=80)

class Restaurant(Place):
	serves_hot_dogs = models.BooleanField(default=False)
	serves_pizza = models.BooleanField(default=False)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;data들은 서로 다른 database table에 있음에도 불구하고 &lt;strong&gt;Place&lt;/strong&gt;의 모든 field들은 &lt;strong&gt;Restaurant&lt;/strong&gt;에서도 모두 이용 가능하다. 따라서 다음 두 가지가 모두 가능하다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Place.objects.filter(name=&quot;Bob's Cafe&quot;)
&amp;gt;&amp;gt;&amp;gt; Restaurant.objects.filter(name=&quot;Bob's Cafe&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 너가 &lt;strong&gt;Restaurant&lt;/strong&gt; 이기도 한 &lt;strong&gt;Place&lt;/strong&gt;를 갖고 있다면, 너는 &lt;strong&gt;Place&lt;/strong&gt; object로부터 소문자 model 이름을 이용함으로써 &lt;strong&gt;Restaurant&lt;/strong&gt; object를 얻을 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; p = Place.objects.get(id=12)
# If p is a Restaurant obejct, this will give the child class:
&amp;gt;&amp;gt;&amp;gt; p.restaurant
&amp;lt;Restaurant: ...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러나 만약 위 예시에서의 &lt;strong&gt;p&lt;/strong&gt;가 &lt;strong&gt;Restaurant&lt;/strong&gt;가 아니라면(그것이 &lt;strong&gt;Place&lt;/strong&gt; object로 직접적으로 생성되었거나 다른 class의 부모였다면), &lt;strong&gt;p.restaurant&lt;/strong&gt;를 호출하는 것은 &lt;strong&gt;Restaurant.DoesNotExist&lt;/strong&gt; exception을 일으킬 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Restaurant&lt;/strong&gt;에 자동적으로 생성된 &lt;strong&gt;Place&lt;/strong&gt;로 link해주는 &lt;strong&gt;OneToOneField&lt;/strong&gt;는 다음과 같이 생겼다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;place_ptr = models.OneToOneField(
	Place, on_delete=models.CASCADE,
	parent_link=True,
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너는 해당 field를 &lt;strong&gt;Restaurant&lt;/strong&gt;에 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;parent_link=True&lt;/code&gt;&lt;/strong&gt; 와 함께 고유의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;를 선언함으로써 override할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Meta and multi-table inheritance&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;multi-table inheritance의 경우에, 자식 class에서 부모의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class를 상속받는 것은 말이 되지 않는다. 모든 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; option들은 이미 부모 class에 적용되었고, 그들을 다시 적용하는 것은 보통 모순적인 행동으로 보일 것이다(이것은 abstract base class와는 반대인데, base class는 그들 스스로는 존재하지 않는다).&lt;/p&gt;

&lt;p&gt;따라서 자식 model은 그들 부모의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class에 접근할 수 없다. 그러나 부모로부터 몇 가지 행동을 상속받는 경우가 있다: 만약 자식이 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ordering&lt;/code&gt;&lt;/strong&gt; attribute 또는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get_latest_by&lt;/code&gt;&lt;/strong&gt; attribute를 명시하지 않는다면, 자식은 부모로부터 이들을 상속받을 것이다.&lt;/p&gt;

&lt;p&gt;만약 부모가 ordering을 갖고 있고 너는 자식이 아무런 ordering을 갖지 않기를 원하면, 명시적으로 사용을 중단 할 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ChildModel(ParentModel):
	# ...
	class Meta:
		# Remove parent's ordering effect
		ordering = []
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Inheritance and reverse relations&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;multi-table inheritance가 자식과 부모를 link하기 위해 암묵적인 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;를 사용했기 때문에, 위의 예시처럼 부모에서 자식으로 내려가는 것이 가능하다. 하지만, 이는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt; 와 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;의 default &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_name&lt;/code&gt;&lt;/strong&gt; 값을 사용해 나간다. 만약 너가 부모의 자식 class에 이런 종류의 relations를 둔다면, 너는 반드시 각각의 field에 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_name&lt;/code&gt;&lt;/strong&gt; attribute를 명시해야 한다. 만약 그렇지 않으면, Django는 validation error를 일으킬 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어, 위의 &lt;strong&gt;Place&lt;/strong&gt; class 를 다시 사용하여 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;를 이용한 다른 자식 class를 만들자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Supplier(Place):
	customers = models.ManyToManyField(Place)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음은 error 결과이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Reverse query name for 'Supplier.customers'
clashes with reverse query
name for 'Supplier.place_ptr'.

HINT: Add or Change a related_name argument to the fefinition for
'Supplier.customers' or 'Supplier.place_ptr'.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같이 &lt;strong&gt;customers&lt;/strong&gt; field에 &lt;strong&gt;related_name&lt;/strong&gt;을 추가 해주는 것은 error를 해결할 수 있다: &lt;strong&gt;models.ManyToManyField(Place, related_name=’provider’)&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Specifying the parent link field&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;위에서 말했듯이, Django는 너의 자식 class와 그 어떤 non-abstract parent model과 연결해주는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;를 자동적으로 생성할 것이다. 만약 다시 부모로 연결해주는 attribute 이름을 제어하고 싶은 경우, 너는 너만의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;를 생성하고 너의 field가 부모 class를 다시 가리키도록 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;parent_link=True&lt;/code&gt;&lt;/strong&gt;라고 설정하면 된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;proxy-models&quot;&gt;Proxy models&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;multi-table inheritance&lt;/code&gt;를 사용할 때, 새로운 database table은 한 model의 각각의 하위 class에 대해 생긴다. 이는 보통 이상적인 행동인데, 이는 하위 class가 base class에 존재하지 않는 추가적인 data field를 저장할 공간을 필요로 하기 때문이다. 하지만 때때로, 너는 단지 한 model의 Python 동작을 바꾸고 싶을 것이다 - 아마 default manager를 바꾸거나 새로운 method를 추가할 것이다.&lt;/p&gt;

&lt;p&gt;이는 proxy model inheritance을 위한 것이다: 원래 model에 &lt;em&gt;proxy&lt;/em&gt;를 생성하는 것이다. 너는 proxy model의 instances를 생성하고 삭제하고 업데이트 할 수 있으며, 모든 data들은 너가 원래의 (non-proxied) model을 사용하는 것과 같이 저장된다. 차이점은 원래의 것을 변경하지 않고, proxy에서 default model ordering 또는 default manager과 같은 것들을 바꿀 수 있다는 점이다.&lt;/p&gt;

&lt;p&gt;Proxy model들은 보통의 model들과 같이 선언될 수 있다. 너는 Django에게 &lt;strong&gt;Meta&lt;/strong&gt; class의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proxy&lt;/code&gt;&lt;/strong&gt; attribute을 &lt;strong&gt;True&lt;/strong&gt;로 설정함으로써 알려줄 수 있다.&lt;/p&gt;

&lt;p&gt;예를 들어, Person model에 method를 추가하고 싶다고 가정하자. 너는 다음과 같이 할 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Person(models.Model):
	first_name = models.CharField(max_length=30)
	last_name = models.CharField(max_length=30)

class MyPerson(Person):
	class Meta:
		proxy = True

	def do_something(self):
		# ...
		pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;MyPerson&lt;/strong&gt; class는 그것의 부모 &lt;strong&gt;Person&lt;/strong&gt; class와 같은 database table에서 작동한다. 특히, 모든 새로운 Person instance들 또한 MyPerson을 통해 접근 가능하고, 반대의 경우도 가능하다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; p = Person.objects.create(first_name=&quot;foobar&quot;)
&amp;gt;&amp;gt;&amp;gt; MyPerson.objects.get(first_name=&quot;foobar&quot;)
&amp;lt;MyPerson: foobar&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너는 또한 model에서 다른 default ordering을 정의하기 위해 proxy model을 사용할 수 있다. 너는 아마 항상 &lt;strong&gt;Person&lt;/strong&gt; model을 정렬하고 싶지 않을 수 있지만, proxy를 사용할 때 규칙적으로 &lt;strong&gt;last_name&lt;/strong&gt; attribute를 이용하여 정렬할 수 있다. 이것은 쉽다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class OrderedPerson(Person):
	class Meta:
		ordering = [&quot;last_name&quot;]
		proxy = True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 보통의 &lt;strong&gt;Person&lt;/strong&gt; queries는 정렬되지 않지만, &lt;strong&gt;OrderedPerson&lt;/strong&gt; queries는 &lt;strong&gt;last_name&lt;/strong&gt;에 의해 정렬될 것이다.&lt;/p&gt;

&lt;p&gt;Proxy model은 &lt;code class=&quot;highlighter-rouge&quot;&gt;보통의 model들과 같은 방법으로&lt;/code&gt; &lt;strong&gt;Meta&lt;/strong&gt; attribute를 상속 받는다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;QuerySets still return the model that was requested&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;말하자면, 너가 &lt;strong&gt;Person&lt;/strong&gt; objects를 query 할 때마다 Django가 &lt;strong&gt;MyPerson&lt;/strong&gt; object를 반환하게 하는 방법은 없다. &lt;strong&gt;Person&lt;/strong&gt; objects의 queryset은 그 타입의 objects를 반환할 것이다. proxy objects의 요점은 원래의 Person에 의존적인 코드는 proxy objects를 사용할 것이라는 점과 너 고유의 코드는 너가 추가한 extension들을 사용할 수 있다는 점이다(다른 코드는 그다지 의존적이지 않다). 이는 Person (또는 어떠한 다른) model을 너가 만든 다른 것으로 대체할 수 있는 것이 아니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Base class restrictions&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;proxy model은 반드시 하나의non-abstract model class로
 부터 상속을 받아야 한다. 너는 여러 개의 non-abstract models로부터 상속받을 수 없는데, 이는 proxy model은 다른 database table에 있는 rows들 간의 어떤 연결도 제공하지 않기 때문이다. abstract model classes이 어떠한 model fields도 정의하지 않았다면, proxy model은 많은 수의 abstract model classes을 상속할 수 있다. 한 proxy model은 공통의 한 non-abstract 부모 class를 공유하고 있는 여러 proxy models로부터 상속 받을 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Proxy model managers&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 너가 한 proxy model에 어떠한 model manager도 명시하지 않는다면, 그것은 그것의 model parents로부터 managers를 상속한다. 만약 너가 proxy model에 manager를 정의한다면, 그것은 default가 될 것이지만,  부모 classes에 정의된 어떠한 manager도 여전히 사용 가능하다.&lt;/p&gt;

&lt;p&gt;위의 예시를 이어 가자면, 너는 다음과 같이 &lt;strong&gt;Person&lt;/strong&gt; model을 query할 때 default manager를 바꿀 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class NewManager(models.Manager):
	# ...
	pass

class MyPerson(Person):
	objects = NewManager()

	class Meta:
		proxy = True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 proxy에 이미 존재하는 default를 대체하지 않고 새로운 manager를 추가하고 싶다면, 너는 &lt;code class=&quot;highlighter-rouge&quot;&gt;custom manager&lt;/code&gt; 문서에 기술된 방법들을 사용할 수 있다: 새로운 manager를 갖고 있는 base class를 생성한 뒤에 primary base class 이후에 상속 받아라.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Create an abstract class for the new manager.
class ExtraManagers(models.Model):
	secondary = NewManager()
	
	class Meta:
		abstract = True

class MyPerson(Person, ExtraManagers):
	class Meta:
		proxy = True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너는 이를 자주 필요로 하지는 않을 것이지만, 너가 하고 싶을 때 이는 가능하다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Differences between proxy inheritance and unmanaged models&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;proxy model inheritance는 model의 &lt;strong&gt;Meta&lt;/strong&gt; class에 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;managed&lt;/code&gt;&lt;/strong&gt; attribute를 사용하여 unmanaged model을 생성하는 것과 비슷하게 보인다.&lt;/p&gt;

&lt;p&gt;조심스럽게 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Meta.db_table&lt;/code&gt;&lt;/strong&gt;를 설정하여 너는 기존의 model을 가리고 Python method를 거기에 추가할 수 있는 unmanaged model을 생성할 수 있다. 그러나 변경 작업을 수행하면 두 복사본을 동기화 된 상태로 유지해야 하므로 반복적이고 오류가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;다른 한편으로는 proxy model은 proxing 하고 있는 모델과 똑같이 행동하도록 만들어졌다. 그들은 부모 model과 항상 동기화 되어 있는데 그들이 직접적으로 그들의 field와 manager를 상속 받았기 때문이다.&lt;/p&gt;

&lt;p&gt;일반적인 규칙은 다음과 같다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;만약 기존의 model과 database table을 mirroring하고 기존의 모든 database table column들을 원하지 않는다면, Meta.managed=False를 써라. 이 option은 Django가 제어하지 않는 database view와 table을 modeling 할 때 유용하다.&lt;/li&gt;
  &lt;li&gt;만약 너가 model의 Python-only 동작을 변경하고 싶지만, 기존 model의 field를 유지하고 싶다면, Meta.proxy=True를 사용해라. 이는 data가 저장될 때 proxy model의 저장소 구조와 정확히 일치하도록 설정된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;multiple-inheritance&quot;&gt;Multiple inheritance&lt;/h2&gt;

&lt;p&gt;Python의 하위 class와 마찬가지로, Django model이 여러 개의 부모 model로부터 상속 받는 것이 가능하다. 일반적인 Python name resolution rule이 적용된다는 것을 명심해라. 특정 이름(e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt;)가 나타나는 첫 base class가 사용될 것이다. 예를 들어, 이것은 만약 여러 부모 class가 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class를 포함하고 있다면, 첫 번째 것이 사용될 것이며 다른 것들은 모두 무시될 것이다.&lt;/p&gt;

&lt;p&gt;일반적으로, 너는 다수의 부모로부터 상속 받을 필요가 없다. 일반적으로 유용하게 사용되는 경우는 “mix-in” class를 사용할 때이다: mix-in을 상속하고 있는 모든 class에 특정 추가적 field와 method를 추가하는 것이다. 너의 inheritance hierarchies를 가능한 간단하고 직관적으로 유지하여 특정 정보가 어디로부터 왔는지 헷갈리지 않게 해라.&lt;/p&gt;

&lt;p&gt;공통된 &lt;strong&gt;id&lt;/strong&gt; primary key field를 갖고 있는 다양한 model로부터 상속을 받는 것은 error를 일으킬 것이다. 올바르게 multiple inheritance를 사용하기 위해, 너는 base model에 명시적으로 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AutoField&lt;/code&gt;&lt;/strong&gt;를 쓸 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Article(models.Model):
	article_id = models.AutoField(primary_key=True)
	...

class Book(models.Model):
	book_id = models.AutoField(primary_key=True)
	...

class BookReview(Book, Article):
	pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AutoField&lt;/code&gt;&lt;/strong&gt;를 갖고 있는 공통의 ancestor를 사용해라. 이는 각각의 부모 model에서 공통의 ancestor로의 OneToOneField를 명시적으로 사용하는 것을 요구하는데, 자동으로 생성되고 자식으로부터 상속받는 field들 간의 충돌을 피하기 위해서이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Piece(models.Model):
	pass

class Article(Piece):
	article_piece = models.OneToOneField(Piece, on_delete=models.CASCADE, parent_link=True)
	...

class Book(Piece):
	book_piece = models.OneToOneField(Piece, on_delete=models.CASCADE, parent_link=True)
	...

class BookReivew(Book, Article):
	pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;field-name-hiding-is-not-permitted&quot;&gt;Field name “hiding” is not permitted&lt;/h2&gt;

&lt;p&gt;보통의 Python inheritance에서, 자식 class는 부모 class로부터 어떠한 attribute를 override하는 것이 허용된다. Django에서 이것은 model fields에 대하여 주로 허락되지 않는다. 만약 non-abstract class가 &lt;strong&gt;author&lt;/strong&gt;이라 된 field를 갖고 있다면, 너는 그 base class로부터 상속 받은 다른 class에 &lt;strong&gt;author&lt;/strong&gt;이라 불리는 다른 model field나 attribute를 생성할 수 없다.&lt;/p&gt;

&lt;p&gt;이 제약은 abstract model로부터 상속 받은 model field에는 적용되지 않는다. 이러한 field들을 다른 field나 값으로 override 할 수 있고, &lt;strong&gt;field_nam = None&lt;/strong&gt;으로 설정하여 제거 할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;model manager는 abstract base class로 부터 상속된다. 상속된 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;에 의해 참조되는 상속된 field를 override하는 것은 미묘한 bug를 일으킬 수 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;custom managers and model inheritance&lt;/code&gt;를 보아라.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;몇몇의 fields들은 model에 추가적인 attribute를 정의한다. 예를 들어 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;는 field 이름에 &lt;strong&gt;_id&lt;/strong&gt;가 추가된 별도의 attribute를 정의할 뿐만 아니라 &lt;strong&gt;related_name&lt;/strong&gt; 과 &lt;strong&gt;relate_query_name&lt;/strong&gt; 을 foreign model에 정의한다.&lt;/p&gt;

    &lt;p&gt;이런 추가적인 attributes들은 그것을 정의한 field가 바뀌거나 제거되어 더 이상 추가적인 attribute를 정의하지 않는 이상 override할 수 없다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;부모 model의 field를 override하는 것은 (&lt;strong&gt;Model.__init__&lt;/strong&gt;에서 어떤 field가 initialized 될지를 명시하는) 새로운 instance를 initializing 하는 것과 serialization과 같은 영역에 어려움이 있다. 이것들은 Python class inheritance가 똑같은 방식으로 처리 할 필요가 없는 기능이므로, Django model inheritance와 Python class inheritance는 임의적이지 않다.&lt;/p&gt;

&lt;p&gt;이런 제약은 단지 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Field&lt;/code&gt;&lt;/strong&gt; instances인 attribute에만 적용된다. 보통의 Python attribute는 너가 원한다면 Override할 수 있다. 또한 이것은 Python 이 인식하는 attribute 이름에만 적용된다: 만약 너가 직접 database column 이름을 설정한다면, 너는 mutli-table inheritance의 child와 ancestor model에 나타나는 같은 column name을 가질 수 있다(이들은 서로 다른 database table의 column들이다).&lt;/p&gt;

&lt;p&gt;Django는 만약 너가 ancestor model에 있는 어떠한 model field를 override하면 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FieldError&lt;/code&gt;&lt;/strong&gt;를 일으킬 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;organizing-models-in-a-package&quot;&gt;Organizing models in a package&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;manage.py startapp&lt;/code&gt;&lt;/strong&gt; command는 &lt;strong&gt;models.py&lt;/strong&gt; 파일을 갖고 있는 application 구조를 생성한다. 만약 너가 많은 models을 갖고 있다면, 그들을 다른 파일에 구성하는 것이 효과적일 것이다.&lt;/p&gt;

&lt;p&gt;이렇게 하기 위해서는 &lt;strong&gt;models&lt;/strong&gt; package를 만들어라. &lt;strong&gt;models.py&lt;/strong&gt;를 삭제하고 &lt;strong&gt;myapp/models/&lt;/strong&gt; directory를 &lt;strong&gt;__init__.py&lt;/strong&gt; 파일과 너의 models를 저장할 파일들과 함께 만들어라. 너는 model들을 &lt;strong&gt;__init__.py&lt;/strong&gt; 파일에 import 해야 한다.&lt;/p&gt;

&lt;p&gt;예를 들어, 만약 너가 models directory에 &lt;strong&gt;organic.py&lt;/strong&gt;와 &lt;strong&gt;synthetic.py&lt;/strong&gt;를 갖고 있다면 다음과 같다:&lt;/p&gt;

&lt;p&gt;myapp/models/&lt;strong&gt;init&lt;/strong&gt;.py&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from .organic import Person
from .synthetic import Robot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;from .models import *를 사용하는 것보다 명시적으로 각각의 model을 import하는 것이 namespace를 어질러놓지 않을 수 있고, 코드를 더욱 읽기 쉽게 만들어주며, code analysis tools를 효과적으로 만들어준다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;See also&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;The Models Reference&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;model fields, related objects, 그리고 &lt;strong&gt;QuerySet&lt;/strong&gt;을 포함해서 모든 model 관련 API를 다루고 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Seonkyu Kim(김선규)</name><email>hopsprings2ternal@gmail.com</email></author><category term="django 2.1" /><category term="reference" /><summary type="html">들어가며: 본 글의 장고 공식 문서 중 Introduction to models의 앞의 절반, 즉 모델 상속 전까지의 번역본 입니다.</summary></entry></feed>