<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-01-22T23:45:30+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">SERENDIPITY</title><subtitle>Developer</subtitle><author><name>Seonkyu Kim(김선규)</name></author><entry><title type="html">Introduction to database</title><link href="http://localhost:4000/database/introduction-to-database/" rel="alternate" type="text/html" title="Introduction to database" /><published>2019-01-22T00:00:00+09:00</published><updated>2019-01-22T00:00:00+09:00</updated><id>http://localhost:4000/database/introduction-to-database</id><content type="html" xml:base="http://localhost:4000/database/introduction-to-database/">&lt;h1 id=&quot;database&quot;&gt;Database&lt;/h1&gt;

&lt;p&gt;이거 하나로 정리 끝&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/omarelgabrys-blog/database-introduction-part-1-4844fada1fb0&quot;&gt;https://medium.com/omarelgabrys-blog/database-introduction-part-1-4844fada1fb0&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;테이블을 만들 때는 독립적으로 그와 관련된, &lt;strong&gt;변하지 않는&lt;/strong&gt;정보들만 저장한다. 예를 들어 고객 테이블에는 변하지 않는 고객들의 이름과 이메일 등만 저장을 한다.&lt;/li&gt;
  &lt;li&gt;물건을 주문 할 때는 따라서 변하지 않는 주문 테이블을 따로 만드는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;데이터베이스-만들기&quot;&gt;데이터베이스 만들기&lt;/h1&gt;

&lt;h2 id=&quot;1-자료조사&quot;&gt;1. 자료조사&lt;/h2&gt;

&lt;h2 id=&quot;2-table-relationships-규정하기&quot;&gt;2. Table, relationships 규정하기&lt;/h2&gt;

&lt;p&gt;objects를 먼저 규정해야 한다. 이는 고객, 강의, 주문, 프로젝트 등 어떠한 형태도 가능하다. 실제로는 존재하지 않는 카테고리 등도 가능하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;중복된 것을 없애야 한다.&lt;/li&gt;
  &lt;li&gt;몇몇 object는 합치고 분리해야 한다.&lt;/li&gt;
  &lt;li&gt;object의 attribute를 정의해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;object들은 데이터를 담고 있는 것이지, 관계를 포함하고 있지 않기에 객체지향 언어를 사용할 때는 주의해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이후 relation을 규정한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1-M : one to many&lt;/li&gt;
  &lt;li&gt;M-N : many to many&lt;/li&gt;
  &lt;li&gt;1-1 : one to one&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-columns와-data-type-규정하기&quot;&gt;3. Columns와 Data Type 규정하기&lt;/h2&gt;

&lt;p&gt;Datatype은 언어에 따라 달라진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;length : name, address와 같은 column은 데이터 타입 뿐 아니라 fixed length를 정해준다.&lt;/li&gt;
  &lt;li&gt;Null : 입력을 하지 않아도 될 경우 null 을 이용한다.&lt;/li&gt;
  &lt;li&gt;Default Value&lt;/li&gt;
  &lt;li&gt;Other options : 이메일과 같은 column일 경우 형식이 맞는지 확인한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;primary-keys&quot;&gt;Primary Keys&lt;/h1&gt;

&lt;p&gt;어떤 column이 primary key가 될지 정의한다. 주로 정수형을 쓴다. auto-increment를 안 사용하는 것이 좋을 때도 있다.&lt;/p&gt;

&lt;h2 id=&quot;composite-primary-key&quot;&gt;Composite primary key&lt;/h2&gt;

&lt;p&gt;두 개의 column을 합쳐 하나의 primary key로 사용할 수 있다. 강의 수강 학생과 같은 다대다 관계에서 그 예를 볼 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;logical-design&quot;&gt;Logical Design&lt;/h1&gt;

&lt;h2 id=&quot;weak-relation&quot;&gt;Weak Relation&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Partial Key&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;일종의 primary key. 하지만 상위 요소가 없으면 있을 수 없기 때문에 partial key라 불림&lt;/p&gt;

&lt;p&gt;Partial Key 와 Foreign key를 이용해 Primary key 처럼 사용함.&lt;/p&gt;

&lt;h2 id=&quot;1--1&quot;&gt;1 : 1&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;한 쪽이 다른 쪽을 참조하는 방법&lt;/li&gt;
  &lt;li&gt;두 테이블을 합친다.&lt;/li&gt;
  &lt;li&gt;두 개의 Primary key를 갖고 있는 third table을 만든다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;1--m&quot;&gt;1 : M&lt;/h2&gt;

&lt;p&gt;ER diagram 을 그린 후 relation을 토대로 table을 만들 때&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Many에서 1 Side를 참조하는 방향으로 만든다&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;recursive&quot;&gt;Recursive&lt;/h2&gt;

&lt;p&gt;recursive는 1:M일 수도, M:M일 수도, 아니면 다른 형태일 수 있다. 그동안 하던 것과 똑같은 방법으로 하면 된다. 예를 들어 Employee와 Supervision과 같이 1:M의 관계가 있을 경우, Supervision이 1 side, employee가 M side다. 이때, employee table의 column에 supervision란을 추가하여 employee 를 참조하면 된다. 없을 경우 null값을 준다.&lt;/p&gt;

&lt;p&gt;즉, 이전과 같은 방법으로 진행하되 같은 테이블에 column을 추가하여 같은 테이블을 참조하는 방식이다.&lt;/p&gt;

&lt;h2 id=&quot;multi-valued-attribute&quot;&gt;Multi-valued attribute&lt;/h2&gt;

&lt;p&gt;예를 들어 department가 여러 개의 location을 가질 수 있다. 이는 1:M 관계로 department와 location 두 개의 column이 있는 테이블을 새로 만들어준다. 이 두 개의 column을 primary key로 사용한다.&lt;/p&gt;

&lt;h1 id=&quot;normalization&quot;&gt;Normalization&lt;/h1&gt;

&lt;h2 id=&quot;first-normal-form&quot;&gt;First Normal Form&lt;/h2&gt;

&lt;p&gt;First normal form requires that every column should have one, and only one value; there is no multi-valued attribute, and there shouldn’t be repeating groups of data.&lt;/p&gt;

&lt;h2 id=&quot;second-normal-form&quot;&gt;Second Normal Form&lt;/h2&gt;

&lt;p&gt;The second normal form requires that all of the non-primary columns have to be dependent on the entire (composite) primary key.&lt;/p&gt;

&lt;p&gt;회원이 이메일 외에도 다른 attribute를 가질 경우, 그 값들은 third table로 만들지 않는 이상 중복된 값을 가진다. 그래서 third table을 만들어 non-primary column들이 오직 primary key에만 의존적이게 한다.&lt;/p&gt;

&lt;p&gt;만약 한 회원이 여러 개의 이메일을 가질 경우, 위에 적힌 1:M을 사용할 수도 있지만, 확장성을 고려하여 새로운 third table을 만든다. 두 개의 column이 email과 ID이고 이 두개의 column을 primary key로 이용한다.&lt;/p&gt;

&lt;h2 id=&quot;third-normal-form&quot;&gt;Third Normal Form&lt;/h2&gt;

&lt;p&gt;한 column이 primary key가 아닌 다른 값에 의존적일 때, 그 값들을 새로운 table로 만들어준다. 이는 다른 이가 하나의 값을 변경했을 경우, 그 relation이 무너지는 것을 방지하기 위함이다. 예를 들어 course이름, 강의실 번호, 수용 인원이 있을 경우, 강의실 번호와 수용 인원은 상호관계가 있기 때문에 강의실 table을 따로 설정해주는 것이다.&lt;/p&gt;

&lt;p&gt;참고 : &lt;a href=&quot;https://3months.tistory.com/193&quot;&gt;https://3months.tistory.com/193&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;denormalization&quot;&gt;Denormalization&lt;/h2&gt;

&lt;p&gt;한 회원이 이메일을 여러 개 갖고 있을 경우, 만약 이메일의 개수를 2개로 제한한다면, email1 column과 email2 column을 설정하는 것으로 표를 만들 수 있다. 이럴 경우 더 쉽고 수월하게 작업할 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;sqlstructured-query-language&quot;&gt;SQL(Structured Query Language)&lt;/h1&gt;

&lt;p&gt;The Structured Query Language (SQL) — pronounced S-Q-L — is used for creating, querying, updating and manipulating data in relational databases&lt;/p&gt;

&lt;h1 id=&quot;dmldata-manipulation-language&quot;&gt;DML(Data Manipulation Language)&lt;/h1&gt;

&lt;p&gt;The data manipulation language is used to create, read, update, and delete data from a table.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.notion.so/41756fc2e0c745b1a84a041cae904d14&quot;&gt;CRUD&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;다양한 명령어들 : &lt;a href=&quot;https://medium.com/omarelgabrys-blog/database-structured-query-language-part-8-230a1808ec96&quot;&gt;https://medium.com/omarelgabrys-blog/database-structured-query-language-part-8-230a1808ec96&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;indexing&quot;&gt;Indexing&lt;/h1&gt;

&lt;p&gt;Use index to find the tuple that you want. You can use primary key with the reference to the object in binary tree. Or you can use other columns that you use often. But be careful because when you modify your datas, indexes could be messed up.&lt;/p&gt;

&lt;p&gt;(part 9) still writing&lt;/p&gt;

&lt;h1 id=&quot;transaction&quot;&gt;Transaction&lt;/h1&gt;

&lt;p&gt;(part 9) still writing&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.notion.so/07c094190f9c4659a30a44e6d715080c&quot;&gt;비지니스 룰&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;single-table-inheritance&quot;&gt;Single Table Inheritance&lt;/h1&gt;

&lt;p&gt;두 개의 테이블이 같은 데이터 폼을 갖고 있지만, 서로 다른 기능을 갖고 있을 때&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.driftingruby.com/episodes/single-table-inheritance&quot;&gt;https://www.driftingruby.com/episodes/single-table-inheritance&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ex) emergency contact - 전화번호가 있어야 함, friends contact - 생일이 있어야 함&lt;/p&gt;</content><author><name>Seonkyu Kim(김선규)</name></author><category term="database" /><category term="reference" /><summary type="html">Database</summary></entry><entry><title type="html">Making queries</title><link href="http://localhost:4000/django/Making-queries/" rel="alternate" type="text/html" title="Making queries" /><published>2019-01-22T00:00:00+09:00</published><updated>2019-01-22T00:00:00+09:00</updated><id>http://localhost:4000/django/Making-queries</id><content type="html" xml:base="http://localhost:4000/django/Making-queries/">&lt;h1 id=&quot;making-queries&quot;&gt;Making queries&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;본 글은 작성 중 입니다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;너가 &lt;code class=&quot;highlighter-rouge&quot;&gt;data models&lt;/code&gt;를 만들고 나면, Django는 create, retrieve, update 그리고 delete object를 할 수 있는 database-abstraction API를 자동적으로 제공할 것이다. 이 문서는 이 API를 어떻게 사용하는지를 알려준다. 모든 다양한 model lookup options에 대한 자세한 내용은 &lt;code class=&quot;highlighter-rouge&quot;&gt;data model reference&lt;/code&gt;를 참조하여라.&lt;/p&gt;

&lt;p&gt;이 가이드를 설명하는 동안, 우리는 다음과 같이 Weblog application을 구성하는 models를 사용할 것이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Blog(models.Model):
	name = models.CharField(max_length=100)
	tagline = models.TextField()
	
	def __str__(self):
		return self.name

class Author(models.Model):
	name = models.CharField(max_length=200)
	email = models.EmailField()

	def __str__(self):
		return self.name

class Entry(models.Model):
	blog = models.ForeignKey(Blog, on_delete=models.CASCADE)
	headline = models.CharField(max_length=255)
	body_text = models.TextField()
	pub_date = models.DateField()
	mod_date = models.DateField()
	authors = models.ManyToManyField(Author)
	n_comments = models.IntegerField()
	n_pingbacks = models.IntegerField()
	rating = models.IntegerField()

	def __str__(self):
		return self.headline
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;creating-objects&quot;&gt;Creating objects&lt;/h1&gt;

&lt;p&gt;Python object의 database-table data를 나타내기 위해, Django는 직관적인 시스템을 사용한다: database class를 나타내는 model class, 그리고 그 class의 instance는 database table 안의 특정 기록들을 나타낸다.&lt;/p&gt;

&lt;p&gt;object를 생성하기 위해, model class의 keyword arguments를 사용하여 그것을 instantiate 한 뒤, database에 저장하기 위해 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;&lt;/strong&gt;를 호출해라.&lt;/p&gt;

&lt;p&gt;models가 &lt;strong&gt;mysite/blog/models.py&lt;/strong&gt; 파일 안에 있다고 가정하자. 예시는 다음과 같다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from blog.models import Blog
&amp;gt;&amp;gt;&amp;gt; b = Blog(name='Beatles Blog', tagline='All the latest Beatles news.')
&amp;gt;&amp;gt;&amp;gt; b.save()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 뒤에서 &lt;strong&gt;INSERT&lt;/strong&gt; SQL statement를 실행한다. Django는 너가 명시적으로 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save()를&lt;/code&gt;&lt;/strong&gt; 호출하기 전까지 database를 건드리지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;&lt;/strong&gt; method는 return 값이 없다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;See also&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;&lt;/strong&gt;는 여기에서 설명하지 않은 다수의 advanced option들이 있다. 모든 세부 사항을 위해서 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;&lt;/strong&gt; 문서를 참조하라&lt;/p&gt;

    &lt;p&gt;object를 생성하고 저장하는 것을 한 번에 하기 위해서는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;create()&lt;/code&gt;&lt;/strong&gt; method를 사용하여라.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;saving-changes-to-objects&quot;&gt;Saving changes to objects&lt;/h1&gt;

&lt;p&gt;databse 에 이미 있는 object의 변경 사항을 저장하기 위해서는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;&lt;/strong&gt;를 사용해라.&lt;/p&gt;

&lt;p&gt;주어진 &lt;strong&gt;Blog&lt;/strong&gt; instance &lt;strong&gt;b5&lt;/strong&gt;는 이미 database에 저장되어 있다. 이 예시는 그것의 이름을 바꾸고, database에 그것의 record를 update하는 것이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; b5.name = 'New name'
&amp;gt;&amp;gt;&amp;gt; b5.save()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이것은 뒤에서 &lt;strong&gt;UPDATE&lt;/strong&gt; SQL statement를 실행한다. Django는 너가 명시적으로 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;&lt;/strong&gt; 호출하기 전까지 database를 건드리지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;saving-foreignkey-and-manytomanyfield-fields&quot;&gt;Saving ForeignKey and ManyToManyField fields&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt; field를 update하는 것은 일반적인 field를 저장하는 것과 정확히 같은 방법으로 작동한다 - 단순히 옳은 타입의 object를 할당 해주는 것이다. 이 예시는 &lt;strong&gt;Entry&lt;/strong&gt; instance &lt;strong&gt;entry&lt;/strong&gt;의 &lt;strong&gt;blog&lt;/strong&gt; attribute를 update하는 것이다. &lt;strong&gt;Entry&lt;/strong&gt;와 &lt;strong&gt;Blog&lt;/strong&gt;의 적당한 instances들이 이미 database에 저장되어 있다고 가정하자(따라서 우리는 다음과 같이 그들을 retrieve 할 수 있다):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from blog.models import Blog, Entry
&amp;gt;&amp;gt;&amp;gt; entry = Entry.objects.get(pk=1)
&amp;gt;&amp;gt;&amp;gt; chees_blog = Blog.objects.get(name=&quot;Cheddar Talk&quot;)
&amp;gt;&amp;gt;&amp;gt; entry.blog = cheese_blog
&amp;gt;&amp;gt;&amp;gt; entry.save()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;를 updating하는 것은 약간 다르게 작동한다 - relation에 record를 추가하기 위해 field에 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;add()&lt;/code&gt;&lt;/strong&gt; method를 사용해라. 이 예시는 &lt;strong&gt;Author&lt;/strong&gt; instance &lt;strong&gt;joe&lt;/strong&gt;를 &lt;strong&gt;entry&lt;/strong&gt; object에 추가한 것이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from blog.models import Author
&amp;gt;&amp;gt;&amp;gt; joe = Author.objects.create(name=&quot;Joe&quot;)
&amp;gt;&amp;gt;&amp;gt; entry.authors.add(joe)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;에 많은 수의 record를 한 번에 저장하기 위해, 많은 arguments를 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;add()&lt;/code&gt;&lt;/strong&gt; 의 호출 안에 포함해라. 다음과 같다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; john = Author.objects.create(name=&quot;John&quot;)
&amp;gt;&amp;gt;&amp;gt; paul = Author.objects.create(name=&quot;Paul&quot;)
&amp;gt;&amp;gt;&amp;gt; george = Author.objects.create(name=&quot;George&quot;)
&amp;gt;&amp;gt;&amp;gt; ringo = Author.objects.create(name=&quot;Ringo&quot;)
&amp;gt;&amp;gt;&amp;gt; entry.authors.add(john, paul, george, ringo)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Django는 만약 너가 다른 종류의 object를 추가하거나 할당 할 때 error를 일으킬 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;retrieving-objects&quot;&gt;Retrieving objects&lt;/h1&gt;

&lt;p&gt;너의 database로부터 objects를 retrieve하기 위해, 너의 model class의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;를 통해 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 구성해라.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;은 너의 database의 objects의 모음을 나타낸다. 이것은 없거나 한 개일 수도 있고, 많은 &lt;em&gt;filter&lt;/em&gt;일 수도 있다. Filters는 주어진 parmeters에 따라서 query results를 줄여 나간다. SQL 용어로는, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QeurySet&lt;/code&gt;&lt;/strong&gt;은 &lt;strong&gt;SELECT&lt;/strong&gt; 명령어에 해당하고, filter은 제한하는 구절인 &lt;strong&gt;WHERE&lt;/strong&gt; 또는 &lt;strong&gt;LIMIT&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;너는 너의 model &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;를 사용함으로써 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 얻는다. 각각의 model은 적어도 한 개의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;를 갖고 있고, 이는 기본적으로 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;objects&lt;/code&gt;&lt;/strong&gt;라고 불리운다. 다음와 같이 model class를 통해 직접적으로 접근할 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Blog.objects
&amp;lt;django.db.models.manager.Manager object at ...&amp;gt;
&amp;gt;&amp;gt;&amp;gt; b = Blog(name='Foo', tagline='Bar')
&amp;gt;&amp;gt;&amp;gt; b.objects
Traceback:
	...
AttributeError: &quot;Manager isn't accessible via Blog instances.&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Managers&lt;/code&gt;&lt;/strong&gt;는 model class를 통해서만 접근할 수 있고 model instances를 통해서는 안된다. 이는 “table-level” operations와 “record-level” operations를 분리하기 위함이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;은 한 model에 대한 &lt;strong&gt;QuerySets&lt;/strong&gt;의 메인 소스이다. 예를 들어, &lt;strong&gt;Blog.objects.all()&lt;/strong&gt;은 database에서 모든 &lt;strong&gt;Blog&lt;/strong&gt; objects를 담고 있는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 반환한다.&lt;/p&gt;

&lt;h2 id=&quot;retrieving-all-objects&quot;&gt;Retrieving all objects&lt;/h2&gt;

&lt;p&gt;table로 부터 objects를 retrieve하는 가장 쉬운 방법은 모든 것들을 받는 것이다. 이를 하기 위해서 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;에 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;all()&lt;/code&gt;&lt;/strong&gt; method를 사용해라:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; all_entries = Entry.objects.all()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;all()&lt;/code&gt;&lt;/strong&gt; mothod는 database에 있는 모든 objects의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySets&lt;/code&gt;&lt;/strong&gt;을 반환한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;retrieving-specific-objects-with-filters&quot;&gt;Retrieving specific objects with filters&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;all()&lt;/code&gt;&lt;/strong&gt;에 의해 반환된 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;은 database table의 모든 objects를 묘사한다. 그러나 보통, 너는 완전한 objects의 집합에서 일부만 선택해야 할 필요가 있을 것이다.&lt;/p&gt;

&lt;p&gt;이러한 부분집합을 만들기 위해서, 너는 filter conditions를 추가하여 초기의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Queryset&lt;/code&gt;&lt;/strong&gt;을 수정한다. 다음은 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 refine하는 대표적인 두 가지 방법이다:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;filter(&lt;/strong&gt;kwargs)**&lt;/p&gt;

&lt;p&gt;주어진 lookup parameters와 match하는&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;exclude(&lt;/strong&gt;kwargs)**&lt;/p&gt;

&lt;p&gt;주어진 lookup parameters와 match하지 않는 objects를 포함하고 있는 새로운 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 반환한다.&lt;/p&gt;

&lt;p&gt;lookup parameters (위 함수의 정의에서 &lt;strong&gt;**kwargs&lt;/strong&gt;)는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Field lookups&lt;/code&gt; 아래에 기술된 포멧을 따라야 한다.&lt;/p&gt;

&lt;p&gt;예를 들어, 2006년의 blog entries의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 얻고 싶다면 다음과 같이 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/strong&gt;를 사용해라:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.filter(pub_date__year=2006)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;기본 manager class를 사용하면 이는 다음과 같다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.all().filter(pub_date__year=2006)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Chaining filters&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 refine한 결과는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt; 그 자신이기 때문에 연속적인 refinement을 함께 할 수 있다. 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(
...		headline__startswith='What'
...).exclude(
...		pub_date__gte=datetime.date.today()
...).filter(
...		pub_date__gte=datetime.date(2005, 1, 30)
...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 모든 database의 entries를 시작 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;으로 받고, filter를 추가하고, exclusion하고, 다른 filter를 추가했다. 최종 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;의 결과는 “What”으로 시작하는 headline과 현재 날짜와 2005년 1월 30일 사이에 출판된 모든 entries를 갖고 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Filtered QuerySets are unique&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;너가 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 refine할 때마다, 너는 이전의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;과 전혀 연결되지 않은 새로운 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 을 얻는다. 각각의 refinement는 저장되고, 사용되고, 다시 쓸 수 있는 분리되고 별개의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 생성한다.&lt;/p&gt;

&lt;p&gt;다음은 예시이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; q1 = Entry.objects.filter(headline__startswith=&quot;What&quot;)
&amp;gt;&amp;gt;&amp;gt; q2 = q1.exclude(pub_date__dte=datetime.date.today())
&amp;gt;&amp;gt;&amp;gt; q3 = q1.filter(pub_date__gte=datetime.date.today())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 세 가지 &lt;strong&gt;QuerySets&lt;/strong&gt;는 각각 별개이다. 첫 번째 것은 “What”으로 시작하는 headline을 갖고 있는 모든 entries를 포함하는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;이다. 두 번째 것은 첫 번째 것의 하위 집합으로, &lt;strong&gt;pub_date&lt;/strong&gt;가 오늘이거나 미래인 것들의 records를 제외하는 추가적인 기준을 갖고 있다. 세 번째 것은 첫 번째의 하위 집합으로, &lt;strong&gt;pub_date&lt;/strong&gt;가 오늘이거나 미래인 것들만 고르는 추가적인 기준을 갖고 있다. 초기 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;(&lt;strong&gt;q1&lt;/strong&gt;)은 refinement 과정에 영향을 받지 않는다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;QuerySets are lazy&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;QuerySets는 게으르다 - &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 생성하는 작업은 어떠한 database activity도 포함하지 않는다. 너는 매우 길게 filters를 쌓을 수 있지만, Django는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;가 &lt;em&gt;evaluated&lt;/em&gt; 되기 전까지 실제로 query를 실행하지 않는다. 다음 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; q = Entry.objects.filter(headline__startswith=&quot;What&quot;)
&amp;gt;&amp;gt;&amp;gt; q = q.filter(pub_date__lte=datetime.date.today())
&amp;gt;&amp;gt;&amp;gt; q = q.exclude(body_text__icontains=&quot;food&quot;)
&amp;gt;&amp;gt;&amp;gt; print(q)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 세 번의 database hit처럼 보이지만, 사실 이것은 마지막 line의 (print(q))에서 database를 단 한 번만 hit한다. 일반적으로, 너가 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;의 결과를 요구하지 않는 이상, 그것들은 database로 부터 도출되지 않을 것이다. 너가 그것을 할 때, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;은 database에 접근하여 &lt;em&gt;evaluated&lt;/em&gt;된다. 언제 evaluation이 일어나는지에 대한 자세한 디테일은 &lt;code class=&quot;highlighter-rouge&quot;&gt;When QuerySets are evalutated&lt;/code&gt;를 보아라.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;retrieving-a-single-object-with-get&quot;&gt;Retrieving a single object with get()&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/strong&gt;는 너에게 항상 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;을 줄 것이다, 단 하나의 object가 query에 해당할 지라도 - 이 경우에, 이는 하나의 요소를 갖고 있는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt;이 될 것이다.&lt;/p&gt;

&lt;p&gt;만약 너가 query에 해당하는 하나의 object가 있다는 것을 안다면, 그 object를 직접적으로 반환하는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;&lt;/strong&gt; mehtod를 사용해라:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; one_entry = Entry.objects.get(pk=1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너는 마치 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/strong&gt;처럼 어떠한 query expression과도 함께 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;&lt;/strong&gt;을 사용할 수 있다 - 다시 말하지만, &lt;code class=&quot;highlighter-rouge&quot;&gt;Field looups&lt;/code&gt; 아래를 참고해라.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;&lt;/strong&gt;을 사용하는 것과 &lt;strong&gt;[0]&lt;/strong&gt; 슬라이싱과 함께 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/strong&gt;를 사용하는 것에 차이가 있다는 점을 알고 있어라. 만약 query와 맞는 결과가 없다면, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;&lt;/strong&gt;은 &lt;strong&gt;DoesNotExist&lt;/strong&gt; exception을 일으킬 것이다. 이 exception은 query가 수행되고 있는 model class의 attribute이다 - 따라서 위의 코드에서 만약 primary key가 1인 &lt;strong&gt;Entry&lt;/strong&gt; object가 없다면, Django는 &lt;strong&gt;Entry.DoesNotExist&lt;/strong&gt;를 일으킬 것이다.&lt;/p&gt;

&lt;p&gt;비슷하게, Django는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;&lt;/strong&gt; query에 한 개 이상의 해당하는 것이 있을 경우 에러를 일으킬 것이다. 이 경우, 그것은 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MultipleObjectsReturned&lt;/code&gt;&lt;/strong&gt;를 일으킬 것이고, 이 역시 model class 자체의 attribute이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;other-queryset-methods&quot;&gt;Other QuerySet methods&lt;/h2&gt;

&lt;p&gt;너가 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;all()&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/strong&gt;, 그리고 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;exclude()&lt;/code&gt;&lt;/strong&gt;를 사용할 대부분의 경우는 너가 database로부터 objects를 찾아볼 필요가 있을 때이다. 그러나 이 외에도 많은 것이 있다; 다양한 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;&lt;/strong&gt; method의 전체 리스트를 보기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet API Reference&lt;/code&gt;를 보아라.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;limiting-querysets&quot;&gt;Limiting QuerySets&lt;/h2&gt;

&lt;p&gt;너의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet이&lt;/code&gt;&lt;/strong&gt; 특정 개수의 결과를 갖게 제한하고 싶다면 Python의 array-slicing syntax를 이용해라. 이는 SQL의 &lt;strong&gt;LIMIT&lt;/strong&gt; 과 &lt;strong&gt;OFFSET&lt;/strong&gt; clauses와 같다.&lt;/p&gt;

&lt;p&gt;예를 들어 다음은 첫 5개의 objects를 반환한다(&lt;strong&gt;LIMIT 5&lt;/strong&gt;):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.all()[:5]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음은 6번째 부터 10번째 objects를 반환한다(&lt;strong&gt;OFFSET 5 LIMIT 5&lt;/strong&gt;):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.all()[5:10]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Negative indexing(i.e. &lt;strong&gt;Entry.objects.all()[-1]&lt;/strong&gt;)은 지원되지 않는다.&lt;/p&gt;

&lt;p&gt;일반적으로, slicing QuerySet은 새로운 QuerySet을 반환한다 - 이것은 query를 evaluate하지 않는다. 예외는 너가 Python slice syntax에서 “step” parameter를 사용할 경우이다. 예를 들어, 이것은 첫 10개의 매 두 번째 objects를 반환하기 위해 query를 실행한다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.all()[:10:2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;sliced queryset에 filtering을 추가하거나 순서를 매기는 것은 그것이 어떻게 작동할지에 대한 모호성 때문에 금지된다.&lt;/p&gt;

&lt;p&gt;리스트가 아니라 하나의 단일 object를 얻고 싶다면(e.g. &lt;strong&gt;SELECT foo FROM bar LIMIT 1&lt;/strong&gt;), slice 대신에 간단한 index를 사용해라. 예를 들어, 이는 headline을 알파벳 순서로 정렬한 후, database의 첫 번째 &lt;strong&gt;Entry&lt;/strong&gt;를 반환할 것이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.order_by('headline')[0] 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이것은 대략 다음과 같다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.order_by('headline')[0:1].get()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러나, 만약 기준에 합당한 objects가 없다면 첫 번째 것은 &lt;strong&gt;IndexError&lt;/strong&gt;를 일으키는 반면, 두 번째 것은 &lt;strong&gt;DoesNotExist&lt;/strong&gt;를 일으킬 것이다. 자세한 사항은 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;&lt;/strong&gt;을 보아라.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;field-lookups&quot;&gt;Field lookups&lt;/h2&gt;

&lt;p&gt;Field lookups는 SQL &lt;strong&gt;WHERE&lt;/strong&gt; clause의 항목을 지정하는 방법이다. 그들은 &lt;strong&gt;QuerySet&lt;/strong&gt; method인 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;exclude()&lt;/code&gt;&lt;/strong&gt;, 그리고 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;&lt;/strong&gt;에 keyword arguments로 명시돼 있다.&lt;/p&gt;

&lt;p&gt;기본 lookups keyword arguments들은 &lt;strong&gt;field__lookuptype=value&lt;/strong&gt;와 같은 형식을 취한다. (두 개의 underscore이다). 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(pub_date__lte='2006-01-01')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;대략 다음과 같은 SQL로 바뀐다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM blog_entry WHERE pub_date &amp;lt;= '2006-01-01';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;How this is possible&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Python은 runtime에 names와 values가 evalutated되는 임의의 name-value arguments를 허용하는 함수를 정의 할 수 있다. 자세한 내용은 공식 Python 튜토리얼의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Keyword Arguments&lt;/code&gt;를 참조하여라.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;lookup에 명시된 field는 model field의 이름이어야 한다. 한 가지 예외가 있는데, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;의 경우, 너는 접미사로 &lt;strong&gt;_id&lt;/strong&gt;가 추가된 field name을 명시할 수 있다. 이 경우에 value parameter는 foreign model의 primary key의 raw value를 포함할 것을 기대된다. 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(blog_id=4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 너가 유효하지 않은 keyword argument를 넘겨준다면, lookup 함수는 &lt;strong&gt;TypeError&lt;/strong&gt;를 일으킬 것이다.&lt;/p&gt;

&lt;p&gt;datase API는 약 24개의 lookup type들을 소개한다; 완전한 reference는 &lt;code class=&quot;highlighter-rouge&quot;&gt;field lookup reference&lt;/code&gt;를 참조하여라. 무엇이 가능한지 잠깐 소개를 하기 위해 여기에는 너가 자주 사용하게 될 몇 가지를 소개하겠다:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;exact&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;'’exact’’ match이다. 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.get(headline__exact=&quot;Cat bites dog&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 다음과 같은 SQL lines이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT ... WHERE headline = 'Cat bites dog';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 너가 lookup type을 제공하지 않는다면 - 즉, 너의 keyword argument가 double underscore을 포함하지 않는다면 - lookup type은 &lt;strong&gt;exact&lt;/strong&gt;라고 가정된다.&lt;/p&gt;

&lt;p&gt;예를 들어, 다음 두 문장은 동일하다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Blog.objects.get(id__exact=14)   # Explicit form
&amp;gt;&amp;gt;&amp;gt; Blog.objects.get(id=14           # __exact is implied
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;exact&lt;/strong&gt; lookups는 일반적인 경우이므로, 이는 편의를 위한 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;iexact&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;case-insensitive match이다. 따라서 다음 query:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Blog.objects.get(name__iexact=&quot;beatles blog&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;는 “Beatles Blog”, “beatles blog”, 또는 심지어 “BeAtlES blOG”의 제목을 가진 Blog를 match한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;contains&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;case-sensitive한 포함 테스트이다. 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.get(haadline__contains='Lennon')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 대략 다음 SQL과 같다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT ... WHERE headline LIKE '%Lennon%';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 ‘Today Lennon honored’ 의 headline을 match하지만, ‘today lennon honored’는 match하지 않는다는 점을 주의해라.&lt;/p&gt;

&lt;p&gt;또한 case-insensitive 버전인 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;icontains&lt;/code&gt;&lt;/strong&gt;가 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;startswith&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;endswith&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;각각 Starts-with와 ends-with search이다. 또한 case-insensitive 버전인 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;istartswith&lt;/code&gt;&lt;/strong&gt;와 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;iendswith&lt;/code&gt;&lt;/strong&gt;가 있다.&lt;/p&gt;

&lt;p&gt;다시 말하지만, 이는 오직 표면만 다룬 것이다. 전체 reference는 &lt;code class=&quot;highlighter-rouge&quot;&gt;field lookup reference&lt;/code&gt;에서 볼 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;lookups-that-span-relationships&quot;&gt;Lookups that span relationships&lt;/h2&gt;

&lt;p&gt;Django는 뒤에서 자동으로 SQL &lt;strong&gt;JOIN&lt;/strong&gt;s를 다루면서, lookups에서 relatioships를 “follow”할 수 있는 강력하고 직관적인 방법을 제공한다. relationship을 확장하기 위해, 너가 원하는 field에 도달할 때까지, double underscore으로 분리하여, model 사이의 related fields의 이름을 사용해라.&lt;/p&gt;

&lt;p&gt;다음 예시는 &lt;strong&gt;Blog&lt;/strong&gt;의 &lt;strong&gt;name&lt;/strong&gt;이 &lt;strong&gt;‘Beatles Blog’&lt;/strong&gt;인 모든 &lt;strong&gt;Entry&lt;/strong&gt; objects를 받는다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(blog__name='Beatles Blog')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 확장은 너가 원하는 만큼 깊이 할 수 있다.&lt;/p&gt;

&lt;p&gt;이는 또한 뒤 방향으로도 진행 가능하다. “reverse” relationship을 참조하고 싶다면, 단지 model의 소문자 이름을 사용해라.&lt;/p&gt;

&lt;p&gt;다음 예시는 &lt;strong&gt;headline&lt;/strong&gt;이 &lt;strong&gt;‘Lennon’&lt;/strong&gt;을 포함하고 있는 &lt;strong&gt;Entry&lt;/strong&gt;가 적어도 하나 있는 모든 &lt;strong&gt;Blog&lt;/strong&gt; objects를 받는다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Blog.objects.filter(entry__headline__contains='Lennon')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 너가 multiple relationships를 가로질러 filtering하고 있고 중간 model이 filter 조건에 맞는 value를 갖고 있지 않다면, Django는 그것을 거기에 마치 유효하지만 비어있는(모든 values가 &lt;strong&gt;NULL&lt;/strong&gt;) object가 있다고 다룰 것이다. 즉, error가 발생하지 않을 것이라는 의미이다. 예를 들어, 다음 filter를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Blog.objects.filter(entry__authors__name='Lennon')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(만약, 연관된 &lt;strong&gt;Author&lt;/strong&gt; model이 있고), 만약 한 entry와 연관된 &lt;strong&gt;author&lt;/strong&gt;이 없다면, error를 일으키는 대신에 그것은 연관된 &lt;strong&gt;name&lt;/strong&gt; 또한 없다고 다뤄진다. 보통 이는 너가 원하는 것일 것이다. 헷갈리는 유일한 경우는 만약 너가 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;isnull&lt;/code&gt;&lt;/strong&gt;을 사용할 경우이다. 즉:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Blog.objects.filter(entry__authors__name__isnull=True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;은 &lt;strong&gt;author&lt;/strong&gt;에 비어있는 &lt;strong&gt;name&lt;/strong&gt;을 갖고 있는 &lt;strong&gt;Blog&lt;/strong&gt; objects 뿐만 아니라, &lt;strong&gt;entry&lt;/strong&gt;에 비어있는 &lt;strong&gt;author&lt;/strong&gt;을 갖고 있는 &lt;strong&gt;Blog&lt;/strong&gt; objects 또한 반환할 것이다. 만약 너가 후자를 원하지 않는다면 이렇게 써야 한다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Blog.objects.filter(entry__authors__isnull=False,
entry__authors__name__isnull=True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;related-objects&quot;&gt;Related objects&lt;/h1&gt;

&lt;p&gt;만약 너가 model에 relationship을 정의하고 싶다면(i.e. &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;, 또는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;), model의 instances는 related object에 접근할 수 있는 편리한 API를 갖고 있다.&lt;/p&gt;

&lt;p&gt;이 페이지의 맨 위에 있는 model들을 예시로 삼는다면, &lt;strong&gt;Entry&lt;/strong&gt; object인 &lt;strong&gt;e&lt;/strong&gt;는 그것과 연관된 &lt;strong&gt;Blog&lt;/strong&gt; obejct를 blog attribute를 통해서 얻을 수 있다: &lt;strong&gt;e.blog.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(배후에서 이 기능은 Python &lt;code class=&quot;highlighter-rouge&quot;&gt;descriptors&lt;/code&gt;에 의해 구현된다. 이 내용은 사용자에게 중요하지는 않지만 호기심을 유발하기 위해 여기에서 설명한다.)&lt;/p&gt;

&lt;p&gt;Django는 또한 API accessors를 relationship의 다른 쪽에 생성한다 - related model에서 그 relationship을 정의한 모델로의 link이다. 예를 들어 &lt;strong&gt;Blog&lt;/strong&gt; object &lt;strong&gt;b&lt;/strong&gt;는 모든 related &lt;strong&gt;Entry&lt;/strong&gt; objects의 리스트를 &lt;strong&gt;entry_set&lt;/strong&gt; attribute를 이용하여 접근할 수 있다:&lt;strong&gt;b.entry_set.all()&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;one-to-many-relationships&quot;&gt;One-to-many relationships&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Forward&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 model이 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;를 갖고 있다면, 그 model의 instances는 간단히 그 model의 attribute를 통하여 related (foreign) object에 접근할 수 있다.&lt;/p&gt;

&lt;p&gt;예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; e = Entry.objects.get(id=2)
&amp;gt;&amp;gt;&amp;gt; e.blog # Returns the related Blog object.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너는 foreign-key attribute를 통해 가져오고 설정할 수 있다. 너가 예상한 대로, foreign key의 변화는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;&lt;/strong&gt;를 호출하기 전까지 너의 database에 저장되지 않는다. 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; e = Entry.objects.get(id=2)
&amp;gt;&amp;gt;&amp;gt; e.blog = some_blog
&amp;gt;&amp;gt;&amp;gt; e.save()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt; field가 &lt;strong&gt;null=True&lt;/strong&gt; 설정을 갖고 있다면(i.e. 그것이 &lt;strong&gt;NULL&lt;/strong&gt; 값을 허락한다면), 너는 &lt;strong&gt;None&lt;/strong&gt;을 설정하여 relation을 제거할 수 있다. 예시이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; e = Entry.objects.get(id=2)
&amp;gt;&amp;gt;&amp;gt; e.blog = None
&amp;gt;&amp;gt;&amp;gt; e.save() # &quot;UPDATE blog_entry SET blog_id = NULL...;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;one-to-many relationships에서 forward access는 related object에 처음 접근할 때 cached된다. 같은 object instance에 있는 foreign key로의 후속 접근들은 cached된다. 예시이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; e = Entry.objects.get(id=2)
&amp;gt;&amp;gt;&amp;gt; print(e.blog) # Hits the database to retrieve the associated Blog.
&amp;gt;&amp;gt;&amp;gt; print(e.blog) # Doesn't hit the database; use cached version.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;**select_related() QuerySet**&lt;/code&gt; method 모든 one-to-many relationships의 cache를 미리 recursive하게 미리 채운다. 예시이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; e = Entry.objects.selected_related().get(id=2)
&amp;gt;&amp;gt;&amp;gt; print(e.blog) # Doesn't hit the database; uses cached version.
&amp;gt;&amp;gt;&amp;gt; print(e.blog) # Doesn't hit the database; uses cached version.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Following relationships “backward”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 model이 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;를 갖고 있다면, foreign-key model의 instances는 첫 번째 model(ForeignKey를 갖고 있는 앞의 model)의 모든 instances를 반환하는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;에 접근할 수 있다. 기본적으로, 이 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;의 이름은 &lt;strong&gt;F00_set&lt;/strong&gt;인데, &lt;strong&gt;F00&lt;/strong&gt;는 source model의 소문자 이름이다. 이 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;는 &lt;strong&gt;QuerySets&lt;/strong&gt;를 반환하는데, 이것은 위의 “Retrieving objects” 부문에 기술되어 있는 대로 filtered 되고 manipulated 될 수 있다.&lt;/p&gt;

&lt;p&gt;다음은 예시이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; b = Blog.objects.get(id=1)
&amp;gt;&amp;gt;&amp;gt; b.entry_set.all() # Returns all Entry objects related to Blog.

# b.entry_set is a Manager that returns QuerySets.
&amp;gt;&amp;gt;&amp;gt; b.entry_set.filter(headline__conatains='Lennon')
&amp;gt;&amp;gt;&amp;gt; b.entry_set.count()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;F00_set&lt;/strong&gt; 이름을 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt; 정의에 있는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_name&lt;/code&gt;&lt;/strong&gt; parameter를 설정함으로써 override할 수 있다. 예를 들어, 만약 &lt;strong&gt;Entry&lt;/strong&gt; model이 &lt;strong&gt;blog = ForeignKey(Blog, on_delete=models.CASCADE, related_name=’entries’)&lt;/strong&gt;로 바뀌었을 경우, 위의 코드는 다음과 같이 바뀐다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; b = Blog.objects.get(id=1)
&amp;gt;&amp;gt;&amp;gt; b.entries.all() # Returns all Entry objects related to Blog.

# b.entries is a Manager that returns QuerySets.
&amp;gt;&amp;gt;&amp;gt; b.entries.filter(headline__contains='Lennon')
&amp;gt;&amp;gt;&amp;gt; b.entries.count()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Using a custom reverse manager&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;기본적으로 reverse relations로 사용되는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RelatedManager&lt;/code&gt;&lt;/strong&gt;는 해당 model의 &lt;code class=&quot;highlighter-rouge&quot;&gt;default manager&lt;/code&gt;의 하위 class이다. 만약 너가 주어진 query에 대하여 다른 manager를 사용하고 싶다면 너는 다음과 같은 syntax를 사용하면 된다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Entry(models.Model):
	# ...
	objects = models.Manager() # Default Manager
	entries = EntryManager()   # Custom Manager

b = Blog.objects.get(id=1)
b.entry_set(manager='entries').all()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 &lt;strong&gt;EntryManager&lt;/strong&gt;의 해당 &lt;strong&gt;get_queryset()&lt;/strong&gt; method에서 기본 filtering을 수행하면 해당 filtering이 &lt;strong&gt;all()&lt;/strong&gt; 호출에 적용된다.&lt;/p&gt;

&lt;p&gt;물론, custom reverse manager를 명시하는 것은 너가 그것의 custom method의 사용도 가능하게 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;b.entry_set(manager='entries').is_published()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;</content><author><name>Seonkyu Kim(김선규)</name></author><category term="django reference" /><summary type="html">Making queries</summary></entry><entry><title type="html">Introduction to models</title><link href="http://localhost:4000/django/introduction-to-model/" rel="alternate" type="text/html" title="Introduction to models" /><published>2019-01-22T00:00:00+09:00</published><updated>2019-01-22T00:00:00+09:00</updated><id>http://localhost:4000/django/introduction-to-model</id><content type="html" xml:base="http://localhost:4000/django/introduction-to-model/">&lt;h1 id=&quot;introduction-to-models&quot;&gt;Introduction to models&lt;/h1&gt;

&lt;h1 id=&quot;models&quot;&gt;Models&lt;/h1&gt;

&lt;p&gt;model은 너의 데이터에 대한 하나의, 결정적인 정보이다. 그것은 필수적인 field들과 너가 저장하고 있는 데이터들의 행동을 결정한다. 일반적으로, 각각의 model은 하나의 database table로 mapping된다.&lt;/p&gt;

&lt;p&gt;기초 사항:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각각의 model은 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;django.db.models.Model&lt;/code&gt;&lt;/strong&gt;의 하위 python 클래스이다.&lt;/li&gt;
  &lt;li&gt;model 클래스의 각각의 attribute는 database field를 나타낸다.&lt;/li&gt;
  &lt;li&gt;이것들과 함께, Django는 너에게 자동으로 만들어진 database-access API를 제공한다; &lt;a href=&quot;https://www.notion.so/Making-queries-d1ee592133a24ef48fa9394d3276dedd&quot;&gt;Making queries&lt;/a&gt; 참고하라.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;quick-example&quot;&gt;Quick example&lt;/h1&gt;

&lt;p&gt;다음 예시는 &lt;strong&gt;first_name&lt;/strong&gt;과 &lt;strong&gt;last_name&lt;/strong&gt;을 갖고 있는 &lt;strong&gt;Person&lt;/strong&gt; model이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Person(models.Model):
	first_name = models.CharField(max_length=30)
	last_name = models.CharField(max_length=30)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;first_name&lt;/strong&gt;과 &lt;strong&gt;last_name&lt;/strong&gt;은 model의 &lt;code class=&quot;highlighter-rouge&quot;&gt;field&lt;/code&gt;이다. 각각의 field는 class attribute로 구체화되며, 각각의 attribute는 하나의 database column으로 mapping된다.&lt;/p&gt;

&lt;p&gt;위의 &lt;strong&gt;Person&lt;/strong&gt; model은 다음과 같은 database 테이블을 생성한다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE myapp_person (
	&quot;id&quot; serial NOT NULL PRIMARY KEY,
	&quot;first_name&quot; varchar(30) NOT NULL,
	&quot;last_name&quot; varchar(30) NOT NULL
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Some technical notes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;테이블의 이름인 &lt;strong&gt;myapp_person&lt;/strong&gt;은 몇 개의 model metadata로부터 자동적으로 파생되지만, override할 수 있다. 자세한 사항은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Table names&lt;/code&gt;를 참조하라.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;id&lt;/strong&gt; field는 자동적으로 추가되지만 이 역시 override할 수 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Automatic primary key fields&lt;/code&gt;를 참조하라.&lt;/li&gt;
  &lt;li&gt;위 예시의 &lt;strong&gt;CREATE TABLE&lt;/strong&gt;은 PostgreSQL 문법으로 쓰여 있는데, Django가 너의 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings file&lt;/code&gt;에 명시된 database backend 맞춤 SQL 을 사용한다는 것을 알고 있어라.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;using-models&quot;&gt;Using models&lt;/h1&gt;

&lt;p&gt;너가 너의 models를 정의한 후, 너는 Django에게 앞으로 그 models를 사용할 것이라고 알려야 한다. 이를 위해 너의 settings file을 수정해야 하는데, 파일 안의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;INSTALLED_APPS&lt;/code&gt;&lt;/strong&gt;에 너의 &lt;strong&gt;models.py&lt;/strong&gt;을 포함하고 있는 module이름을 추가해라.&lt;/p&gt;

&lt;p&gt;예를 들어, 만약 너의 application의 models가 &lt;strong&gt;myapp.models&lt;/strong&gt; module 안에 있다면 (application을 위해 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;manage.py startapp&lt;/code&gt;&lt;/strong&gt; 명령어를 사용하여 만든 package structure 안에 있다면), &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;INSTALLED_APPS&lt;/code&gt;&lt;/strong&gt;는 다음과 같다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSTALLED_APPS = [
	#...
	'myapp',
	#...
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너가 새로운 app들을 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;INSTALLED_APPS&lt;/code&gt;&lt;/strong&gt;에 추가할 때, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;manage.py makemigrations&lt;/code&gt;&lt;/strong&gt;를 이용하여 부분적으로 migrations를 만든 후, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;manage.py migrate&lt;/code&gt;&lt;/strong&gt;를 꼭 실행하도록 하라&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;fields&quot;&gt;Fields&lt;/h1&gt;

&lt;p&gt;model에서 가장 중요한 부분이다 - 그리고 model에서 요구되는 유일한 부분이다 - 그것은 바로 정의된 database field 들의 리스트를 아는 것이다. Fields는 class attirbute에 의해 명시된다. &lt;strong&gt;clean, save&lt;/strong&gt; 또는 &lt;strong&gt;delete&lt;/strong&gt;와 같은 &lt;code class=&quot;highlighter-rouge&quot;&gt;models API&lt;/code&gt;와 field 이름이 충돌하지 않도록 주의하라&lt;/p&gt;

&lt;p&gt;예시 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Musician(models.Model):
	first_name = models.CharField(max_length=50)
	last_name = models.CharField(max_length=50)
	instrument = models.CharField(max_length=100)

class Album(models.Model):
	artist = models.ForeignKey(Musician, on_delete=models.CASCADE)
	name = models.CharField(max_length=100)
	release_date = models.DateField()
	num_starts = models.IntegerField()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;field-types&quot;&gt;Field types&lt;/h2&gt;

&lt;p&gt;너의 model 안의 각각의 field는 적당한 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Field&lt;/code&gt;&lt;/strong&gt; class안의 instance이어야 한다. Django는 몇 가지를 결정하기 위해 field class types를 사용한다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Column type은 어떤 종류의 database를 저장할지 알려 준다.(e.g.&lt;strong&gt;INTEGER, VARCHAR, TEXT&lt;/strong&gt;)&lt;/li&gt;
  &lt;li&gt;Default HTML &lt;code class=&quot;highlighter-rouge&quot;&gt;widget&lt;/code&gt;은 form field들을 rendering할 때 사용된다.(e.g. **&lt;input type=&quot;text&quot; /&gt;&lt;select&gt;**)&lt;/select&gt;&lt;/li&gt;
  &lt;li&gt;Minimal validation requirements는 Django의 admin과 자동으로 생성된 form에서 사용된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Django는 수십 개의 내장 field-type들을 갖고 있다; 너는 전체 목록을 model field reference에서 확인할 수 있다. 만약 Django의 내장 field가 제 기능을 못 할 경우, 너는 너만의 field를 쉽게 작성할 수 있다; &lt;code class=&quot;highlighter-rouge&quot;&gt;Writing custom model fields&lt;/code&gt;를 참조해라.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;field-options&quot;&gt;Field options&lt;/h2&gt;

&lt;p&gt;각각의 field는 field-specific arguments를 갖고 있다(&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reference&lt;/span&gt;&lt;/code&gt;에 작성되어 있다). 예를 들어, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CharField&lt;/code&gt;&lt;/strong&gt;(그리고 그것의 subclasses)는 데이터를 저장하는데 사용되는 &lt;strong&gt;VARCHAR&lt;/strong&gt; database field의 사이즈를 명시해주는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;max_length&lt;/code&gt;&lt;/strong&gt; 인자를 필요로 한다.&lt;/p&gt;

&lt;p&gt;또한 모든 field type에 적용되는 공통 argument들이 있다. 모두 optional이다. 이들은 &lt;code class=&quot;highlighter-rouge&quot;&gt;reference&lt;/code&gt;에서 전부 설명되어 있지만, 여기에서는 가장 많이 사용하는 몇 가지만 요약을 하겠다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 &lt;strong&gt;True&lt;/strong&gt;라면, Django는 database에 빈 값인 &lt;strong&gt;NULL&lt;/strong&gt;값을 저장한다. 초기 값은 &lt;strong&gt;False&lt;/strong&gt;다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;blank&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 True라면, field는 빈 칸이 있을 수 있다. 초기 값은 False이다.&lt;/p&gt;

&lt;p&gt;이는 null과 다르다. null은 database-related인 반면, blank는 validation-related이다. 만약 field에서 blank=True라면, form validation은 entry의 비어있는 값을 허락한다. 만약 field에서 blank=False라면, 그 field의 값은 항상 요구된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;choices&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2-tuples로 구성된 iteralbe(e.g. list or tuple)은 이 field의 choices로 사용할 수 있다. 만약 이것이 주어지면, default form widget은 기본적인 text field가 아니라 select box가 될 것이고 주어진 choices로 선택권이 제한될 것이다.&lt;/p&gt;

&lt;p&gt;choices list는 다음과 같다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;YEAR_IN_SCHOOL_CHOICES = (
	('FR', 'Freshman'),
	('SO', 'Sophomore'),
	('JR', 'Junior'),
	('SR', 'Senior'),
	('GR', 'Graduate'),
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;각각의 tuple의 첫 번째 요소는 database에 저장되는 값이다. 두 번째 요소는 field의 form widget에 나타나는 값(display value)이다.&lt;/p&gt;

&lt;p&gt;model instance가 주어졌을 때, &lt;strong&gt;choices&lt;/strong&gt;를 갖고 있는 field에서 display value는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get_F00_display()&lt;/code&gt;&lt;/strong&gt; method를 이용하여 접근할 수 있다. 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Person(models.Model):
	SHIRT_SIZES = (
		('S', 'Small'),
		('M', 'Medium'),
		('L', 'Large'),
	)
	name = models.CharField(max_length=60)
	shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)

&amp;gt;&amp;gt;&amp;gt; p = Person(name=&quot;Fred Flintsone&quot;, shirt_size='L')
&amp;gt;&amp;gt;&amp;gt; p.save()
&amp;gt;&amp;gt;&amp;gt; p.shirt_size
'L'
&amp;gt;&amp;gt;&amp;gt; p.get_shirt_size_display()
'Large'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;field의 초기 값이다. 이는 한 값이나 callable object가 될 수 있다. 만약 callable하다면 이것은 새로운 object가 생성될 때마다 실행될 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;help_text&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;form widget에 표시될 추가적인 “help” text이다. 이는 field가 form에서 사용되지 않더라도 documentation하는데 유용하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;primary_key&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 &lt;strong&gt;True&lt;/strong&gt;라면, 이 field는 model의 primary key가 된다.&lt;/p&gt;

&lt;p&gt;만약 너가 model에서 어떤 field에도 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;primary_key=True&lt;/code&gt;&lt;/strong&gt;로 설정해 두지 않았다면, Django는 자동적으로 primary key로 사용할 &lt;code class=&quot;highlighter-rouge&quot;&gt;**IntegerField**&lt;/code&gt;를 추가하기 때문에 너가 default primary-key를 override하고 싶지 않은 이상 어떤 field에 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;primary_key=True&lt;/code&gt;&lt;/strong&gt;를 설정할 필요없다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Automatic primary key fields&lt;/code&gt;에 더 자세히 기술되어 있다.&lt;/p&gt;

&lt;p&gt;primary key field는 읽을 수만 있다. 만약 너가 기존 object의 primary key 값을 변경한다면, 기존 object옆에 새로운 object가 생성될 것이다. 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Fruit(models.Model):
	name = models.CharField(max_length=100, primary_key=True)

&amp;gt;&amp;gt;&amp;gt; fruit = Fruit.objects.create(name='Apple')
&amp;gt;&amp;gt;&amp;gt; fruit.name = 'Pear'
&amp;gt;&amp;gt;&amp;gt; fruit.save()
&amp;gt;&amp;gt;&amp;gt; Fruit.objects.values_list('name', flat=True)
&amp;lt;QuerySet ['Apple', 'Pear']&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unique&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 True라면, 이 field는 table 전체에서 유일해야 한다.&lt;/p&gt;

&lt;p&gt;다시 한 번 말하지만, 이들은 모두 공통된 field option들에 대한 짧은 설명이다. 자세한 내용은 &lt;code class=&quot;highlighter-rouge&quot;&gt;common model field option reference&lt;/code&gt;에 기술되어 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;automatic-primary-key-fields&quot;&gt;Automatic primary key fields&lt;/h2&gt;

&lt;p&gt;초기 값으로, Django는 각각의 model에 다음과 같은 field를 생성한다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id = models.AutoField(primary_key=True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 auto-incrementing primary key이다.&lt;/p&gt;

&lt;p&gt;만약 너가 custom primary key를 명시하고 싶다면, 너의 field들 중 하나에 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;primary_key=True&lt;/code&gt;&lt;/strong&gt;를 명시하여라. 만약 명시적으로 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Field.primary_key&lt;/code&gt;&lt;/strong&gt;를 설정 했다면, Django는 자동적으로 생성된 &lt;strong&gt;id&lt;/strong&gt; column을 추가하지 않을 것이다.&lt;/p&gt;

&lt;p&gt;각각의 model은 오직 하나의 field만이 primary_key=True를 갖고 있어야 한다(명시적으로 추가 되었든지 아니면 자동적으로 추가 되었든지).&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;verbose-field-names&quot;&gt;Verbose field names&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;와 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;를 제외하고, 각각의 field type들은 선택적인 첫 번째 위치의 argument들을 갖는다 - 바로 verbose name이다. 만약 verbose name이 주어지지 않았다면, Django는 자동적으로 field의 attribute name에 있는 underscores를 space로 바꾸어 verbose name을 생성한다.&lt;/p&gt;

&lt;p&gt;이 예시에서 verbose name은 “&lt;strong&gt;person’s first name&lt;/strong&gt;“이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;first_name = models.CharField(&quot;person's first name&quot;, max_length=30)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 예시에서 verbose name은 “&lt;strong&gt;first name&lt;/strong&gt;“이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;first_name = models.CharField(max_length=30)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;와 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;는 첫 번째 argument로 model class가 필요로 하기 때문에 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;verbose_name&lt;/code&gt;&lt;/strong&gt; keyword argument를 사용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;poll = models.ForeignKey(
	Poll,
	on_delete=models.CASCADE,
	verbose_name=&quot;the related poll&quot;,
)
sites = models.ManyToManyField(Site, verbose_name=&quot;list of sites&quot;)
place = models.OneToOneField(
	Place,
	on_delete=models.CASCADE,
	verbose_name=&quot;related place&quot;,
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;관습적으로 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;verbose_name&lt;/code&gt;&lt;/strong&gt;의 첫 글자는 대문자를 쓰지 않는다. Django가 자동적으로 첫 번째 글자를 대문자로 바꾸어주기 때문이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;relationships&quot;&gt;Relationships&lt;/h2&gt;

&lt;p&gt;명확하게, relational database의 강점은 table간에 relating이 되어있다는 점이다. Django는 가장 많이 사용되는 세 가지 database relationship을 정의해준다: many-to-one, many-to-many 그리고 one-to-one이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Many-to-one relationships&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;many-to-one relationship을 정의하기 위해, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;django.db.models.ForeignKey&lt;/code&gt;&lt;/strong&gt;를 사용해라. 너는 이것을 다른 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Field&lt;/code&gt;&lt;/strong&gt; type처럼 사용하면 된다: 너의 model에 class attribute처럼 추가하여라.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;는 지정된 위치의 argument를 요구한다: 모델과 relate된 class를 지정하는 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어, &lt;strong&gt;Car&lt;/strong&gt; model이 &lt;strong&gt;Manufacturer&lt;/strong&gt;을 갖고 있다면 - 즉, &lt;strong&gt;Manufacturer&lt;/strong&gt;은 다양한 cars를 만들지만 각각의 &lt;strong&gt;Car&lt;/strong&gt;는 단 하나의 &lt;strong&gt;Manufacturer&lt;/strong&gt;를 갖고 있다 - 다음과 같은 정의를 써라:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Manufacturer(models.Model):
	# ...
	pass

class Car(models.Model):
	manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)
	# ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너는 또한 &lt;code class=&quot;highlighter-rouge&quot;&gt;recursive relationship&lt;/code&gt;(자기 자신에게 many-to-one relationship을 갖고 있는 object)을 만들 수 있고 &lt;code class=&quot;highlighter-rouge&quot;&gt;아직 정의되지 않은 model에게 relationship&lt;/code&gt;을 만들 수 있다; 자세한 사항은 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reference&lt;/span&gt;&lt;/code&gt;를 참고하라.&lt;/p&gt;

&lt;p&gt;필수적인 것은 아니지만, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey field&lt;/code&gt;&lt;/strong&gt;의 이름(위의 예에서는 &lt;strong&gt;manufacturer&lt;/strong&gt;)은 소문자의 model 이름을 사용하는 것이 좋다. 물론, 너는 너가 원하는 대로 field 이름을 정해도 된다. 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Car(models.Model):
	company_that_makes_it = models.ForeignKey(
		Manufacturer,
		on_delete=models.CASCADE,
	)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;See also&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt; field는 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;references&lt;/span&gt;&lt;/code&gt;에 설명되어 있는 다른 arguements도 사용할 수 있다. 이 option들은 relationship이 어떻게 작동할지 규정한다; 모두 optional이다.&lt;/p&gt;

    &lt;p&gt;backward-related objects에 접근하는 방법에 대해서는 Following relationships backward example을 참고하라.&lt;/p&gt;

    &lt;p&gt;sample code를 보고 싶다면 Many-to-one relationship model example을 참고하라.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Many-to-many relationships&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Many-to-many relationships를 정의하기 위해, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;를 사용해라. 너는 이것을 다른 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Field&lt;/code&gt;&lt;/strong&gt; type처럼 사용하면 된다: 너의 model에 class attribute처럼 추가하여라.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;는 지정된 위치의 argument를 요구한다: relate할 class를 지정하는 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어, &lt;strong&gt;Pizza&lt;/strong&gt; 가 다양한 &lt;strong&gt;Topping&lt;/strong&gt; objects를 갖고 있다면 - 즉, 한 &lt;strong&gt;Topping&lt;/strong&gt;이 다양한 pizzas에 있을 수 있고 각각의 &lt;strong&gt;Pizza&lt;/strong&gt;는 다양한 toppings를 가질 수 있다 - 다음과 같이 이를 나타내면 된다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Topping(models.Model):
	# ...
	pass

class Pizza(models.Model):
	# ...
	toppings = models.ManyToManyField(Topping)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;와 마찬가지로, 너는 &lt;code class=&quot;highlighter-rouge&quot;&gt;recursive relationship&lt;/code&gt;(자기 자신에게 many-to-many relationship을 갖고 있는 object)을 만들 수 있고 &lt;code class=&quot;highlighter-rouge&quot;&gt;아직 정의되지 않은 model에게 relationship&lt;/code&gt;을 만들 수 있다.&lt;/p&gt;

&lt;p&gt;필수적인 것은 아니지만, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;의 이름(위 예에서는 &lt;strong&gt;toppings&lt;/strong&gt;)을 related model objects를 묘사하고 있는 복수형으로 하는 것이 좋다.&lt;/p&gt;

&lt;p&gt;어떤 model이 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;를 갖고 있는지는 중요하지 않지만, 너는 두 쪽 모두가 아니라 한 쪽에만 이것을 설정해야 한다.&lt;/p&gt;

&lt;p&gt;일반적으로, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt; instance는 form에서 수정되어야 하는 object에 있어야 한다. 위의 예에서는 &lt;strong&gt;toppings&lt;/strong&gt;는 &lt;strong&gt;Pizza&lt;/strong&gt;에 있는데(&lt;strong&gt;Topping&lt;/strong&gt;이 많은 &lt;strong&gt;pizzas &lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;를 갖고 있는 것이 아니다) 그 이유는 pizza가 많은 topping들이 갖고 있다고 생각하는 것이 topping이 많은 pizza들 위에 있다고 생각하는 것보다 자연스럽기 때문이다. 위에서는 이와 같이 설정되어 있으며, Pizza는 사용자들이 topppings들을 선택할 수 있게 해준다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;See also&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;전체 예시를 보기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Many-to-many relationship model example&lt;/code&gt;을 참조하라.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt; field는 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;references&lt;/span&gt;&lt;/code&gt;에 설명되어 있는 다른 arguements도 사용할 수 있다. 이 option들은 relationship이 어떻게 작동할지 규정한다; 모두 optional이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Extra fields on many-to-many relationships&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;pizza와 topping과 같은 단순한 many-to-many relationship을 다루고 있다면, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;가 너가 필요한 전부이다. 하지만, 때때로 너는 relationship이 있는 두 models간의 데이터들을 연결지어야 한다.&lt;/p&gt;

&lt;p&gt;예를 들어 musicians이 속해있는 musical group을 추적하는 경우를 생각해보자. 여기에는 person과 그들이 멤버로서 속해있는 group들 간의 many-to-many relationship이 있고, 너는 이 관계를 나타내기 위해 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;를 사용할 수 있다. 그러나, 너가 얻고 싶어하는 membership과 관련된 세부 사항들, 예를 들어 person들이 group에 들어간 날짜 등이 많이 있다.&lt;/p&gt;

&lt;p&gt;이러한 상황들에서, Django에서 너는 many-to-many relationship을 관리하는 model을 명시할 수 있다. 또한 너는 이 intermidate model에 추가적인 field들을 넣을 수 있다. intermediary 역할을 할 model을 알려주는  &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;through&lt;/code&gt;&lt;/strong&gt; argument를 이용하여 intermediate model은 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;와 연결될 수 있다. 우리의 musician 예시는 다음 코드와 같이 쓸 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Person(models.Model):
	name = models.CharField(max_length=128)
	
	def __str__(self):
		return self.name

class Group(models.Model):
	name = models.CharField(max_length=128)
	members = models.ManyToManyField(Person, through='Membership')
	
	def __str__(self):
		return self.name

class Membership(models.Model):
	person = models.ForeignKey(Person, on_delete=models.CASCADE)
	group = models.ForeignKey(Group, on_delete=models.CASCADE)
	date_joined = models.DateField()
	invite_reason = models.CharField(max_length=64)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너가 intermediary model을 만들 때, 너는 many-to-many relationship에 포함될 model들에게 foreign key를 명시적으로 지정해주어야 한다. 이 명시적 선언은 두 model들이 어떻게 relate되는지 정의한다.&lt;/p&gt;

&lt;p&gt;다음은 intermediate model에서 몇 가지 제약 사항이다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;너의 intermediate model은 source model(우리의 예에서는 &lt;strong&gt;Group&lt;/strong&gt;)로 향하는 foreign key는 단 하나만 갖고 있어야 한거나, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField.through_fields&lt;/code&gt;&lt;/strong&gt;를 사용하여 Django가 relationship을 위해 사용해야 하는 foreign key를 명시적으로 지정해야 한다. 만약 한 개 이상의 foreign key를 갖고 있거나 through_fields가 명시되어 있지 않으면 validation error가 발생할 것이다. 비슷한 제약은 target model(우리의 예에서는 &lt;strong&gt;Person&lt;/strong&gt;)에서도 적용된다.&lt;/li&gt;
  &lt;li&gt;intermediary model을 이용하여 자기 자신에게 many-to-many relationship을 갖고 있는 model에 대해서는, 같은 model로 두 개의 foreign key가 있을 수 있다. 하지만 그들은 many-to-many relationship에서 서로 다른 측면에 있는 것으로 간주된다. 만약 두 개 이상의 foreign key가 있다면, 너는 역시 &lt;strong&gt;through_fields&lt;/strong&gt;를 위와 같이 명시해 주어야 validation error가 발생하지 않을 것이다.&lt;/li&gt;
  &lt;li&gt;intermediary model을 이용하여 자기 자신에게 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;many-to-many relationship&lt;/code&gt;&lt;/strong&gt;을 정의할 때, 너는 &lt;code class=&quot;highlighter-rouge&quot;&gt;symmetrical=False&lt;/code&gt; 를 사용해야 한다(model field reference를 참조하라).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 너의 intermediatry model(우리의 경우 &lt;strong&gt;Membership&lt;/strong&gt;)을 이용하기 위한 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt; 준비 작업을 마쳤고, 너는 many-to-many relationship을 사용할 준비가 되었다. 너는 이것을 intermediate model의 instances를 만들어 사용할 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; ringo = Person.objects.create(name=&quot;Ringo Starr&quot;)
&amp;gt;&amp;gt;&amp;gt; paul = Person.objects.create(name=&quot;Paul McCartney&quot;)
&amp;gt;&amp;gt;&amp;gt; beatles = Group.objects.create(name=&quot;The Beatles&quot;)
&amp;gt;&amp;gt;&amp;gt; m1 = Membership(person=ringo, group=beatles,
...			date_joined=date(1962, 8, 16),
...	 	 	invite_reason=&quot;Needed a new drummer.&quot;)
&amp;gt;&amp;gt;&amp;gt; m1.save()
&amp;gt;&amp;gt;&amp;gt; beatles.members.all()
&amp;lt;QuerySet [&amp;lt;Person: ringo Starr&amp;gt;]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; ringo.group_set.all()
&amp;lt;QuerySet [&amp;lt;Group: The Beatles&amp;gt;]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; m2 = Membership.objects.create(person=paul, group=beatles,
...			date_joined=date(1960, 8, 1),
...			invite_reason=&quot;Wanted to form a band.&quot;)
&amp;gt;&amp;gt;&amp;gt; beatles.memebers.all()
&amp;lt;QuerySet [&amp;lt;Person: Ringo starr&amp;gt;, &amp;lt;Person: Paul McCartney&amp;gt;]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;보통의 many-to-many field과는 다르게, 너는 &lt;strong&gt;add()&lt;/strong&gt;, &lt;strong&gt;create()&lt;/strong&gt;, 또는 &lt;strong&gt;set()&lt;/strong&gt; 을 relationship을 만들기 위해 사용할 수 없다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; # The following statements will not work
&amp;gt;&amp;gt;&amp;gt; beatles.members.add(john)
&amp;gt;&amp;gt;&amp;gt; beatles.members.create(name=&quot;George Harrison&quot;)
&amp;gt;&amp;gt;&amp;gt; beatles.members.set([john, paul, ringo, george])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;왜 그럴까? 너는 단순히 &lt;strong&gt;Person&lt;/strong&gt;과 &lt;strong&gt;Group&lt;/strong&gt;사이의 relationship을 만들 수 없다 - 너는 &lt;strong&gt;Membership&lt;/strong&gt; model이 필요로 하는 모든 세부 사항들을 명시해 주어야 한다. 단순히 &lt;strong&gt;add&lt;/strong&gt;, &lt;strong&gt;create&lt;/strong&gt; 그리고 assignment call으로는 이러한 추가적인 세부 사항들을 알려줄 방법이 없다. 결과적으로, 이들은 intermediate model을 이용하는 many-to-many relationship에 사용 불가능하다. 이런 종류의 relationship을 만드는 유일한 방법은 intermeidate model의 instance들을 생성하는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;remove()&lt;/code&gt;&lt;/strong&gt; method도 비슷한 이유로 사용 불가능하다. 예를 들어, 만약 intermediate model을 사용하여 정의한 custom들이 &lt;strong&gt;(model1, model2)&lt;/strong&gt;의 유일성을 보장하지 않는다면, &lt;strong&gt;remove()&lt;/strong&gt; 호출은 어떤 어떤 intermediate model의 instance를 삭제해야 하는지 충분한 정보를 제공하지 않는다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Membership.objects.create(person=ringo, group=beatles,
...			date_joined=date(1968, 9, 4),
...			invite_reason=&quot;You've been gone for a month and we miss you.&quot;)
&amp;gt;&amp;gt;&amp;gt; beatles.members.all()
&amp;lt;QuerySet [&amp;lt;Person: Ringo Starr&amp;gt;, &amp;lt;Person: Paul McCartney&amp;gt;, 
&amp;lt;Person: Ringo Starr&amp;gt;]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; # This will not work because it cannot tell which membership to remove
&amp;gt;&amp;gt;&amp;gt; beatles.members.remove(ringo)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러나, &lt;strong&gt;clear()&lt;/strong&gt; method는 모든 many-to-many relationships의 instance들을 삭제하기 위해 사용할 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; # Beatles have broken up
&amp;gt;&amp;gt;&amp;gt; beatles.members.clear()
&amp;gt;&amp;gt;&amp;gt; # Note that this deletes the intermediate model instances
&amp;gt;&amp;gt;&amp;gt; Membership.objects.all()
&amp;lt;QuerySet []&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일단 너가 너의 intermediate model의 instance를 생성하여 many-to-many relationship을 형성했다면, 너는 queries를 볼 수 있다. 평범한 many-to-many relationship과 마찬가지로, 너는 many-to-many로 연결된 model들의 attribute들을 이용하여 query할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Find all the groups with a member whose name starts with 'Paul'
&amp;gt;&amp;gt;&amp;gt; Group.objects.filter(members__name__startswith='Paul')
&amp;lt;QuerySet [&amp;lt;Group: The Beatles&amp;gt;]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너는 또한 intermediate model들을 attributes들을 이용하여 query 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Find all the members of the Beatles that joined after 1 Jan 1961
&amp;gt;&amp;gt;&amp;gt; Person.objects.filter(
...			group__name='The Beatles',
...			membership__date_joined__gt=date(1961,1,1))
&amp;lt;QuerySet [&amp;lt;Person: Ringo Starr]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 너가 membership의 정보들에 접근할 필요가 있으면 너는 &lt;strong&gt;Membership&lt;/strong&gt; model을 직접적으로 querying함으로써 할 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; ringos_membership = Membership.objects.get(group=beatles, person=ringo)
&amp;gt;&amp;gt;&amp;gt; ringos_membership.date_joined
datetime.date(1962, 8, 16)
&amp;gt;&amp;gt;&amp;gt; ringos_membership.invite_reason
'Needed a new drummer.'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;같은 정보에 접근할 수 있는 또 다른 방법은 &lt;strong&gt;Person&lt;/strong&gt; object로부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;many-to-many reverse relationship&lt;/code&gt;을 querying하는 것이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; ringos_membership = ringo.membership_set.get(group=beatles)
&amp;gt;&amp;gt;&amp;gt; ringos_membership.date_joined
datetime.date(1962, 8, 16)
&amp;gt;&amp;gt;&amp;gt; ringos_membership.invite_reason
'Needed a new drummer.'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;One-to-one relationships&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;one-to-one relationship을 정의하기 위해, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;를 사용해라. 너는 어느 다른 &lt;strong&gt;Field&lt;/strong&gt; type처럼 이용하면 된다: 너의 model의 class attribute로 추가해라.&lt;/p&gt;

&lt;p&gt;이것은 한 object가 다른 object를 “extends” 하고 있을 때 그 object의 primary key에서 가장 유용하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;는 지정된 위치의 argument를 요구한다: 모델과 relate된 class를 지정하는 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어, 만약 너가 “places”라는 database를 만들고 있다면, 너는 address, phone number 등과 같은 평범한 것들을 데이터 베이스에 포함할 것이다. 그리고 나서, 너가 그 place들 위에 restaurant들의 데이터 베이스를 세우고 싶다면, &lt;strong&gt;Restaurant&lt;/strong&gt; model에 그 fields들을 복제하는 것 대신에, &lt;strong&gt;Restaurant&lt;/strong&gt;가 &lt;strong&gt;Place&lt;/strong&gt;로 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;를 갖게 만들어 주면 된다(왜냐하면 reataurant “is a” place이기 때문이다; 사실, 이것을 다루기 위해 전형적으로 inheritance를 사용하는데, 이것은 암묵적으로 one-to-one relation을 갖는다).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt; 와 함께 &lt;code class=&quot;highlighter-rouge&quot;&gt;recursive relationship&lt;/code&gt;은 정의될 수 있고 &lt;code class=&quot;highlighter-rouge&quot;&gt;references to as-yet undefined model&lt;/code&gt;도 만들어 질 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;See also&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;전체 예시를 보기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;One-to-one relationship model example&lt;/code&gt;을 참고하라.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;는 또한 optional &lt;code class=&quot;highlighter-rouge&quot;&gt;**parent_link**&lt;/code&gt; argument를 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt; class들은 자동적으로 model의 primary key가 되곤 했다. 이는 더 이상 사실이 아니다(너가 직접 &lt;code class=&quot;highlighter-rouge&quot;&gt;**primary_key**&lt;/code&gt; argument들을 넘겨주어도 말이다). 그러므로, 이제 하나의 model에서 OneToOneField type의 다양한 field를 갖는 것이 가능하다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;models-across-files&quot;&gt;Models across files&lt;/h2&gt;

&lt;p&gt;한 model에서 다른 app에 있는 model로 relate을 하는 것은 완벽히 괜찮다. 이를 하기 위해서, 너의 모델이 정의되어 있는 곳 파일 가장 위에 related model을 import해야 한다. 이후, 필요한 곳 어디든지 그 다른 model class를 참조하면 된다. 예를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models
from geography.models import ZipCode

class Restaurant(models.Model):
	# ...
	zipe_code = models.ForeignKey(
		ZipCode,
		on_delete=models.SET_NULL,
		blank=True,
		null=True,
	)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;field-name-restrictions&quot;&gt;Field name restrictions&lt;/h2&gt;

&lt;p&gt;Django는 model field 이름에 단 두 가지 제약만이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;filed name은 Python reserved word가 될 수 없다. 왜냐하면 이는 Python syntax error를 발생시킬 것이다. 예시를 보자:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; class Example(models.Model):
 	pass = models.IntegerField() # 'pass' is a reserved word!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;field name은 두 개 이상의 underscore을 가질 수 없는데, 이는 Django의 query lookup syntax words이기 때문이다. 예시를 보자:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; class Example(models.Model):
 	foo__bar = models.IntegerField() # 'foo__bar' has two underscores!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 제약 사항들은 해결될 수 있는데, 왜냐하면 너의 field name은 너의 database column 이름과 꼭 어울릴 필요가 없기 때문이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;db_column&lt;/code&gt; option을 참조하여라.&lt;/p&gt;

&lt;p&gt;SQL reserved words, 예를 들어 &lt;strong&gt;join&lt;/strong&gt;, &lt;strong&gt;where&lt;/strong&gt; 또는 &lt;strong&gt;select&lt;/strong&gt;는 model field name으로 사용할 수 있는데, 왜냐하면 Django는 기본 SQL query에 있는 모든 database table 이름과 column 이름들을 직접적으로 사용하지 때문이다. 그것은 너의 특정 database 엔진의 quoting syntax를 사용한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;custom-field-types&quot;&gt;Custom field types&lt;/h2&gt;

&lt;p&gt;만약 기존에 존재하는 model fields들이 너의 목적에 맞게 사용할 수 없다면, 또는 너가 일반적으로 사용되지 않는 database column type을 이용하려면 너만의 자체 field class를 만들 수 있다. 고유의 field를 만드는 전체 방법은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Writing custom model fields&lt;/code&gt;에 나와 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;meta-options&quot;&gt;Meta options&lt;/h1&gt;

&lt;p&gt;inner &lt;strong&gt;class Meta&lt;/strong&gt;를 다음과 같이 사용하여 너의 model에게 metadata를 줄 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Ox(models.Model):
	horn_length = models.IntegerField()

	class Meta:
		ordering = [&quot;horn_length&quot;]
		verbose_name_plural = &quot;oxen&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Model의 metadata는 “field가 아닌 모든 것”이다. 예를 들어 ordering options(&lt;strong&gt;ordering&lt;/strong&gt;), database table name(&lt;strong&gt;db_table&lt;/strong&gt;), 또는 사람이 읽을 수 있는 복수형 또는 단수형 이름들(&lt;strong&gt;verbose_name&lt;/strong&gt; 그리고 &lt;strong&gt;verbose_name_plural&lt;/strong&gt;)이 있다. 모두 필수는 아니고 &lt;strong&gt;class Meta&lt;/strong&gt;를 model에 추가하는 것은 전적으로 optional이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Meta&lt;/strong&gt; option에 대한 전체 목록은 model option reference에서 확인 할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;model-attributes&quot;&gt;Model attributes&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;objects&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;model의 가장 중요한 attribute는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;이다. 이는 interface인데 database query operation들이 이를 통해 Django model로 제공되고 database로부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;retrieve the instances&lt;/code&gt; 하는데 사용된다. 만약 custom &lt;strong&gt;Manager&lt;/strong&gt;가 정의되지 않는다면, 초기 이름은 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;objects&lt;/code&gt;&lt;/strong&gt;이다. Managers은 model instance가 아니라, 단지 model class를 통해서만 접근 할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;model-methods&quot;&gt;Model methods&lt;/h1&gt;

&lt;p&gt;너의 obejcts를 위한 custom “row-leve” functionality를 model에 추가하기 위해 custom method를 정의해라. &lt;code class=&quot;highlighter-rouge&quot;&gt;**Manager**&lt;/code&gt; mehods들은 “table-wide” 관련 작업들을 하기 위해 만들어진 반면, model methods는 특정 model instance에 대해 작동한다.&lt;/p&gt;

&lt;p&gt;이는 business logic을 한 곳에 유지하기 위한 값진 기술이다 - the model&lt;/p&gt;

&lt;p&gt;예를 들어, 이 model은 몇 개의 custom method를 갖고 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Person(models.Moel):
	first_name = models.CharField(max_length=50)
	last_name = models.CharField(max_length=50)
	birth_date = models.DateField()

	def baby_boomer_status(self):
		&quot;Returns the person's baby-boomer status.&quot;
		import datetime
		if self.birth_date &amp;lt; datetime.date(1945, 8, 1):
			return &quot;Pre-boomer&quot;
		elif self.birth_date &amp;lt; datetime.date(1965, 1, 1):
			return &quot;Baby boomer&quot;
		else:
			return &quot;Post-boomer&quot;

	@property
	def full_name(self):
		&quot;Returns the person's full name.&quot;
		return '%s %s' % (self.first_name, self.last_name)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 예시의 마지막 method는 &lt;code class=&quot;highlighter-rouge&quot;&gt;property&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;model i&lt;code class=&quot;highlighter-rouge&quot;&gt;nstance reference&lt;/code&gt;에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;각각의 model에게 자동적으로 주어진 mothod&lt;/code&gt;들의 전체 리스트가 있다. 너는 이들을 override할 수 있다 - &lt;code class=&quot;highlighter-rouge&quot;&gt;overriding predefined model methods&lt;/code&gt;를 참고하라 - 그러나 너가 거의 항상 정의해야 할 몇 가지 method들이 있다:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;__str__()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;모든 object의 문자 표현을 반환하는 Python의 “magic method”이다. model instance가 순수 string으로 표현되어야 할 때마다 Python과 Django이 이를 호출할 것이다. 제일 알아 두어야 할 것은, 이는 너가 대화형 console이나 admin에 obejct를 표시해야 할 때 일어난다.&lt;/p&gt;

&lt;p&gt;너는 항상 이 mothod를 정의하고 싶어할 것이다; 초기 값이 전혀 도움이 되지 않기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;get_absolute_url()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이는 Django에게 한 object에 대해 URL을 계산하라 말한다. Django는 이를 그것의 admin interface 안에서 사용하고 한 object의 URL을 알아내야 할 때 필요하다.&lt;/p&gt;

&lt;p&gt;object를 고유하게 식별하는 URL을 가진 object는 이 method를 정의해야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;overriding-predefined-model-methods&quot;&gt;Overriding predefined model methods&lt;/h2&gt;

&lt;p&gt;customize 할 database 동작을 encapsulate하고 있는 또 다른 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;/code&gt; 집합이 있다. 특히 너는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;&lt;/strong&gt;와 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;delete()&lt;/code&gt;&lt;/strong&gt;가 동작하는 방법을 종종 바꾸고 싶을 것이다.&lt;/p&gt;

&lt;p&gt;너는 자유롭게 이 methods(그리고 다른 model methods) 역시 override할 수 있고 동작을 바꿀 수 있다.&lt;/p&gt;

&lt;p&gt;내장 method들을 override하는 전형적인 경우는 너가 object를 저장할 때마다 어떤 일이 일어나게 하고 싶을 때이다. 예시를 보자(&lt;code class=&quot;highlighter-rouge&quot;&gt;**save()**&lt;/code&gt;에서 받아들이는 parameter의 문서를 참조하라):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Blog(models.Model):
	name = models.CharField(max_length=100)
	tagline = models.TextFeild()

	def save(self, *args, **kwargs):
		do_something()
		super().save(*args, **kwargs)
		do_something_else()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너는 또한 잘못된 저장을 방지할 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Blog(models.Model):
	name = models.CharField(max_length=100)
	tagline = models.TextField()

	def save(self, *args, **kwargs):
		if self.name == &quot;Yoko One's blog&quot;:
			return # Yoko shall never have her own blog!
		else:
			super().save(*args, **kwargs) # Call the &quot;real&quot; save() method
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;database에 object가 저장되는 것을 확실히 하기 위해 superclass의 method를 호출해야 하는 것을 기억해야 한다 - 바로 &lt;strong&gt;super.save(*args, **kwargs)&lt;/strong&gt; 이다. 만약 너가 superclass의 method를 호출하는 것을 잊는다면, default behavior은 발생하지 않을 것이고 database는 변하지 않을 것이다.&lt;/p&gt;

&lt;p&gt;또한 model method 에 전달할 수 있는 parameter를 전달하는 것이 중요하다 - 이것이 바로 &lt;strong&gt;&lt;em&gt;args, **kwargs**들이 하는 것이다. Django는 수시로 새로운 argument를 추가하면서 내장된 model method 기능들을 확장한다. 만약 너가 method를 정의할 때 **&lt;/em&gt;args&lt;/strong&gt;, &lt;strong&gt;**kwargs&lt;/strong&gt;를 사용한다면, 너의 코드는 argument들이 추가될 때 자동적으로 이들을 지원할 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Overriden model methods are not called on bulk operations&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;deleting objects in bulk using a QuerySet&lt;/code&gt;을 하거나 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cascading delete&lt;/code&gt;&lt;/strong&gt;의 결과로 삭제 될 때 object의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;delete()&lt;/code&gt;&lt;/strong&gt; method는 필수적으로 호출 될 필요 없다. customized delete logic이 실행 되었는지 확인하고 싶다면, 너는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pre_delete&lt;/code&gt;&lt;/strong&gt; 또는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;post_delete&lt;/code&gt;&lt;/strong&gt;를 사용할 수 있다.&lt;/p&gt;

    &lt;p&gt;불행히도 bulk로 object를 creating과 updating 할 때는 해결할 수 있는 방법이 없다. 왜냐하면 &lt;strong&gt;save()&lt;/strong&gt;, &lt;strong&gt;pre_save&lt;/strong&gt;, 그리고 &lt;strong&gt;post_save&lt;/strong&gt; 그 어느 것도 호출되지 않기 때문이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;executing-custom-sql&quot;&gt;Executing custom SQL&lt;/h2&gt;

&lt;p&gt;다른 일반적인 패턴은 custom SQL statements를 model method와 module-level method에 작성하는 것이다. raw SQL을 사용하는데 더 세부적인 사항은 &lt;code class=&quot;highlighter-rouge&quot;&gt;using raw SQL&lt;/code&gt; 을 참조하여라.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;model-inheritance&quot;&gt;Model inheritance&lt;/h1&gt;

&lt;p&gt;Django에서의 model inheritance는 Python에서 일반적인 class inheritance와 거의 동일하게 작동하지만, 이 페이지의 시작 부분의 기초 사항들은 따라야 한다. 즉, base class 역시 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;django.db.models.Model&lt;/code&gt;&lt;/strong&gt;의 하위 클래스여야 한다.&lt;/p&gt;

&lt;p&gt;너가 결정해야 할 유일한 것은 너의 부모 model이 그 고유의 model(자신의 database table을 갖고 있는)이 될 것인지, 아니면 부모 model이 단지 자식 class들을 통해서만 볼 수 있는 공통된 정보들을 담고 있을 것인지이다.&lt;/p&gt;

&lt;p&gt;다음은 Django에서 가능한 세 가지 유형의 inheritance이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;종종 너는 부모 class를 사용하여 각 하위 model에 입력하고 싶지 않은 정보들을 보유하게 하기를 원할 것이다. 이 class는 따로 분리하여 사용하지 않으므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Abstract base classes&lt;/code&gt; 가 다음에 볼 내용이다.&lt;/li&gt;
  &lt;li&gt;만약 너가 이미 존재하는 model을 상속 받기 원하고(아마 완전히 다른 application으로 부터) 각각의 model이 그들의 database table을 갖고 있기를 원한다면, &lt;code class=&quot;highlighter-rouge&quot;&gt;Multi-table inheritnace&lt;/code&gt;를 살펴야 한다.&lt;/li&gt;
  &lt;li&gt;마지막으로 model field를 수정하지 않고 단지 model의 Python-level behavior를 수정하기 원한다면, 너는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Proxy models&lt;/code&gt;를 사용할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;abstract-base-classes&quot;&gt;Abstract base classes&lt;/h2&gt;

&lt;p&gt;abstract base classes는 다수의 다른 model들에게 공통된 정보들을 담고 싶을 때 유용하다. 너는 &lt;strong&gt;base class&lt;/strong&gt;를 작성하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class에 abstract=True라고 설정하면 된다. 그러면 이 model은 database를 만드는데 사용되지 않는다. 대신에 이것이 다른 model들을 위한 base class로 사용될 때, 이것의 field들이 child class의 field들에 추가된다.&lt;/p&gt;

&lt;p&gt;다음 예시를 보자 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class CommonInfo(models.Model):
	name = models.CharField(max_length=100)
	age = models.PositiveIntegerField()

		class Meta:
			abstract= True

class Student(CommonInfo):
	home_group = models.CharField(max_length=5)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Student&lt;/strong&gt; model은 세 가지 field를 갖게 될 것이다: &lt;strong&gt;name&lt;/strong&gt;, &lt;strong&gt;age&lt;/strong&gt;, 그리고 &lt;strong&gt;home_group&lt;/strong&gt;이다. &lt;strong&gt;CommonInfo&lt;/strong&gt; model은 보통의 Django model처럼 사용될 수 없는데, 이것은 abstract base class이기 때문이다. 이것은 database table을 생성하지 않고 manager를 갖고 있지 않으며 instantiated 될 수 없고 직접적으로 저장 될 수 없다.&lt;/p&gt;

&lt;p&gt;abstract base classes로부터 상속된 fields들은 또 다른 field나 값으로 override 할 수 있고 &lt;strong&gt;None&lt;/strong&gt;으로 제거 할 수 있다.&lt;/p&gt;

&lt;p&gt;많은 용도로 이런 종류의 model inheritance는 너가 정확히 원하는 것일 것이다. 이것은 Python level에서 공통 정보를 분석하는 방법을 제공하면서 동시에 database level에서는 자식 model 당 하나의 database table을 만든다.&lt;/p&gt;

&lt;h2 id=&quot;meta-inheritance&quot;&gt;Meta inheritance&lt;/h2&gt;

&lt;p&gt;abstract base class가 생성될 때, Django는 base class에서 선언 한 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; inner class를 attribute로 사용할 수 있게 한다. 만약 자식 class가 그것 고유의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class를 선언하지 않았을 경우, 그것은 부모의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt;를 상속받는다. 만약 자식이 부모의 Meta class를 extend하고 싶다면, 상속받으면 된다. 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class CommonInfo(models.Model):
	# ...
	class Meta:
		abstract = True
		ordering = ['name']

class Student(CommonInfo):
	# ...
	class Meta(CommonInfo.Meta):
		db_table = 'student_info'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Django는 abstract base class의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class에 단 하나의 값을 조정 해준다: &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; attribute를 installing하기 전에, &lt;strong&gt;abstract=False&lt;/strong&gt;로 설정한다. 이것은 abstract base classes의 자식들이 자동적으로 abstract class가 되지 않는다는 것을 의미한다. 물론, 너는 다른 abstract base class로부터 상속받는 또 다른 abstract base class를 만들 수 있다. 단지 매번 명시적으로 abstract=True라고 설정해야 한다는 것을 기억하면 된다.&lt;/p&gt;

&lt;p&gt;몇몇 attribute들은 abstract base class의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class 안에 있기에 부적합하다. 예를 들어 &lt;strong&gt;db_table&lt;/strong&gt;을 포함한다는 것은 (그들 고유의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt;를 명시하지 않은) 모든 자식 classes이 모두 같은 database table을 이용한다는 것인데, 이것은 너가 원하는 작업 아닐 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;be-careful-with-related_name-and-related_query_name&quot;&gt;Be careful with related_name and related_query_name&lt;/h2&gt;

&lt;p&gt;만약 너가 &lt;strong&gt;ForeignKey&lt;/strong&gt; 또는 &lt;strong&gt;ManyToManyField&lt;/strong&gt;에서 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_name&lt;/code&gt;&lt;/strong&gt; 또는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_query_name&lt;/code&gt;&lt;/strong&gt;을 사용한다면, 너는 항상 반드시 field에 대한 &lt;em&gt;unique&lt;/em&gt; reverse name과 query name을 명시해 주어야 한다. 이것은 보통 abstract base class에서 문제를 유발하는데, 이 class에 있는 field들이 매번 같은 값의 attribute(&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_name&lt;/code&gt;&lt;/strong&gt;과 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_query_name&lt;/code&gt;&lt;/strong&gt;을 포함해서)로 각각의 자식 class에 포함되기 때문이다.&lt;/p&gt;

&lt;p&gt;abstract base class에서 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_name&lt;/code&gt;&lt;/strong&gt; 또는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_query_name&lt;/code&gt;&lt;/strong&gt;을 사용할 때 이 문제를 해결하기 위해서는, value의 일부분이 ‘&lt;strong&gt;%(app_label)s&lt;/strong&gt;‘와 ‘&lt;strong&gt;%(class)s&lt;/strong&gt;‘를 포함하고 있어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;‘&lt;strong&gt;%(class)s&lt;/strong&gt;‘는 field가 사용되는 자식 class의 소문자 이름으로 대체된다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;’%(app_label)s’&lt;/strong&gt;는 자식 class가 포함되어 있는 app의 소문자 이름으로 대체된다. 각각의 installed applicatoin은 유일하고 app 안에 있는 model class 이름도 유일한 것이 틀림 없기에, 최종 이름은 서로 다르게 될 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어 &lt;strong&gt;comon/models.py&lt;/strong&gt;에 다음과 같은 app이 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Base(models.Model):
	m2m = models.ManyToManyField(
		OtherModel,
		related_name=&quot;%(app_label)s_%(class)s_related&quot;,
		related_query_name=&quot;%(app_label)s_%(class)ss&quot;,
	)
	
	class Meta:
		abstract = True

class ChildA(Base):
	pass

class ChildB(Base):
	pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;rare/models.py&lt;/strong&gt;에도 다음 app이 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from common.models import Base

class ChildB(Base):
	pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;common.ChildA.m2m&lt;/strong&gt; field의 reverse name은 &lt;strong&gt;common_childa_related&lt;/strong&gt;가 될 것이고 reverse query name은 &lt;strong&gt;common_childas&lt;/strong&gt;가 될 것이다. &lt;strong&gt;common.childB.m2m&lt;/strong&gt; field의 reverse name은 &lt;strong&gt;common_childb_related&lt;/strong&gt;가 될 것이고 reverse query name은 &lt;strong&gt;common_chlidbs&lt;/strong&gt;가 될 것이다. 마지막으로 &lt;strong&gt;rare.ChildB.m2m&lt;/strong&gt; field의 reverse name은 &lt;strong&gt;rare_childb_related&lt;/strong&gt;가 될 것이고 reverse query name은 &lt;strong&gt;rare_childbs&lt;/strong&gt;가 될 것이다. 너의 related name이나 related query name을 구성하기 위해 ‘&lt;strong&gt;%(class)s&lt;/strong&gt;‘와 &lt;strong&gt;’%(app_label)s’&lt;/strong&gt; 부분들을 어떻게 사용하는지는 너에게 달려있지만, 만약 너가 그것의 사용을 잊어버린다면, Django는 너가 system check(또는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;migrate&lt;/code&gt;&lt;/strong&gt;)를 사용할 때 error를 일으킬 것이다.&lt;/p&gt;

&lt;p&gt;만약 너가 abstract base class의 field에 대한 &lt;code class=&quot;highlighter-rouge&quot;&gt;**related_name**&lt;/code&gt; attribute를 명시하지 않았다면, default reverse name은 child class 이름 뒤에 &lt;strong&gt;‘_set’&lt;/strong&gt;이 붙은 것이 될 것이고, 너가 child class에 직접적으로 선언한 것처럼 정상적으로 작동할 것이다. 예를 들어 위의 코드에서, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_name&lt;/code&gt;&lt;/strong&gt; attribute가 생략 되었다면, &lt;strong&gt;m2m&lt;/strong&gt; field의 reverse name은 &lt;strong&gt;ChildA&lt;/strong&gt;의 경우 &lt;strong&gt;childa_set&lt;/strong&gt;이 될 것이고 &lt;strong&gt;ChildB&lt;/strong&gt;의 경우 &lt;strong&gt;childb_set&lt;/strong&gt;이 될 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;multi-table-inheritance&quot;&gt;Multi-table inheritance&lt;/h2&gt;

&lt;p&gt;Django에서 지원하는 두 번째 타입의 model inheritance는 계층 구조의 각 model이 모두 하나의 model일 때이다. 각각의 model은 그들 고유의 database table에 대응되고 독립적으로 queried 되고 생성될 수 있다. inheritance relationship은 자식 model과 그들의 부모 사이의 links를 소개한다(자동적으로 생성되는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;를 통해서). 예시를 보자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Place(models.Model):
	name = models.CharField(max_length=50)
	address = models.CharField(max_length=80)

class Restaurant(Place):
	serves_hot_dogs = models.BooleanField(default=False)
	serves_pizza = models.BooleanField(default=False)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;data들은 서로 다른 database table에 있음에도 불구하고 &lt;strong&gt;Place&lt;/strong&gt;의 모든 field들은 &lt;strong&gt;Restaurant&lt;/strong&gt;에서도 모두 이용 가능하다. 따라서 다음 두 가지가 모두 가능하다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Place.objects.filter(name=&quot;Bob's Cafe&quot;)
&amp;gt;&amp;gt;&amp;gt; Restaurant.objects.filter(name=&quot;Bob's Cafe&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 너가 &lt;strong&gt;Restaurant&lt;/strong&gt; 이기도 한 &lt;strong&gt;Place&lt;/strong&gt;를 갖고 있다면, 너는 &lt;strong&gt;Place&lt;/strong&gt; object로부터 소문자 model 이름을 이용함으로써 &lt;strong&gt;Restaurant&lt;/strong&gt; object를 얻을 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; p = Place.objects.get(id=12)
# If p is a Restaurant obejct, this will give the child class:
&amp;gt;&amp;gt;&amp;gt; p.restaurant
&amp;lt;Restaurant: ...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러나 만약 위 예시에서의 &lt;strong&gt;p&lt;/strong&gt;가 &lt;strong&gt;Restaurant&lt;/strong&gt;가 아니라면(그것이 &lt;strong&gt;Place&lt;/strong&gt; object로 직접적으로 생성되었거나 다른 class의 부모였다면), &lt;strong&gt;p.restaurant&lt;/strong&gt;를 호출하는 것은 &lt;strong&gt;Restaurant.DoesNotExist&lt;/strong&gt; exception을 일으킬 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Restaurant&lt;/strong&gt;에 자동적으로 생성된 &lt;strong&gt;Place&lt;/strong&gt;로 link해주는 &lt;strong&gt;OneToOneField&lt;/strong&gt;는 다음과 같이 생겼다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;place_ptr = models.OneToOneField(
	Place, on_delete=models.CASCADE,
	parent_link=True,
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너는 해당 field를 &lt;strong&gt;Restaurant&lt;/strong&gt;에 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;parent_link=True&lt;/code&gt;&lt;/strong&gt; 와 함께 고유의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;를 선언함으로써 override할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Meta and multi-table inheritance&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;multi-table inheritance의 경우에, 자식 class에서 부모의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class를 상속받는 것은 말이 되지 않는다. 모든 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; option들은 이미 부모 class에 적용되었고, 그들을 다시 적용하는 것은 보통 모순적인 행동으로 보일 것이다(이것은 abstract base class와는 반대인데, base class는 그들 스스로는 존재하지 않는다).&lt;/p&gt;

&lt;p&gt;따라서 자식 model은 그들 부모의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class에 접근할 수 없다. 그러나 부모로부터 몇 가지 행동을 상속받는 경우가 있다: 만약 자식이 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ordering&lt;/code&gt;&lt;/strong&gt; attribute 또는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get_latest_by&lt;/code&gt;&lt;/strong&gt; attribute를 명시하지 않는다면, 자식은 부모로부터 이들을 상속받을 것이다.&lt;/p&gt;

&lt;p&gt;만약 부모가 ordering을 갖고 있고 너는 자식이 아무런 ordering을 갖지 않기를 원하면, 명시적으로 사용을 중단 할 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ChildModel(ParentModel):
	# ...
	class Meta:
		# Remove parent's ordering effect
		ordering = []
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Inheritance and reverse relations&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;multi-table inheritance가 자식과 부모를 link하기 위해 암묵적인 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;를 사용했기 때문에, 위의 예시처럼 부모에서 자식으로 내려가는 것이 가능하다. 하지만, 이는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt; 와 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;의 default &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_name&lt;/code&gt;&lt;/strong&gt; 값을 사용해 나간다. 만약 너가 부모의 자식 class에 이런 종류의 relations를 둔다면, 너는 반드시 각각의 field에 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;related_name&lt;/code&gt;&lt;/strong&gt; attribute를 명시해야 한다. 만약 그렇지 않으면, Django는 validation error를 일으킬 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어, 위의 &lt;strong&gt;Place&lt;/strong&gt; class 를 다시 사용하여 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;&lt;/strong&gt;를 이용한 다른 자식 class를 만들자:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Supplier(Place):
	customers = models.ManyToManyField(Place)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음은 error 결과이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Reverse query name for 'Supplier.customers'
clashes with reverse query
name for 'Supplier.place_ptr'.

HINT: Add or Change a related_name argument to the fefinition for
'Supplier.customers' or 'Supplier.place_ptr'.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같이 &lt;strong&gt;customers&lt;/strong&gt; field에 &lt;strong&gt;related_name&lt;/strong&gt;을 추가 해주는 것은 error를 해결할 수 있다: &lt;strong&gt;models.ManyToManyField(Place, related_name=’provider’)&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Specifying the parent link field&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;위에서 말했듯이, Django는 너의 자식 class와 그 어떤 non-abstract parent model과 연결해주는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;를 자동적으로 생성할 것이다. 만약 다시 부모로 연결해주는 attribute 이름을 제어하고 싶은 경우, 너는 너만의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;&lt;/strong&gt;를 생성하고 너의 field가 부모 class를 다시 가리키도록 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;parent_link=True&lt;/code&gt;&lt;/strong&gt;라고 설정하면 된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;proxy-models&quot;&gt;Proxy models&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;multi-table inheritance&lt;/code&gt;를 사용할 때, 새로운 database table은 한 model의 각각의 하위 class에 대해 생긴다. 이는 보통 이상적인 행동인데, 이는 하위 class가 base class에 존재하지 않는 추가적인 data field를 저장할 공간을 필요로 하기 때문이다. 하지만 때때로, 너는 단지 한 model의 Python 동작을 바꾸고 싶을 것이다 - 아마 default manager를 바꾸거나 새로운 method를 추가할 것이다.&lt;/p&gt;

&lt;p&gt;이는 proxy model inheritance을 위한 것이다: 원래 model에 &lt;em&gt;proxy&lt;/em&gt;를 생성하는 것이다. 너는 proxy model의 instances를 생성하고 삭제하고 업데이트 할 수 있으며, 모든 data들은 너가 원래의 (non-proxied) model을 사용하는 것과 같이 저장된다. 차이점은 원래의 것을 변경하지 않고, proxy에서 default model ordering 또는 default manager과 같은 것들을 바꿀 수 있다는 점이다.&lt;/p&gt;

&lt;p&gt;Proxy model들은 보통의 model들과 같이 선언될 수 있다. 너는 Django에게 &lt;strong&gt;Meta&lt;/strong&gt; class의 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proxy&lt;/code&gt;&lt;/strong&gt; attribute을 &lt;strong&gt;True&lt;/strong&gt;로 설정함으로써 알려줄 수 있다.&lt;/p&gt;

&lt;p&gt;예를 들어, Person model에 method를 추가하고 싶다고 가정하자. 너는 다음과 같이 할 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Person(models.Model):
	first_name = models.CharField(max_length=30)
	last_name = models.CharField(max_length=30)

class MyPerson(Person):
	class Meta:
		proxy = True

	def do_something(self):
		# ...
		pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;MyPerson&lt;/strong&gt; class는 그것의 부모 &lt;strong&gt;Person&lt;/strong&gt; class와 같은 database table에서 작동한다. 특히, 모든 새로운 Person instance들 또한 MyPerson을 통해 접근 가능하고, 반대의 경우도 가능하다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; p = Person.objects.create(first_name=&quot;foobar&quot;)
&amp;gt;&amp;gt;&amp;gt; MyPerson.objects.get(first_name=&quot;foobar&quot;)
&amp;lt;MyPerson: foobar&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너는 또한 model에서 다른 default ordering을 정의하기 위해 proxy model을 사용할 수 있다. 너는 아마 항상 &lt;strong&gt;Person&lt;/strong&gt; model을 정렬하고 싶지 않을 수 있지만, proxy를 사용할 때 규칙적으로 &lt;strong&gt;last_name&lt;/strong&gt; attribute를 이용하여 정렬할 수 있다. 이것은 쉽다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class OrderedPerson(Person):
	class Meta:
		ordering = [&quot;last_name&quot;]
		proxy = True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 보통의 &lt;strong&gt;Person&lt;/strong&gt; queries는 정렬되지 않지만, &lt;strong&gt;OrderedPerson&lt;/strong&gt; queries는 &lt;strong&gt;last_name&lt;/strong&gt;에 의해 정렬될 것이다.&lt;/p&gt;

&lt;p&gt;Proxy model은 &lt;code class=&quot;highlighter-rouge&quot;&gt;보통의 model들과 같은 방법으로&lt;/code&gt; &lt;strong&gt;Meta&lt;/strong&gt; attribute를 상속 받는다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;QuerySets still return the model that was requested&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;말하자면, 너가 &lt;strong&gt;Person&lt;/strong&gt; objects를 query 할 때마다 Django가 &lt;strong&gt;MyPerson&lt;/strong&gt; object를 반환하게 하는 방법은 없다. &lt;strong&gt;Person&lt;/strong&gt; objects의 queryset은 그 타입의 objects를 반환할 것이다. proxy objects의 요점은 원래의 Person에 의존적인 코드는 proxy objects를 사용할 것이라는 점과 너 고유의 코드는 너가 추가한 extension들을 사용할 수 있다는 점이다(다른 코드는 그다지 의존적이지 않다). 이는 Person (또는 어떠한 다른) model을 너가 만든 다른 것으로 대체할 수 있는 것이 아니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Base class restrictions&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;proxy model은 반드시 하나의non-abstract model class로
 부터 상속을 받아야 한다. 너는 여러 개의 non-abstract models로부터 상속받을 수 없는데, 이는 proxy model은 다른 database table에 있는 rows들 간의 어떤 연결도 제공하지 않기 때문이다. abstract model classes이 어떠한 model fields도 정의하지 않았다면, proxy model은 많은 수의 abstract model classes을 상속할 수 있다. 한 proxy model은 공통의 한 non-abstract 부모 class를 공유하고 있는 여러 proxy models로부터 상속 받을 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Proxy model managers&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 너가 한 proxy model에 어떠한 model manager도 명시하지 않는다면, 그것은 그것의 model parents로부터 managers를 상속한다. 만약 너가 proxy model에 manager를 정의한다면, 그것은 default가 될 것이지만,  부모 classes에 정의된 어떠한 manager도 여전히 사용 가능하다.&lt;/p&gt;

&lt;p&gt;위의 예시를 이어 가자면, 너는 다음과 같이 &lt;strong&gt;Person&lt;/strong&gt; model을 query할 때 default manager를 바꿀 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class NewManager(models.Manager):
	# ...
	pass

class MyPerson(Person):
	objects = NewManager()

	class Meta:
		proxy = True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 proxy에 이미 존재하는 default를 대체하지 않고 새로운 manager를 추가하고 싶다면, 너는 &lt;code class=&quot;highlighter-rouge&quot;&gt;custom manager&lt;/code&gt; 문서에 기술된 방법들을 사용할 수 있다: 새로운 manager를 갖고 있는 base class를 생성한 뒤에 primary base class 이후에 상속 받아라.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Create an abstract class for the new manager.
class ExtraManagers(models.Model):
	secondary = NewManager()
	
	class Meta:
		abstract = True

class MyPerson(Person, ExtraManagers):
	class Meta:
		proxy = True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;너는 이를 자주 필요로 하지는 않을 것이지만, 너가 하고 싶을 때 이는 가능하다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Differences between proxy inheritance and unmanaged models&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;proxy model inheritance는 model의 &lt;strong&gt;Meta&lt;/strong&gt; class에 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;managed&lt;/code&gt;&lt;/strong&gt; attribute를 사용하여 unmanaged model을 생성하는 것과 비슷하게 보인다.&lt;/p&gt;

&lt;p&gt;조심스럽게 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Meta.db_table&lt;/code&gt;&lt;/strong&gt;를 설정하여 너는 기존의 model을 가리고 Python method를 거기에 추가할 수 있는 unmanaged model을 생성할 수 있다. 그러나 변경 작업을 수행하면 두 복사본을 동기화 된 상태로 유지해야 하므로 반복적이고 오류가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;다른 한편으로는 proxy model은 proxing 하고 있는 모델과 똑같이 행동하도록 만들어졌다. 그들은 부모 model과 항상 동기화 되어 있는데 그들이 직접적으로 그들의 field와 manager를 상속 받았기 때문이다.&lt;/p&gt;

&lt;p&gt;일반적인 규칙은 다음과 같다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;만약 기존의 model과 database table을 mirroring하고 기존의 모든 database table column들을 원하지 않는다면, Meta.managed=False를 써라. 이 option은 Django가 제어하지 않는 database view와 table을 modeling 할 때 유용하다.&lt;/li&gt;
  &lt;li&gt;만약 너가 model의 Python-only 동작을 변경하고 싶지만, 기존 model의 field를 유지하고 싶다면, Meta.proxy=True를 사용해라. 이는 data가 저장될 때 proxy model의 저장소 구조와 정확히 일치하도록 설정된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;multiple-inheritance&quot;&gt;Multiple inheritance&lt;/h2&gt;

&lt;p&gt;Python의 하위 class와 마찬가지로, Django model이 여러 개의 부모 model로부터 상속 받는 것이 가능하다. 일반적인 Python name resolution rule이 적용된다는 것을 명심해라. 특정 이름(e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt;)가 나타나는 첫 base class가 사용될 것이다. 예를 들어, 이것은 만약 여러 부모 class가 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; class를 포함하고 있다면, 첫 번째 것이 사용될 것이며 다른 것들은 모두 무시될 것이다.&lt;/p&gt;

&lt;p&gt;일반적으로, 너는 다수의 부모로부터 상속 받을 필요가 없다. 일반적으로 유용하게 사용되는 경우는 “mix-in” class를 사용할 때이다: mix-in을 상속하고 있는 모든 class에 특정 추가적 field와 method를 추가하는 것이다. 너의 inheritance hierarchies를 가능한 간단하고 직관적으로 유지하여 특정 정보가 어디로부터 왔는지 헷갈리지 않게 해라.&lt;/p&gt;

&lt;p&gt;공통된 &lt;strong&gt;id&lt;/strong&gt; primary key field를 갖고 있는 다양한 model로부터 상속을 받는 것은 error를 일으킬 것이다. 올바르게 multiple inheritance를 사용하기 위해, 너는 base model에 명시적으로 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AutoField&lt;/code&gt;&lt;/strong&gt;를 쓸 수 있다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Article(models.Model):
	article_id = models.AutoField(primary_key=True)
	...

class Book(models.Model):
	book_id = models.AutoField(primary_key=True)
	...

class BookReview(Book, Article):
	pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또는 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AutoField&lt;/code&gt;&lt;/strong&gt;를 갖고 있는 공통의 ancestor를 사용해라. 이는 각각의 부모 model에서 공통의 ancestor로의 OneToOneField를 명시적으로 사용하는 것을 요구하는데, 자동으로 생성되고 자식으로부터 상속받는 field들 간의 충돌을 피하기 위해서이다:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Piece(models.Model):
	pass

class Article(Piece):
	article_piece = models.OneToOneField(Piece, on_delete=models.CASCADE, parent_link=True)
	...

class Book(Piece):
	book_piece = models.OneToOneField(Piece, on_delete=models.CASCADE, parent_link=True)
	...

class BookReivew(Book, Article):
	pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;field-name-hiding-is-not-permitted&quot;&gt;Field name “hiding” is not permitted&lt;/h2&gt;

&lt;p&gt;보통의 Python inheritance에서, 자식 class는 부모 class로부터 어떠한 attribute를 override하는 것이 허용된다. Django에서 이것은 model fields에 대하여 주로 허락되지 않는다. 만약 non-abstract class가 &lt;strong&gt;author&lt;/strong&gt;이라 된 field를 갖고 있다면, 너는 그 base class로부터 상속 받은 다른 class에 &lt;strong&gt;author&lt;/strong&gt;이라 불리는 다른 model field나 attribute를 생성할 수 없다.&lt;/p&gt;

&lt;p&gt;이 제약은 abstract model로부터 상속 받은 model field에는 적용되지 않는다. 이러한 field들을 다른 field나 값으로 override 할 수 있고, &lt;strong&gt;field_nam = None&lt;/strong&gt;으로 설정하여 제거 할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;model manager는 abstract base class로 부터 상속된다. 상속된 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;&lt;/strong&gt;에 의해 참조되는 상속된 field를 override하는 것은 미묘한 bug를 일으킬 수 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;custom managers and model inheritance&lt;/code&gt;를 보아라.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;몇몇의 fields들은 model에 추가적인 attribute를 정의한다. 예를 들어 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;&lt;/strong&gt;는 field 이름에 &lt;strong&gt;_id&lt;/strong&gt;가 추가된 별도의 attribute를 정의할 뿐만 아니라 &lt;strong&gt;related_name&lt;/strong&gt; 과 &lt;strong&gt;relate_query_name&lt;/strong&gt; 을 foreign model에 정의한다.&lt;/p&gt;

    &lt;p&gt;이런 추가적인 attributes들은 그것을 정의한 field가 바뀌거나 제거되어 더 이상 추가적인 attribute를 정의하지 않는 이상 override할 수 없다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;부모 model의 field를 override하는 것은 (&lt;strong&gt;Model.__init__&lt;/strong&gt;에서 어떤 field가 initialized 될지를 명시하는) 새로운 instance를 initializing 하는 것과 serialization과 같은 영역에 어려움이 있다. 이것들은 Python class inheritance가 똑같은 방식으로 처리 할 필요가 없는 기능이므로, Django model inheritance와 Python class inheritance는 임의적이지 않다.&lt;/p&gt;

&lt;p&gt;이런 제약은 단지 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Field&lt;/code&gt;&lt;/strong&gt; instances인 attribute에만 적용된다. 보통의 Python attribute는 너가 원한다면 Override할 수 있다. 또한 이것은 Python 이 인식하는 attribute 이름에만 적용된다: 만약 너가 직접 database column 이름을 설정한다면, 너는 mutli-table inheritance의 child와 ancestor model에 나타나는 같은 column name을 가질 수 있다(이들은 서로 다른 database table의 column들이다).&lt;/p&gt;

&lt;p&gt;Django는 만약 너가 ancestor model에 있는 어떠한 model field를 override하면 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FieldError&lt;/code&gt;&lt;/strong&gt;를 일으킬 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;organizing-models-in-a-package&quot;&gt;Organizing models in a package&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;manage.py startapp&lt;/code&gt;&lt;/strong&gt; command는 &lt;strong&gt;models.py&lt;/strong&gt; 파일을 갖고 있는 application 구조를 생성한다. 만약 너가 많은 models을 갖고 있다면, 그들을 다른 파일에 구성하는 것이 효과적일 것이다.&lt;/p&gt;

&lt;p&gt;이렇게 하기 위해서는 &lt;strong&gt;models&lt;/strong&gt; package를 만들어라. &lt;strong&gt;models.py&lt;/strong&gt;를 삭제하고 &lt;strong&gt;myapp/models/&lt;/strong&gt; directory를 &lt;strong&gt;__init__.py&lt;/strong&gt; 파일과 너의 models를 저장할 파일들과 함께 만들어라. 너는 model들을 &lt;strong&gt;__init__.py&lt;/strong&gt; 파일에 import 해야 한다.&lt;/p&gt;

&lt;p&gt;예를 들어, 만약 너가 models directory에 &lt;strong&gt;organic.py&lt;/strong&gt;와 &lt;strong&gt;synthetic.py&lt;/strong&gt;를 갖고 있다면 다음과 같다:&lt;/p&gt;

&lt;p&gt;myapp/models/&lt;strong&gt;init&lt;/strong&gt;.py&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from .organic import Person
from .synthetic import Robot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;from .models import *를 사용하는 것보다 명시적으로 각각의 model을 import하는 것이 namespace를 어질러놓지 않을 수 있고, 코드를 더욱 읽기 쉽게 만들어주며, code analysis tools를 효과적으로 만들어준다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;See also&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;The Models Reference&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;model fields, related objects, 그리고 &lt;strong&gt;QuerySet&lt;/strong&gt;을 포함해서 모든 model 관련 API를 다루고 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Seonkyu Kim(김선규)</name></author><category term="django reference" /><summary type="html">Introduction to models</summary></entry><entry><title type="html">Test1</title><link href="http://localhost:4000/test1/" rel="alternate" type="text/html" title="Test1" /><published>2018-01-01T00:00:00+09:00</published><updated>2018-01-01T00:00:00+09:00</updated><id>http://localhost:4000/test1</id><content type="html" xml:base="http://localhost:4000/test1/">&lt;p&gt;everyone&lt;/p&gt;</content><author><name>Seonkyu Kim(김선규)</name></author><summary type="html"></summary></entry></feed>